#library('html');

#import('dart:dom', prefix:'dom');
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// DO NOT EDIT
// Auto-generated dart:html library.






_WindowImpl __window;
_DocumentImpl __document;

void _initialize() {
  __window = _wrap(dom.window);
  __document = _wrap(dom.document);
}

Window get window() {
  if (__window == null) {
    _initialize();
  }
  return __window;
}

Document get document() {
  if (__document == null) {
    _initialize();
  }
  return __document;
}

_WindowImpl get _window() {
  if (__window == null) {
    _initialize();
  }
  return __window;
}

_DocumentImpl get _document() {
  if (__document == null) {
    _initialize();
  }
  return __document;
}

_unwrap(raw) {
  return raw is _DOMTypeBase ? raw._ptr : raw;
}

// Warning: does not attempt wrap event listeners.
_wrap(raw) {
  if (raw is! dom.DOMType) return raw;
  dom.DOMType domObject = raw;
  if (domObject.dartObjectLocalStorage != null)
    return domObject.dartObjectLocalStorage;
  switch(domObject.typeName) {
    case 'HTMLElement':
      return new _UnknownElementImpl._wrap(domObject);
    case 'EventTarget': return new _EventTargetImpl._wrap(domObject);
    case 'AbstractWorker': return new _AbstractWorkerImpl._wrap(domObject);
    case 'Node': return new _NodeImpl._wrap(domObject);
    case 'NodeSelector': return new _NodeSelectorImpl._wrap(domObject);
    case 'ElementTraversal': return new _ElementTraversalImpl._wrap(domObject);
    case 'Element': return new _ElementImpl._wrap(domObject);
    case 'HTMLAnchorElement': return new _AnchorElementImpl._wrap(domObject);
    case 'WebKitAnimation': return new _AnimationImpl._wrap(domObject);
    case 'Event': return new _EventImpl._wrap(domObject);
    case 'WebKitAnimationEvent': return new _AnimationEventImpl._wrap(domObject);
    case 'WebKitAnimationList': return new _AnimationListImpl._wrap(domObject);
    case 'HTMLAppletElement': return new _AppletElementImpl._wrap(domObject);
    case 'HTMLAreaElement': return new _AreaElementImpl._wrap(domObject);
    case 'ArrayBuffer': return new _ArrayBufferImpl._wrap(domObject);
    case 'ArrayBufferView': return new _ArrayBufferViewImpl._wrap(domObject);
    case 'Attr': return new _AttrImpl._wrap(domObject);
    case 'AudioBuffer': return new _AudioBufferImpl._wrap(domObject);
    case 'AudioNode': return new _AudioNodeImpl._wrap(domObject);
    case 'AudioSourceNode': return new _AudioSourceNodeImpl._wrap(domObject);
    case 'AudioBufferSourceNode': return new _AudioBufferSourceNodeImpl._wrap(domObject);
    case 'AudioChannelMerger': return new _AudioChannelMergerImpl._wrap(domObject);
    case 'AudioChannelSplitter': return new _AudioChannelSplitterImpl._wrap(domObject);
    case 'AudioContext': return new _AudioContextImpl._wrap(domObject);
    case 'AudioDestinationNode': return new _AudioDestinationNodeImpl._wrap(domObject);
    case 'HTMLMediaElement': return new _MediaElementImpl._wrap(domObject);
    case 'HTMLAudioElement': return new _AudioElementImpl._wrap(domObject);
    case 'AudioParam': return new _AudioParamImpl._wrap(domObject);
    case 'AudioGain': return new _AudioGainImpl._wrap(domObject);
    case 'AudioGainNode': return new _AudioGainNodeImpl._wrap(domObject);
    case 'AudioListener': return new _AudioListenerImpl._wrap(domObject);
    case 'AudioPannerNode': return new _AudioPannerNodeImpl._wrap(domObject);
    case 'AudioProcessingEvent': return new _AudioProcessingEventImpl._wrap(domObject);
    case 'HTMLBRElement': return new _BRElementImpl._wrap(domObject);
    case 'BarInfo': return new _BarInfoImpl._wrap(domObject);
    case 'HTMLBaseElement': return new _BaseElementImpl._wrap(domObject);
    case 'HTMLBaseFontElement': return new _BaseFontElementImpl._wrap(domObject);
    case 'BatteryManager': return new _BatteryManagerImpl._wrap(domObject);
    case 'BeforeLoadEvent': return new _BeforeLoadEventImpl._wrap(domObject);
    case 'BiquadFilterNode': return new _BiquadFilterNodeImpl._wrap(domObject);
    case 'Blob': return new _BlobImpl._wrap(domObject);
    case 'HTMLBodyElement': return new _BodyElementImpl._wrap(domObject);
    case 'HTMLButtonElement': return new _ButtonElementImpl._wrap(domObject);
    case 'CharacterData': return new _CharacterDataImpl._wrap(domObject);
    case 'Text': return new _TextImpl._wrap(domObject);
    case 'CDATASection': return new _CDATASectionImpl._wrap(domObject);
    case 'CSSRule': return new _CSSRuleImpl._wrap(domObject);
    case 'CSSCharsetRule': return new _CSSCharsetRuleImpl._wrap(domObject);
    case 'CSSFontFaceRule': return new _CSSFontFaceRuleImpl._wrap(domObject);
    case 'CSSImportRule': return new _CSSImportRuleImpl._wrap(domObject);
    case 'WebKitCSSKeyframeRule': return new _CSSKeyframeRuleImpl._wrap(domObject);
    case 'WebKitCSSKeyframesRule': return new _CSSKeyframesRuleImpl._wrap(domObject);
    case 'WebKitCSSMatrix': return new _CSSMatrixImpl._wrap(domObject);
    case 'CSSMediaRule': return new _CSSMediaRuleImpl._wrap(domObject);
    case 'CSSPageRule': return new _CSSPageRuleImpl._wrap(domObject);
    case 'CSSValue': return new _CSSValueImpl._wrap(domObject);
    case 'CSSPrimitiveValue': return new _CSSPrimitiveValueImpl._wrap(domObject);
    case 'CSSRuleList': return new _CSSRuleListImpl._wrap(domObject);
    case 'CSSStyleDeclaration': return new _CSSStyleDeclarationImpl._wrap(domObject);
    case 'CSSStyleRule': return new _CSSStyleRuleImpl._wrap(domObject);
    case 'StyleSheet': return new _StyleSheetImpl._wrap(domObject);
    case 'CSSStyleSheet': return new _CSSStyleSheetImpl._wrap(domObject);
    case 'CSSValueList': return new _CSSValueListImpl._wrap(domObject);
    case 'WebKitCSSTransformValue': return new _CSSTransformValueImpl._wrap(domObject);
    case 'CSSUnknownRule': return new _CSSUnknownRuleImpl._wrap(domObject);
    case 'HTMLCanvasElement': return new _CanvasElementImpl._wrap(domObject);
    case 'CanvasGradient': return new _CanvasGradientImpl._wrap(domObject);
    case 'CanvasPattern': return new _CanvasPatternImpl._wrap(domObject);
    case 'CanvasRenderingContext': return new _CanvasRenderingContextImpl._wrap(domObject);
    case 'CanvasRenderingContext2D': return new _CanvasRenderingContext2DImpl._wrap(domObject);
    case 'ClientRect': return new _ClientRectImpl._wrap(domObject);
    case 'ClientRectList': return new _ClientRectListImpl._wrap(domObject);
    case 'Clipboard': return new _ClipboardImpl._wrap(domObject);
    case 'CloseEvent': return new _CloseEventImpl._wrap(domObject);
    case 'Comment': return new _CommentImpl._wrap(domObject);
    case 'UIEvent': return new _UIEventImpl._wrap(domObject);
    case 'CompositionEvent': return new _CompositionEventImpl._wrap(domObject);
    case 'Console': return new _ConsoleImpl._wrap(domObject);
    case 'HTMLContentElement': return new _ContentElementImpl._wrap(domObject);
    case 'ConvolverNode': return new _ConvolverNodeImpl._wrap(domObject);
    case 'Coordinates': return new _CoordinatesImpl._wrap(domObject);
    case 'Counter': return new _CounterImpl._wrap(domObject);
    case 'Crypto': return new _CryptoImpl._wrap(domObject);
    case 'CustomEvent': return new _CustomEventImpl._wrap(domObject);
    case 'HTMLDListElement': return new _DListElementImpl._wrap(domObject);
    case 'DOMApplicationCache': return new _DOMApplicationCacheImpl._wrap(domObject);
    case 'DOMException': return new _DOMExceptionImpl._wrap(domObject);
    case 'DOMFileSystem': return new _DOMFileSystemImpl._wrap(domObject);
    case 'DOMFileSystemSync': return new _DOMFileSystemSyncImpl._wrap(domObject);
    case 'DOMFormData': return new _DOMFormDataImpl._wrap(domObject);
    case 'DOMImplementation': return new _DOMImplementationImpl._wrap(domObject);
    case 'DOMMimeType': return new _DOMMimeTypeImpl._wrap(domObject);
    case 'DOMMimeTypeArray': return new _DOMMimeTypeArrayImpl._wrap(domObject);
    case 'DOMParser': return new _DOMParserImpl._wrap(domObject);
    case 'DOMPlugin': return new _DOMPluginImpl._wrap(domObject);
    case 'DOMPluginArray': return new _DOMPluginArrayImpl._wrap(domObject);
    case 'DOMSelection': return new _DOMSelectionImpl._wrap(domObject);
    case 'DOMTokenList': return new _DOMTokenListImpl._wrap(domObject);
    case 'DOMSettableTokenList': return new _DOMSettableTokenListImpl._wrap(domObject);
    case 'DOMStringList': return new _DOMStringListImpl._wrap(domObject);
    case 'DOMURL': return new _DOMURLImpl._wrap(domObject);
    case 'DataTransferItem': return new _DataTransferItemImpl._wrap(domObject);
    case 'DataTransferItemList': return new _DataTransferItemListImpl._wrap(domObject);
    case 'DataView': return new _DataViewImpl._wrap(domObject);
    case 'Database': return new _DatabaseImpl._wrap(domObject);
    case 'DatabaseSync': return new _DatabaseSyncImpl._wrap(domObject);
    case 'WorkerContext': return new _WorkerContextImpl._wrap(domObject);
    case 'DedicatedWorkerContext': return new _DedicatedWorkerContextImpl._wrap(domObject);
    case 'DelayNode': return new _DelayNodeImpl._wrap(domObject);
    case 'DeprecatedPeerConnection': return new _DeprecatedPeerConnectionImpl._wrap(domObject);
    case 'HTMLDetailsElement': return new _DetailsElementImpl._wrap(domObject);
    case 'DeviceMotionEvent': return new _DeviceMotionEventImpl._wrap(domObject);
    case 'DeviceOrientationEvent': return new _DeviceOrientationEventImpl._wrap(domObject);
    case 'HTMLDirectoryElement': return new _DirectoryElementImpl._wrap(domObject);
    case 'Entry': return new _EntryImpl._wrap(domObject);
    case 'DirectoryEntry': return new _DirectoryEntryImpl._wrap(domObject);
    case 'EntrySync': return new _EntrySyncImpl._wrap(domObject);
    case 'DirectoryEntrySync': return new _DirectoryEntrySyncImpl._wrap(domObject);
    case 'DirectoryReader': return new _DirectoryReaderImpl._wrap(domObject);
    case 'DirectoryReaderSync': return new _DirectoryReaderSyncImpl._wrap(domObject);
    case 'HTMLDivElement': return new _DivElementImpl._wrap(domObject);
    case 'Document': return new _DocumentImpl._wrap(domObject);
    case 'DocumentFragment': return new _DocumentFragmentImpl._wrap(domObject);
    case 'DocumentType': return new _DocumentTypeImpl._wrap(domObject);
    case 'DynamicsCompressorNode': return new _DynamicsCompressorNodeImpl._wrap(domObject);
    case 'EXTTextureFilterAnisotropic': return new _EXTTextureFilterAnisotropicImpl._wrap(domObject);
    case 'ElementTimeControl': return new _ElementTimeControlImpl._wrap(domObject);
    case 'HTMLEmbedElement': return new _EmbedElementImpl._wrap(domObject);
    case 'Entity': return new _EntityImpl._wrap(domObject);
    case 'EntityReference': return new _EntityReferenceImpl._wrap(domObject);
    case 'EntryArray': return new _EntryArrayImpl._wrap(domObject);
    case 'EntryArraySync': return new _EntryArraySyncImpl._wrap(domObject);
    case 'ErrorEvent': return new _ErrorEventImpl._wrap(domObject);
    case 'EventException': return new _EventExceptionImpl._wrap(domObject);
    case 'EventSource': return new _EventSourceImpl._wrap(domObject);
    case 'HTMLFieldSetElement': return new _FieldSetElementImpl._wrap(domObject);
    case 'File': return new _FileImpl._wrap(domObject);
    case 'FileEntry': return new _FileEntryImpl._wrap(domObject);
    case 'FileEntrySync': return new _FileEntrySyncImpl._wrap(domObject);
    case 'FileError': return new _FileErrorImpl._wrap(domObject);
    case 'FileException': return new _FileExceptionImpl._wrap(domObject);
    case 'FileList': return new _FileListImpl._wrap(domObject);
    case 'FileReader': return new _FileReaderImpl._wrap(domObject);
    case 'FileReaderSync': return new _FileReaderSyncImpl._wrap(domObject);
    case 'FileWriter': return new _FileWriterImpl._wrap(domObject);
    case 'FileWriterSync': return new _FileWriterSyncImpl._wrap(domObject);
    case 'Float32Array': return new _Float32ArrayImpl._wrap(domObject);
    case 'Float64Array': return new _Float64ArrayImpl._wrap(domObject);
    case 'HTMLFontElement': return new _FontElementImpl._wrap(domObject);
    case 'HTMLFormElement': return new _FormElementImpl._wrap(domObject);
    case 'HTMLFrameElement': return new _FrameElementImpl._wrap(domObject);
    case 'HTMLFrameSetElement': return new _FrameSetElementImpl._wrap(domObject);
    case 'Geolocation': return new _GeolocationImpl._wrap(domObject);
    case 'Geoposition': return new _GeopositionImpl._wrap(domObject);
    case 'HTMLHRElement': return new _HRElementImpl._wrap(domObject);
    case 'HTMLAllCollection': return new _HTMLAllCollectionImpl._wrap(domObject);
    case 'HTMLCollection': return new _HTMLCollectionImpl._wrap(domObject);
    case 'HTMLOptionsCollection': return new _HTMLOptionsCollectionImpl._wrap(domObject);
    case 'HashChangeEvent': return new _HashChangeEventImpl._wrap(domObject);
    case 'HTMLHeadElement': return new _HeadElementImpl._wrap(domObject);
    case 'HTMLHeadingElement': return new _HeadingElementImpl._wrap(domObject);
    case 'History': return new _HistoryImpl._wrap(domObject);
    case 'HTMLHtmlElement': return new _HtmlElementImpl._wrap(domObject);
    case 'IDBAny': return new _IDBAnyImpl._wrap(domObject);
    case 'IDBCursor': return new _IDBCursorImpl._wrap(domObject);
    case 'IDBCursorWithValue': return new _IDBCursorWithValueImpl._wrap(domObject);
    case 'IDBDatabase': return new _IDBDatabaseImpl._wrap(domObject);
    case 'IDBDatabaseException': return new _IDBDatabaseExceptionImpl._wrap(domObject);
    case 'IDBFactory': return new _IDBFactoryImpl._wrap(domObject);
    case 'IDBIndex': return new _IDBIndexImpl._wrap(domObject);
    case 'IDBKey': return new _IDBKeyImpl._wrap(domObject);
    case 'IDBKeyRange': return new _IDBKeyRangeImpl._wrap(domObject);
    case 'IDBObjectStore': return new _IDBObjectStoreImpl._wrap(domObject);
    case 'IDBRequest': return new _IDBRequestImpl._wrap(domObject);
    case 'IDBTransaction': return new _IDBTransactionImpl._wrap(domObject);
    case 'IDBVersionChangeEvent': return new _IDBVersionChangeEventImpl._wrap(domObject);
    case 'IDBVersionChangeRequest': return new _IDBVersionChangeRequestImpl._wrap(domObject);
    case 'HTMLIFrameElement': return new _IFrameElementImpl._wrap(domObject);
    case 'IceCandidate': return new _IceCandidateImpl._wrap(domObject);
    case 'ImageData': return new _ImageDataImpl._wrap(domObject);
    case 'HTMLImageElement': return new _ImageElementImpl._wrap(domObject);
    case 'HTMLInputElement': return new _InputElementImpl._wrap(domObject);
    case 'Int16Array': return new _Int16ArrayImpl._wrap(domObject);
    case 'Int32Array': return new _Int32ArrayImpl._wrap(domObject);
    case 'Int8Array': return new _Int8ArrayImpl._wrap(domObject);
    case 'JavaScriptAudioNode': return new _JavaScriptAudioNodeImpl._wrap(domObject);
    case 'JavaScriptCallFrame': return new _JavaScriptCallFrameImpl._wrap(domObject);
    case 'KeyboardEvent': return new _KeyboardEventImpl._wrap(domObject);
    case 'HTMLKeygenElement': return new _KeygenElementImpl._wrap(domObject);
    case 'HTMLLIElement': return new _LIElementImpl._wrap(domObject);
    case 'HTMLLabelElement': return new _LabelElementImpl._wrap(domObject);
    case 'HTMLLegendElement': return new _LegendElementImpl._wrap(domObject);
    case 'HTMLLinkElement': return new _LinkElementImpl._wrap(domObject);
    case 'MediaStream': return new _MediaStreamImpl._wrap(domObject);
    case 'LocalMediaStream': return new _LocalMediaStreamImpl._wrap(domObject);
    case 'Location': return new _LocationImpl._wrap(domObject);
    case 'HTMLMapElement': return new _MapElementImpl._wrap(domObject);
    case 'HTMLMarqueeElement': return new _MarqueeElementImpl._wrap(domObject);
    case 'MediaController': return new _MediaControllerImpl._wrap(domObject);
    case 'MediaElementAudioSourceNode': return new _MediaElementAudioSourceNodeImpl._wrap(domObject);
    case 'MediaError': return new _MediaErrorImpl._wrap(domObject);
    case 'MediaKeyError': return new _MediaKeyErrorImpl._wrap(domObject);
    case 'MediaKeyEvent': return new _MediaKeyEventImpl._wrap(domObject);
    case 'MediaList': return new _MediaListImpl._wrap(domObject);
    case 'MediaQueryList': return new _MediaQueryListImpl._wrap(domObject);
    case 'MediaQueryListListener': return new _MediaQueryListListenerImpl._wrap(domObject);
    case 'MediaStreamEvent': return new _MediaStreamEventImpl._wrap(domObject);
    case 'MediaStreamList': return new _MediaStreamListImpl._wrap(domObject);
    case 'MediaStreamTrack': return new _MediaStreamTrackImpl._wrap(domObject);
    case 'MediaStreamTrackList': return new _MediaStreamTrackListImpl._wrap(domObject);
    case 'MemoryInfo': return new _MemoryInfoImpl._wrap(domObject);
    case 'HTMLMenuElement': return new _MenuElementImpl._wrap(domObject);
    case 'MessageChannel': return new _MessageChannelImpl._wrap(domObject);
    case 'MessageEvent': return new _MessageEventImpl._wrap(domObject);
    case 'MessagePort': return new _MessagePortImpl._wrap(domObject);
    case 'HTMLMetaElement': return new _MetaElementImpl._wrap(domObject);
    case 'Metadata': return new _MetadataImpl._wrap(domObject);
    case 'HTMLMeterElement': return new _MeterElementImpl._wrap(domObject);
    case 'HTMLModElement': return new _ModElementImpl._wrap(domObject);
    case 'MouseEvent': return new _MouseEventImpl._wrap(domObject);
    case 'MutationCallback': return new _MutationCallbackImpl._wrap(domObject);
    case 'MutationEvent': return new _MutationEventImpl._wrap(domObject);
    case 'MutationRecord': return new _MutationRecordImpl._wrap(domObject);
    case 'NamedNodeMap': return new _NamedNodeMapImpl._wrap(domObject);
    case 'Navigator': return new _NavigatorImpl._wrap(domObject);
    case 'NavigatorUserMediaError': return new _NavigatorUserMediaErrorImpl._wrap(domObject);
    case 'NodeFilter': return new _NodeFilterImpl._wrap(domObject);
    case 'NodeIterator': return new _NodeIteratorImpl._wrap(domObject);
    case 'NodeList': return new _NodeListImpl._wrap(domObject);
    case 'Notation': return new _NotationImpl._wrap(domObject);
    case 'Notification': return new _NotificationImpl._wrap(domObject);
    case 'NotificationCenter': return new _NotificationCenterImpl._wrap(domObject);
    case 'OESStandardDerivatives': return new _OESStandardDerivativesImpl._wrap(domObject);
    case 'OESTextureFloat': return new _OESTextureFloatImpl._wrap(domObject);
    case 'OESVertexArrayObject': return new _OESVertexArrayObjectImpl._wrap(domObject);
    case 'HTMLOListElement': return new _OListElementImpl._wrap(domObject);
    case 'HTMLObjectElement': return new _ObjectElementImpl._wrap(domObject);
    case 'OfflineAudioCompletionEvent': return new _OfflineAudioCompletionEventImpl._wrap(domObject);
    case 'OperationNotAllowedException': return new _OperationNotAllowedExceptionImpl._wrap(domObject);
    case 'HTMLOptGroupElement': return new _OptGroupElementImpl._wrap(domObject);
    case 'HTMLOptionElement': return new _OptionElementImpl._wrap(domObject);
    case 'Oscillator': return new _OscillatorImpl._wrap(domObject);
    case 'HTMLOutputElement': return new _OutputElementImpl._wrap(domObject);
    case 'OverflowEvent': return new _OverflowEventImpl._wrap(domObject);
    case 'PageTransitionEvent': return new _PageTransitionEventImpl._wrap(domObject);
    case 'HTMLParagraphElement': return new _ParagraphElementImpl._wrap(domObject);
    case 'HTMLParamElement': return new _ParamElementImpl._wrap(domObject);
    case 'PeerConnection00': return new _PeerConnection00Impl._wrap(domObject);
    case 'Performance': return new _PerformanceImpl._wrap(domObject);
    case 'PerformanceNavigation': return new _PerformanceNavigationImpl._wrap(domObject);
    case 'PerformanceTiming': return new _PerformanceTimingImpl._wrap(domObject);
    case 'WebKitPoint': return new _PointImpl._wrap(domObject);
    case 'PointerLock': return new _PointerLockImpl._wrap(domObject);
    case 'PopStateEvent': return new _PopStateEventImpl._wrap(domObject);
    case 'PositionError': return new _PositionErrorImpl._wrap(domObject);
    case 'HTMLPreElement': return new _PreElementImpl._wrap(domObject);
    case 'ProcessingInstruction': return new _ProcessingInstructionImpl._wrap(domObject);
    case 'HTMLProgressElement': return new _ProgressElementImpl._wrap(domObject);
    case 'ProgressEvent': return new _ProgressEventImpl._wrap(domObject);
    case 'HTMLQuoteElement': return new _QuoteElementImpl._wrap(domObject);
    case 'RGBColor': return new _RGBColorImpl._wrap(domObject);
    case 'Range': return new _RangeImpl._wrap(domObject);
    case 'RangeException': return new _RangeExceptionImpl._wrap(domObject);
    case 'RealtimeAnalyserNode': return new _RealtimeAnalyserNodeImpl._wrap(domObject);
    case 'Rect': return new _RectImpl._wrap(domObject);
    case 'SQLError': return new _SQLErrorImpl._wrap(domObject);
    case 'SQLException': return new _SQLExceptionImpl._wrap(domObject);
    case 'SQLResultSet': return new _SQLResultSetImpl._wrap(domObject);
    case 'SQLResultSetRowList': return new _SQLResultSetRowListImpl._wrap(domObject);
    case 'SQLTransaction': return new _SQLTransactionImpl._wrap(domObject);
    case 'SQLTransactionSync': return new _SQLTransactionSyncImpl._wrap(domObject);
    case 'SVGElement': return new _SVGElementImpl._wrap(domObject);
    case 'SVGURIReference': return new _SVGURIReferenceImpl._wrap(domObject);
    case 'SVGTests': return new _SVGTestsImpl._wrap(domObject);
    case 'SVGLangSpace': return new _SVGLangSpaceImpl._wrap(domObject);
    case 'SVGExternalResourcesRequired': return new _SVGExternalResourcesRequiredImpl._wrap(domObject);
    case 'SVGStylable': return new _SVGStylableImpl._wrap(domObject);
    case 'SVGLocatable': return new _SVGLocatableImpl._wrap(domObject);
    case 'SVGTransformable': return new _SVGTransformableImpl._wrap(domObject);
    case 'SVGAElement': return new _SVGAElementImpl._wrap(domObject);
    case 'SVGAltGlyphDefElement': return new _SVGAltGlyphDefElementImpl._wrap(domObject);
    case 'SVGTextContentElement': return new _SVGTextContentElementImpl._wrap(domObject);
    case 'SVGTextPositioningElement': return new _SVGTextPositioningElementImpl._wrap(domObject);
    case 'SVGAltGlyphElement': return new _SVGAltGlyphElementImpl._wrap(domObject);
    case 'SVGAltGlyphItemElement': return new _SVGAltGlyphItemElementImpl._wrap(domObject);
    case 'SVGAngle': return new _SVGAngleImpl._wrap(domObject);
    case 'SVGAnimationElement': return new _SVGAnimationElementImpl._wrap(domObject);
    case 'SVGAnimateColorElement': return new _SVGAnimateColorElementImpl._wrap(domObject);
    case 'SVGAnimateElement': return new _SVGAnimateElementImpl._wrap(domObject);
    case 'SVGAnimateMotionElement': return new _SVGAnimateMotionElementImpl._wrap(domObject);
    case 'SVGAnimateTransformElement': return new _SVGAnimateTransformElementImpl._wrap(domObject);
    case 'SVGAnimatedAngle': return new _SVGAnimatedAngleImpl._wrap(domObject);
    case 'SVGAnimatedBoolean': return new _SVGAnimatedBooleanImpl._wrap(domObject);
    case 'SVGAnimatedEnumeration': return new _SVGAnimatedEnumerationImpl._wrap(domObject);
    case 'SVGAnimatedInteger': return new _SVGAnimatedIntegerImpl._wrap(domObject);
    case 'SVGAnimatedLength': return new _SVGAnimatedLengthImpl._wrap(domObject);
    case 'SVGAnimatedLengthList': return new _SVGAnimatedLengthListImpl._wrap(domObject);
    case 'SVGAnimatedNumber': return new _SVGAnimatedNumberImpl._wrap(domObject);
    case 'SVGAnimatedNumberList': return new _SVGAnimatedNumberListImpl._wrap(domObject);
    case 'SVGAnimatedPreserveAspectRatio': return new _SVGAnimatedPreserveAspectRatioImpl._wrap(domObject);
    case 'SVGAnimatedRect': return new _SVGAnimatedRectImpl._wrap(domObject);
    case 'SVGAnimatedString': return new _SVGAnimatedStringImpl._wrap(domObject);
    case 'SVGAnimatedTransformList': return new _SVGAnimatedTransformListImpl._wrap(domObject);
    case 'SVGCircleElement': return new _SVGCircleElementImpl._wrap(domObject);
    case 'SVGClipPathElement': return new _SVGClipPathElementImpl._wrap(domObject);
    case 'SVGColor': return new _SVGColorImpl._wrap(domObject);
    case 'SVGComponentTransferFunctionElement': return new _SVGComponentTransferFunctionElementImpl._wrap(domObject);
    case 'SVGCursorElement': return new _SVGCursorElementImpl._wrap(domObject);
    case 'SVGDefsElement': return new _SVGDefsElementImpl._wrap(domObject);
    case 'SVGDescElement': return new _SVGDescElementImpl._wrap(domObject);
    case 'SVGDocument': return new _SVGDocumentImpl._wrap(domObject);
    case 'SVGElementInstance': return new _SVGElementInstanceImpl._wrap(domObject);
    case 'SVGElementInstanceList': return new _SVGElementInstanceListImpl._wrap(domObject);
    case 'SVGEllipseElement': return new _SVGEllipseElementImpl._wrap(domObject);
    case 'SVGException': return new _SVGExceptionImpl._wrap(domObject);
    case 'SVGFilterPrimitiveStandardAttributes': return new _SVGFilterPrimitiveStandardAttributesImpl._wrap(domObject);
    case 'SVGFEBlendElement': return new _SVGFEBlendElementImpl._wrap(domObject);
    case 'SVGFEColorMatrixElement': return new _SVGFEColorMatrixElementImpl._wrap(domObject);
    case 'SVGFEComponentTransferElement': return new _SVGFEComponentTransferElementImpl._wrap(domObject);
    case 'SVGFECompositeElement': return new _SVGFECompositeElementImpl._wrap(domObject);
    case 'SVGFEConvolveMatrixElement': return new _SVGFEConvolveMatrixElementImpl._wrap(domObject);
    case 'SVGFEDiffuseLightingElement': return new _SVGFEDiffuseLightingElementImpl._wrap(domObject);
    case 'SVGFEDisplacementMapElement': return new _SVGFEDisplacementMapElementImpl._wrap(domObject);
    case 'SVGFEDistantLightElement': return new _SVGFEDistantLightElementImpl._wrap(domObject);
    case 'SVGFEDropShadowElement': return new _SVGFEDropShadowElementImpl._wrap(domObject);
    case 'SVGFEFloodElement': return new _SVGFEFloodElementImpl._wrap(domObject);
    case 'SVGFEFuncAElement': return new _SVGFEFuncAElementImpl._wrap(domObject);
    case 'SVGFEFuncBElement': return new _SVGFEFuncBElementImpl._wrap(domObject);
    case 'SVGFEFuncGElement': return new _SVGFEFuncGElementImpl._wrap(domObject);
    case 'SVGFEFuncRElement': return new _SVGFEFuncRElementImpl._wrap(domObject);
    case 'SVGFEGaussianBlurElement': return new _SVGFEGaussianBlurElementImpl._wrap(domObject);
    case 'SVGFEImageElement': return new _SVGFEImageElementImpl._wrap(domObject);
    case 'SVGFEMergeElement': return new _SVGFEMergeElementImpl._wrap(domObject);
    case 'SVGFEMergeNodeElement': return new _SVGFEMergeNodeElementImpl._wrap(domObject);
    case 'SVGFEMorphologyElement': return new _SVGFEMorphologyElementImpl._wrap(domObject);
    case 'SVGFEOffsetElement': return new _SVGFEOffsetElementImpl._wrap(domObject);
    case 'SVGFEPointLightElement': return new _SVGFEPointLightElementImpl._wrap(domObject);
    case 'SVGFESpecularLightingElement': return new _SVGFESpecularLightingElementImpl._wrap(domObject);
    case 'SVGFESpotLightElement': return new _SVGFESpotLightElementImpl._wrap(domObject);
    case 'SVGFETileElement': return new _SVGFETileElementImpl._wrap(domObject);
    case 'SVGFETurbulenceElement': return new _SVGFETurbulenceElementImpl._wrap(domObject);
    case 'SVGFilterElement': return new _SVGFilterElementImpl._wrap(domObject);
    case 'SVGFitToViewBox': return new _SVGFitToViewBoxImpl._wrap(domObject);
    case 'SVGFontElement': return new _SVGFontElementImpl._wrap(domObject);
    case 'SVGFontFaceElement': return new _SVGFontFaceElementImpl._wrap(domObject);
    case 'SVGFontFaceFormatElement': return new _SVGFontFaceFormatElementImpl._wrap(domObject);
    case 'SVGFontFaceNameElement': return new _SVGFontFaceNameElementImpl._wrap(domObject);
    case 'SVGFontFaceSrcElement': return new _SVGFontFaceSrcElementImpl._wrap(domObject);
    case 'SVGFontFaceUriElement': return new _SVGFontFaceUriElementImpl._wrap(domObject);
    case 'SVGForeignObjectElement': return new _SVGForeignObjectElementImpl._wrap(domObject);
    case 'SVGGElement': return new _SVGGElementImpl._wrap(domObject);
    case 'SVGGlyphElement': return new _SVGGlyphElementImpl._wrap(domObject);
    case 'SVGGlyphRefElement': return new _SVGGlyphRefElementImpl._wrap(domObject);
    case 'SVGGradientElement': return new _SVGGradientElementImpl._wrap(domObject);
    case 'SVGHKernElement': return new _SVGHKernElementImpl._wrap(domObject);
    case 'SVGImageElement': return new _SVGImageElementImpl._wrap(domObject);
    case 'SVGLength': return new _SVGLengthImpl._wrap(domObject);
    case 'SVGLengthList': return new _SVGLengthListImpl._wrap(domObject);
    case 'SVGLineElement': return new _SVGLineElementImpl._wrap(domObject);
    case 'SVGLinearGradientElement': return new _SVGLinearGradientElementImpl._wrap(domObject);
    case 'SVGMPathElement': return new _SVGMPathElementImpl._wrap(domObject);
    case 'SVGMarkerElement': return new _SVGMarkerElementImpl._wrap(domObject);
    case 'SVGMaskElement': return new _SVGMaskElementImpl._wrap(domObject);
    case 'SVGMatrix': return new _SVGMatrixImpl._wrap(domObject);
    case 'SVGMetadataElement': return new _SVGMetadataElementImpl._wrap(domObject);
    case 'SVGMissingGlyphElement': return new _SVGMissingGlyphElementImpl._wrap(domObject);
    case 'SVGNumber': return new _SVGNumberImpl._wrap(domObject);
    case 'SVGNumberList': return new _SVGNumberListImpl._wrap(domObject);
    case 'SVGPaint': return new _SVGPaintImpl._wrap(domObject);
    case 'SVGPathElement': return new _SVGPathElementImpl._wrap(domObject);
    case 'SVGPathSeg': return new _SVGPathSegImpl._wrap(domObject);
    case 'SVGPathSegArcAbs': return new _SVGPathSegArcAbsImpl._wrap(domObject);
    case 'SVGPathSegArcRel': return new _SVGPathSegArcRelImpl._wrap(domObject);
    case 'SVGPathSegClosePath': return new _SVGPathSegClosePathImpl._wrap(domObject);
    case 'SVGPathSegCurvetoCubicAbs': return new _SVGPathSegCurvetoCubicAbsImpl._wrap(domObject);
    case 'SVGPathSegCurvetoCubicRel': return new _SVGPathSegCurvetoCubicRelImpl._wrap(domObject);
    case 'SVGPathSegCurvetoCubicSmoothAbs': return new _SVGPathSegCurvetoCubicSmoothAbsImpl._wrap(domObject);
    case 'SVGPathSegCurvetoCubicSmoothRel': return new _SVGPathSegCurvetoCubicSmoothRelImpl._wrap(domObject);
    case 'SVGPathSegCurvetoQuadraticAbs': return new _SVGPathSegCurvetoQuadraticAbsImpl._wrap(domObject);
    case 'SVGPathSegCurvetoQuadraticRel': return new _SVGPathSegCurvetoQuadraticRelImpl._wrap(domObject);
    case 'SVGPathSegCurvetoQuadraticSmoothAbs': return new _SVGPathSegCurvetoQuadraticSmoothAbsImpl._wrap(domObject);
    case 'SVGPathSegCurvetoQuadraticSmoothRel': return new _SVGPathSegCurvetoQuadraticSmoothRelImpl._wrap(domObject);
    case 'SVGPathSegLinetoAbs': return new _SVGPathSegLinetoAbsImpl._wrap(domObject);
    case 'SVGPathSegLinetoHorizontalAbs': return new _SVGPathSegLinetoHorizontalAbsImpl._wrap(domObject);
    case 'SVGPathSegLinetoHorizontalRel': return new _SVGPathSegLinetoHorizontalRelImpl._wrap(domObject);
    case 'SVGPathSegLinetoRel': return new _SVGPathSegLinetoRelImpl._wrap(domObject);
    case 'SVGPathSegLinetoVerticalAbs': return new _SVGPathSegLinetoVerticalAbsImpl._wrap(domObject);
    case 'SVGPathSegLinetoVerticalRel': return new _SVGPathSegLinetoVerticalRelImpl._wrap(domObject);
    case 'SVGPathSegList': return new _SVGPathSegListImpl._wrap(domObject);
    case 'SVGPathSegMovetoAbs': return new _SVGPathSegMovetoAbsImpl._wrap(domObject);
    case 'SVGPathSegMovetoRel': return new _SVGPathSegMovetoRelImpl._wrap(domObject);
    case 'SVGPatternElement': return new _SVGPatternElementImpl._wrap(domObject);
    case 'SVGPoint': return new _SVGPointImpl._wrap(domObject);
    case 'SVGPointList': return new _SVGPointListImpl._wrap(domObject);
    case 'SVGPolygonElement': return new _SVGPolygonElementImpl._wrap(domObject);
    case 'SVGPolylineElement': return new _SVGPolylineElementImpl._wrap(domObject);
    case 'SVGPreserveAspectRatio': return new _SVGPreserveAspectRatioImpl._wrap(domObject);
    case 'SVGRadialGradientElement': return new _SVGRadialGradientElementImpl._wrap(domObject);
    case 'SVGRect': return new _SVGRectImpl._wrap(domObject);
    case 'SVGRectElement': return new _SVGRectElementImpl._wrap(domObject);
    case 'SVGRenderingIntent': return new _SVGRenderingIntentImpl._wrap(domObject);
    case 'SVGZoomAndPan': return new _SVGZoomAndPanImpl._wrap(domObject);
    case 'SVGSVGElement': return new _SVGSVGElementImpl._wrap(domObject);
    case 'SVGScriptElement': return new _SVGScriptElementImpl._wrap(domObject);
    case 'SVGSetElement': return new _SVGSetElementImpl._wrap(domObject);
    case 'SVGStopElement': return new _SVGStopElementImpl._wrap(domObject);
    case 'SVGStringList': return new _SVGStringListImpl._wrap(domObject);
    case 'SVGStyleElement': return new _SVGStyleElementImpl._wrap(domObject);
    case 'SVGSwitchElement': return new _SVGSwitchElementImpl._wrap(domObject);
    case 'SVGSymbolElement': return new _SVGSymbolElementImpl._wrap(domObject);
    case 'SVGTRefElement': return new _SVGTRefElementImpl._wrap(domObject);
    case 'SVGTSpanElement': return new _SVGTSpanElementImpl._wrap(domObject);
    case 'SVGTextElement': return new _SVGTextElementImpl._wrap(domObject);
    case 'SVGTextPathElement': return new _SVGTextPathElementImpl._wrap(domObject);
    case 'SVGTitleElement': return new _SVGTitleElementImpl._wrap(domObject);
    case 'SVGTransform': return new _SVGTransformImpl._wrap(domObject);
    case 'SVGTransformList': return new _SVGTransformListImpl._wrap(domObject);
    case 'SVGUnitTypes': return new _SVGUnitTypesImpl._wrap(domObject);
    case 'SVGUseElement': return new _SVGUseElementImpl._wrap(domObject);
    case 'SVGVKernElement': return new _SVGVKernElementImpl._wrap(domObject);
    case 'SVGViewElement': return new _SVGViewElementImpl._wrap(domObject);
    case 'SVGViewSpec': return new _SVGViewSpecImpl._wrap(domObject);
    case 'SVGZoomEvent': return new _SVGZoomEventImpl._wrap(domObject);
    case 'Screen': return new _ScreenImpl._wrap(domObject);
    case 'HTMLScriptElement': return new _ScriptElementImpl._wrap(domObject);
    case 'ScriptProfile': return new _ScriptProfileImpl._wrap(domObject);
    case 'ScriptProfileNode': return new _ScriptProfileNodeImpl._wrap(domObject);
    case 'HTMLSelectElement': return new _SelectElementImpl._wrap(domObject);
    case 'SessionDescription': return new _SessionDescriptionImpl._wrap(domObject);
    case 'HTMLShadowElement': return new _ShadowElementImpl._wrap(domObject);
    case 'ShadowRoot': return new _ShadowRootImpl._wrap(domObject);
    case 'SharedWorker': return new _SharedWorkerImpl._wrap(domObject);
    case 'SharedWorkerContext': return new _SharedWorkerContextImpl._wrap(domObject);
    case 'HTMLSourceElement': return new _SourceElementImpl._wrap(domObject);
    case 'HTMLSpanElement': return new _SpanElementImpl._wrap(domObject);
    case 'SpeechGrammar': return new _SpeechGrammarImpl._wrap(domObject);
    case 'SpeechGrammarList': return new _SpeechGrammarListImpl._wrap(domObject);
    case 'SpeechInputEvent': return new _SpeechInputEventImpl._wrap(domObject);
    case 'SpeechInputResult': return new _SpeechInputResultImpl._wrap(domObject);
    case 'SpeechInputResultList': return new _SpeechInputResultListImpl._wrap(domObject);
    case 'SpeechRecognition': return new _SpeechRecognitionImpl._wrap(domObject);
    case 'SpeechRecognitionAlternative': return new _SpeechRecognitionAlternativeImpl._wrap(domObject);
    case 'SpeechRecognitionError': return new _SpeechRecognitionErrorImpl._wrap(domObject);
    case 'SpeechRecognitionEvent': return new _SpeechRecognitionEventImpl._wrap(domObject);
    case 'SpeechRecognitionResult': return new _SpeechRecognitionResultImpl._wrap(domObject);
    case 'SpeechRecognitionResultList': return new _SpeechRecognitionResultListImpl._wrap(domObject);
    case 'Storage': return new _StorageImpl._wrap(domObject);
    case 'StorageEvent': return new _StorageEventImpl._wrap(domObject);
    case 'StorageInfo': return new _StorageInfoImpl._wrap(domObject);
    case 'HTMLStyleElement': return new _StyleElementImpl._wrap(domObject);
    case 'StyleMedia': return new _StyleMediaImpl._wrap(domObject);
    case 'StyleSheetList': return new _StyleSheetListImpl._wrap(domObject);
    case 'HTMLTableCaptionElement': return new _TableCaptionElementImpl._wrap(domObject);
    case 'HTMLTableCellElement': return new _TableCellElementImpl._wrap(domObject);
    case 'HTMLTableColElement': return new _TableColElementImpl._wrap(domObject);
    case 'HTMLTableElement': return new _TableElementImpl._wrap(domObject);
    case 'HTMLTableRowElement': return new _TableRowElementImpl._wrap(domObject);
    case 'HTMLTableSectionElement': return new _TableSectionElementImpl._wrap(domObject);
    case 'HTMLTextAreaElement': return new _TextAreaElementImpl._wrap(domObject);
    case 'TextEvent': return new _TextEventImpl._wrap(domObject);
    case 'TextMetrics': return new _TextMetricsImpl._wrap(domObject);
    case 'TextTrack': return new _TextTrackImpl._wrap(domObject);
    case 'TextTrackCue': return new _TextTrackCueImpl._wrap(domObject);
    case 'TextTrackCueList': return new _TextTrackCueListImpl._wrap(domObject);
    case 'TextTrackList': return new _TextTrackListImpl._wrap(domObject);
    case 'TimeRanges': return new _TimeRangesImpl._wrap(domObject);
    case 'HTMLTitleElement': return new _TitleElementImpl._wrap(domObject);
    case 'Touch': return new _TouchImpl._wrap(domObject);
    case 'TouchEvent': return new _TouchEventImpl._wrap(domObject);
    case 'TouchList': return new _TouchListImpl._wrap(domObject);
    case 'HTMLTrackElement': return new _TrackElementImpl._wrap(domObject);
    case 'TrackEvent': return new _TrackEventImpl._wrap(domObject);
    case 'WebKitTransitionEvent': return new _TransitionEventImpl._wrap(domObject);
    case 'TreeWalker': return new _TreeWalkerImpl._wrap(domObject);
    case 'HTMLUListElement': return new _UListElementImpl._wrap(domObject);
    case 'Uint16Array': return new _Uint16ArrayImpl._wrap(domObject);
    case 'Uint32Array': return new _Uint32ArrayImpl._wrap(domObject);
    case 'Uint8Array': return new _Uint8ArrayImpl._wrap(domObject);
    case 'Uint8ClampedArray': return new _Uint8ClampedArrayImpl._wrap(domObject);
    case 'HTMLUnknownElement': return new _UnknownElementImpl._wrap(domObject);
    case 'ValidityState': return new _ValidityStateImpl._wrap(domObject);
    case 'HTMLVideoElement': return new _VideoElementImpl._wrap(domObject);
    case 'WaveShaperNode': return new _WaveShaperNodeImpl._wrap(domObject);
    case 'WaveTable': return new _WaveTableImpl._wrap(domObject);
    case 'WebGLActiveInfo': return new _WebGLActiveInfoImpl._wrap(domObject);
    case 'WebGLBuffer': return new _WebGLBufferImpl._wrap(domObject);
    case 'WebGLCompressedTextureS3TC': return new _WebGLCompressedTextureS3TCImpl._wrap(domObject);
    case 'WebGLContextAttributes': return new _WebGLContextAttributesImpl._wrap(domObject);
    case 'WebGLContextEvent': return new _WebGLContextEventImpl._wrap(domObject);
    case 'WebGLDebugRendererInfo': return new _WebGLDebugRendererInfoImpl._wrap(domObject);
    case 'WebGLDebugShaders': return new _WebGLDebugShadersImpl._wrap(domObject);
    case 'WebGLFramebuffer': return new _WebGLFramebufferImpl._wrap(domObject);
    case 'WebGLLoseContext': return new _WebGLLoseContextImpl._wrap(domObject);
    case 'WebGLProgram': return new _WebGLProgramImpl._wrap(domObject);
    case 'WebGLRenderbuffer': return new _WebGLRenderbufferImpl._wrap(domObject);
    case 'WebGLRenderingContext': return new _WebGLRenderingContextImpl._wrap(domObject);
    case 'WebGLShader': return new _WebGLShaderImpl._wrap(domObject);
    case 'WebGLShaderPrecisionFormat': return new _WebGLShaderPrecisionFormatImpl._wrap(domObject);
    case 'WebGLTexture': return new _WebGLTextureImpl._wrap(domObject);
    case 'WebGLUniformLocation': return new _WebGLUniformLocationImpl._wrap(domObject);
    case 'WebGLVertexArrayObjectOES': return new _WebGLVertexArrayObjectOESImpl._wrap(domObject);
    case 'WebKitCSSFilterValue': return new _WebKitCSSFilterValueImpl._wrap(domObject);
    case 'WebKitCSSRegionRule': return new _WebKitCSSRegionRuleImpl._wrap(domObject);
    case 'WebKitMutationObserver': return new _WebKitMutationObserverImpl._wrap(domObject);
    case 'WebKitNamedFlow': return new _WebKitNamedFlowImpl._wrap(domObject);
    case 'WebSocket': return new _WebSocketImpl._wrap(domObject);
    case 'WheelEvent': return new _WheelEventImpl._wrap(domObject);
    case 'DOMWindow': return new _WindowImpl._wrap(domObject);
    case 'Worker': return new _WorkerImpl._wrap(domObject);
    case 'WorkerLocation': return new _WorkerLocationImpl._wrap(domObject);
    case 'WorkerNavigator': return new _WorkerNavigatorImpl._wrap(domObject);
    case 'XMLHttpRequest': return new _XMLHttpRequestImpl._wrap(domObject);
    case 'XMLHttpRequestException': return new _XMLHttpRequestExceptionImpl._wrap(domObject);
    case 'XMLHttpRequestProgressEvent': return new _XMLHttpRequestProgressEventImpl._wrap(domObject);
    case 'XMLHttpRequestUpload': return new _XMLHttpRequestUploadImpl._wrap(domObject);
    case 'XMLSerializer': return new _XMLSerializerImpl._wrap(domObject);
    case 'XPathEvaluator': return new _XPathEvaluatorImpl._wrap(domObject);
    case 'XPathException': return new _XPathExceptionImpl._wrap(domObject);
    case 'XPathExpression': return new _XPathExpressionImpl._wrap(domObject);
    case 'XPathNSResolver': return new _XPathNSResolverImpl._wrap(domObject);
    case 'XPathResult': return new _XPathResultImpl._wrap(domObject);
    case 'XSLTProcessor': return new _XSLTProcessorImpl._wrap(domObject);
    case 'HTMLDocument':
      return new _DocumentImpl._wrap(domObject);
    default:
      throw 'Unrecognized object $domObject. Name=${domObject.typeName}';
  }
}

spawnDomIsolate(Window targetWindow, String entryPoint) =>
  dom.spawnDomIsolate(_unwrap(targetWindow), entryPoint);

dom.LayoutTestController get layoutTestController() =>
  dom.layoutTestController;

class _AbstractWorkerImpl extends _EventTargetImpl implements AbstractWorker {
  _AbstractWorkerImpl._wrap(ptr) : super._wrap(ptr);

  _AbstractWorkerEventsImpl get on() {
    if (_on == null) _on = new _AbstractWorkerEventsImpl(this);
    return _on;
  }

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool $dom_dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _AbstractWorkerEventsImpl extends _EventsImpl implements AbstractWorkerEvents {
  _AbstractWorkerEventsImpl(_ptr) : super(_ptr);

  EventListenerList get error() => _get('error');
}

class _AnchorElementImpl extends _ElementImpl implements AnchorElement {
  _AnchorElementImpl._wrap(ptr) : super._wrap(ptr);

  String get charset() => _wrap(_ptr.charset);

  void set charset(String value) { _ptr.charset = _unwrap(value); }

  String get coords() => _wrap(_ptr.coords);

  void set coords(String value) { _ptr.coords = _unwrap(value); }

  String get download() => _wrap(_ptr.download);

  void set download(String value) { _ptr.download = _unwrap(value); }

  String get hash() => _wrap(_ptr.hash);

  void set hash(String value) { _ptr.hash = _unwrap(value); }

  String get host() => _wrap(_ptr.host);

  void set host(String value) { _ptr.host = _unwrap(value); }

  String get hostname() => _wrap(_ptr.hostname);

  void set hostname(String value) { _ptr.hostname = _unwrap(value); }

  String get href() => _wrap(_ptr.href);

  void set href(String value) { _ptr.href = _unwrap(value); }

  String get hreflang() => _wrap(_ptr.hreflang);

  void set hreflang(String value) { _ptr.hreflang = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get origin() => _wrap(_ptr.origin);

  String get pathname() => _wrap(_ptr.pathname);

  void set pathname(String value) { _ptr.pathname = _unwrap(value); }

  String get ping() => _wrap(_ptr.ping);

  void set ping(String value) { _ptr.ping = _unwrap(value); }

  String get port() => _wrap(_ptr.port);

  void set port(String value) { _ptr.port = _unwrap(value); }

  String get protocol() => _wrap(_ptr.protocol);

  void set protocol(String value) { _ptr.protocol = _unwrap(value); }

  String get rel() => _wrap(_ptr.rel);

  void set rel(String value) { _ptr.rel = _unwrap(value); }

  String get rev() => _wrap(_ptr.rev);

  void set rev(String value) { _ptr.rev = _unwrap(value); }

  String get search() => _wrap(_ptr.search);

  void set search(String value) { _ptr.search = _unwrap(value); }

  String get shape() => _wrap(_ptr.shape);

  void set shape(String value) { _ptr.shape = _unwrap(value); }

  String get target() => _wrap(_ptr.target);

  void set target(String value) { _ptr.target = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _AnimationImpl extends _DOMTypeBase implements Animation {
  _AnimationImpl._wrap(ptr) : super._wrap(ptr);

  num get delay() => _wrap(_ptr.delay);

  int get direction() => _wrap(_ptr.direction);

  num get duration() => _wrap(_ptr.duration);

  num get elapsedTime() => _wrap(_ptr.elapsedTime);

  void set elapsedTime(num value) { _ptr.elapsedTime = _unwrap(value); }

  bool get ended() => _wrap(_ptr.ended);

  int get fillMode() => _wrap(_ptr.fillMode);

  int get iterationCount() => _wrap(_ptr.iterationCount);

  String get name() => _wrap(_ptr.name);

  bool get paused() => _wrap(_ptr.paused);

  void pause() {
    _ptr.pause();
    return;
  }

  void play() {
    _ptr.play();
    return;
  }
}

class _AnimationEventImpl extends _EventImpl implements AnimationEvent {
  _AnimationEventImpl._wrap(ptr) : super._wrap(ptr);

  String get animationName() => _wrap(_ptr.animationName);

  num get elapsedTime() => _wrap(_ptr.elapsedTime);
}

class _AnimationListImpl extends _DOMTypeBase implements AnimationList {
  _AnimationListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Animation item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _AppletElementImpl extends _ElementImpl implements AppletElement {
  _AppletElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get alt() => _wrap(_ptr.alt);

  void set alt(String value) { _ptr.alt = _unwrap(value); }

  String get archive() => _wrap(_ptr.archive);

  void set archive(String value) { _ptr.archive = _unwrap(value); }

  String get code() => _wrap(_ptr.code);

  void set code(String value) { _ptr.code = _unwrap(value); }

  String get codeBase() => _wrap(_ptr.codeBase);

  void set codeBase(String value) { _ptr.codeBase = _unwrap(value); }

  String get height() => _wrap(_ptr.height);

  void set height(String value) { _ptr.height = _unwrap(value); }

  String get hspace() => _wrap(_ptr.hspace);

  void set hspace(String value) { _ptr.hspace = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get object() => _wrap(_ptr.object);

  void set object(String value) { _ptr.object = _unwrap(value); }

  String get vspace() => _wrap(_ptr.vspace);

  void set vspace(String value) { _ptr.vspace = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }
}

class _AreaElementImpl extends _ElementImpl implements AreaElement {
  _AreaElementImpl._wrap(ptr) : super._wrap(ptr);

  String get alt() => _wrap(_ptr.alt);

  void set alt(String value) { _ptr.alt = _unwrap(value); }

  String get coords() => _wrap(_ptr.coords);

  void set coords(String value) { _ptr.coords = _unwrap(value); }

  String get hash() => _wrap(_ptr.hash);

  String get host() => _wrap(_ptr.host);

  String get hostname() => _wrap(_ptr.hostname);

  String get href() => _wrap(_ptr.href);

  void set href(String value) { _ptr.href = _unwrap(value); }

  bool get noHref() => _wrap(_ptr.noHref);

  void set noHref(bool value) { _ptr.noHref = _unwrap(value); }

  String get pathname() => _wrap(_ptr.pathname);

  String get ping() => _wrap(_ptr.ping);

  void set ping(String value) { _ptr.ping = _unwrap(value); }

  String get port() => _wrap(_ptr.port);

  String get protocol() => _wrap(_ptr.protocol);

  String get search() => _wrap(_ptr.search);

  String get shape() => _wrap(_ptr.shape);

  void set shape(String value) { _ptr.shape = _unwrap(value); }

  String get target() => _wrap(_ptr.target);

  void set target(String value) { _ptr.target = _unwrap(value); }
}

class _ArrayBufferImpl extends _DOMTypeBase implements ArrayBuffer {
  _ArrayBufferImpl._wrap(ptr) : super._wrap(ptr);

  int get byteLength() => _wrap(_ptr.byteLength);

  ArrayBuffer slice(int begin, [int end = null]) {
    if (end === null) {
      return _wrap(_ptr.slice(_unwrap(begin)));
    } else {
      return _wrap(_ptr.slice(_unwrap(begin), _unwrap(end)));
    }
  }
}

class _ArrayBufferViewImpl extends _DOMTypeBase implements ArrayBufferView {
  _ArrayBufferViewImpl._wrap(ptr) : super._wrap(ptr);

  ArrayBuffer get buffer() => _wrap(_ptr.buffer);

  int get byteLength() => _wrap(_ptr.byteLength);

  int get byteOffset() => _wrap(_ptr.byteOffset);
}

class _AttrImpl extends _NodeImpl implements Attr {
  _AttrImpl._wrap(ptr) : super._wrap(ptr);

  bool get isId() => _wrap(_ptr.isId);

  String get name() => _wrap(_ptr.name);

  Element get ownerElement() => _wrap(_ptr.ownerElement);

  bool get specified() => _wrap(_ptr.specified);

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }
}

class _AudioBufferImpl extends _DOMTypeBase implements AudioBuffer {
  _AudioBufferImpl._wrap(ptr) : super._wrap(ptr);

  num get duration() => _wrap(_ptr.duration);

  num get gain() => _wrap(_ptr.gain);

  void set gain(num value) { _ptr.gain = _unwrap(value); }

  int get length() => _wrap(_ptr.length);

  int get numberOfChannels() => _wrap(_ptr.numberOfChannels);

  num get sampleRate() => _wrap(_ptr.sampleRate);

  Float32Array getChannelData(int channelIndex) {
    return _wrap(_ptr.getChannelData(_unwrap(channelIndex)));
  }
}

class _AudioBufferSourceNodeImpl extends _AudioSourceNodeImpl implements AudioBufferSourceNode {
  _AudioBufferSourceNodeImpl._wrap(ptr) : super._wrap(ptr);

  AudioBuffer get buffer() => _wrap(_ptr.buffer);

  void set buffer(AudioBuffer value) { _ptr.buffer = _unwrap(value); }

  AudioGain get gain() => _wrap(_ptr.gain);

  bool get loop() => _wrap(_ptr.loop);

  void set loop(bool value) { _ptr.loop = _unwrap(value); }

  bool get looping() => _wrap(_ptr.looping);

  void set looping(bool value) { _ptr.looping = _unwrap(value); }

  AudioParam get playbackRate() => _wrap(_ptr.playbackRate);

  int get playbackState() => _wrap(_ptr.playbackState);

  void noteGrainOn(num when, num grainOffset, num grainDuration) {
    _ptr.noteGrainOn(_unwrap(when), _unwrap(grainOffset), _unwrap(grainDuration));
    return;
  }

  void noteOff(num when) {
    _ptr.noteOff(_unwrap(when));
    return;
  }

  void noteOn(num when) {
    _ptr.noteOn(_unwrap(when));
    return;
  }
}

class _AudioChannelMergerImpl extends _AudioNodeImpl implements AudioChannelMerger {
  _AudioChannelMergerImpl._wrap(ptr) : super._wrap(ptr);
}

class _AudioChannelSplitterImpl extends _AudioNodeImpl implements AudioChannelSplitter {
  _AudioChannelSplitterImpl._wrap(ptr) : super._wrap(ptr);
}

class _AudioContextImpl extends _EventTargetImpl implements AudioContext {
  _AudioContextImpl._wrap(ptr) : super._wrap(ptr);

  _AudioContextEventsImpl get on() {
    if (_on == null) _on = new _AudioContextEventsImpl(this);
    return _on;
  }

  int get activeSourceCount() => _wrap(_ptr.activeSourceCount);

  num get currentTime() => _wrap(_ptr.currentTime);

  AudioDestinationNode get destination() => _wrap(_ptr.destination);

  AudioListener get listener() => _wrap(_ptr.listener);

  num get sampleRate() => _wrap(_ptr.sampleRate);

  RealtimeAnalyserNode createAnalyser() {
    return _wrap(_ptr.createAnalyser());
  }

  BiquadFilterNode createBiquadFilter() {
    return _wrap(_ptr.createBiquadFilter());
  }

  AudioBuffer createBuffer(buffer_OR_numberOfChannels, mixToMono_OR_numberOfFrames, [num sampleRate = null]) {
    if (buffer_OR_numberOfChannels is ArrayBuffer) {
      if (mixToMono_OR_numberOfFrames is bool) {
        if (sampleRate === null) {
          return _wrap(_ptr.createBuffer(_unwrap(buffer_OR_numberOfChannels), _unwrap(mixToMono_OR_numberOfFrames)));
        }
      }
    } else {
      if (buffer_OR_numberOfChannels is int) {
        if (mixToMono_OR_numberOfFrames is int) {
          return _wrap(_ptr.createBuffer(_unwrap(buffer_OR_numberOfChannels), _unwrap(mixToMono_OR_numberOfFrames), _unwrap(sampleRate)));
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  AudioBufferSourceNode createBufferSource() {
    return _wrap(_ptr.createBufferSource());
  }

  AudioChannelMerger createChannelMerger([int numberOfInputs = null]) {
    if (numberOfInputs === null) {
      return _wrap(_ptr.createChannelMerger());
    } else {
      return _wrap(_ptr.createChannelMerger(_unwrap(numberOfInputs)));
    }
  }

  AudioChannelSplitter createChannelSplitter([int numberOfOutputs = null]) {
    if (numberOfOutputs === null) {
      return _wrap(_ptr.createChannelSplitter());
    } else {
      return _wrap(_ptr.createChannelSplitter(_unwrap(numberOfOutputs)));
    }
  }

  ConvolverNode createConvolver() {
    return _wrap(_ptr.createConvolver());
  }

  DelayNode createDelayNode([num maxDelayTime = null]) {
    if (maxDelayTime === null) {
      return _wrap(_ptr.createDelayNode());
    } else {
      return _wrap(_ptr.createDelayNode(_unwrap(maxDelayTime)));
    }
  }

  DynamicsCompressorNode createDynamicsCompressor() {
    return _wrap(_ptr.createDynamicsCompressor());
  }

  AudioGainNode createGainNode() {
    return _wrap(_ptr.createGainNode());
  }

  JavaScriptAudioNode createJavaScriptNode(int bufferSize, [int numberOfInputChannels = null, int numberOfOutputChannels = null]) {
    if (numberOfInputChannels === null) {
      if (numberOfOutputChannels === null) {
        return _wrap(_ptr.createJavaScriptNode(_unwrap(bufferSize)));
      }
    } else {
      if (numberOfOutputChannels === null) {
        return _wrap(_ptr.createJavaScriptNode(_unwrap(bufferSize), _unwrap(numberOfInputChannels)));
      } else {
        return _wrap(_ptr.createJavaScriptNode(_unwrap(bufferSize), _unwrap(numberOfInputChannels), _unwrap(numberOfOutputChannels)));
      }
    }
    throw "Incorrect number or type of arguments";
  }

  MediaElementAudioSourceNode createMediaElementSource(MediaElement mediaElement) {
    return _wrap(_ptr.createMediaElementSource(_unwrap(mediaElement)));
  }

  Oscillator createOscillator() {
    return _wrap(_ptr.createOscillator());
  }

  AudioPannerNode createPanner() {
    return _wrap(_ptr.createPanner());
  }

  WaveShaperNode createWaveShaper() {
    return _wrap(_ptr.createWaveShaper());
  }

  WaveTable createWaveTable(Float32Array real, Float32Array imag) {
    return _wrap(_ptr.createWaveTable(_unwrap(real), _unwrap(imag)));
  }

  void decodeAudioData(ArrayBuffer audioData, AudioBufferCallback successCallback, [AudioBufferCallback errorCallback = null]) {
    if (errorCallback === null) {
      _ptr.decodeAudioData(_unwrap(audioData), _unwrap(successCallback));
      return;
    } else {
      _ptr.decodeAudioData(_unwrap(audioData), _unwrap(successCallback), _unwrap(errorCallback));
      return;
    }
  }

  void startRendering() {
    _ptr.startRendering();
    return;
  }
}

class _AudioContextEventsImpl extends _EventsImpl implements AudioContextEvents {
  _AudioContextEventsImpl(_ptr) : super(_ptr);

  EventListenerList get complete() => _get('complete');
}

class _AudioDestinationNodeImpl extends _AudioNodeImpl implements AudioDestinationNode {
  _AudioDestinationNodeImpl._wrap(ptr) : super._wrap(ptr);

  int get numberOfChannels() => _wrap(_ptr.numberOfChannels);
}

class _AudioElementImpl extends _MediaElementImpl implements AudioElement {
  _AudioElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _AudioGainImpl extends _AudioParamImpl implements AudioGain {
  _AudioGainImpl._wrap(ptr) : super._wrap(ptr);
}

class _AudioGainNodeImpl extends _AudioNodeImpl implements AudioGainNode {
  _AudioGainNodeImpl._wrap(ptr) : super._wrap(ptr);

  AudioGain get gain() => _wrap(_ptr.gain);
}

class _AudioListenerImpl extends _DOMTypeBase implements AudioListener {
  _AudioListenerImpl._wrap(ptr) : super._wrap(ptr);

  num get dopplerFactor() => _wrap(_ptr.dopplerFactor);

  void set dopplerFactor(num value) { _ptr.dopplerFactor = _unwrap(value); }

  num get speedOfSound() => _wrap(_ptr.speedOfSound);

  void set speedOfSound(num value) { _ptr.speedOfSound = _unwrap(value); }

  void setOrientation(num x, num y, num z, num xUp, num yUp, num zUp) {
    _ptr.setOrientation(_unwrap(x), _unwrap(y), _unwrap(z), _unwrap(xUp), _unwrap(yUp), _unwrap(zUp));
    return;
  }

  void setPosition(num x, num y, num z) {
    _ptr.setPosition(_unwrap(x), _unwrap(y), _unwrap(z));
    return;
  }

  void setVelocity(num x, num y, num z) {
    _ptr.setVelocity(_unwrap(x), _unwrap(y), _unwrap(z));
    return;
  }
}

class _AudioNodeImpl extends _DOMTypeBase implements AudioNode {
  _AudioNodeImpl._wrap(ptr) : super._wrap(ptr);

  AudioContext get context() => _wrap(_ptr.context);

  int get numberOfInputs() => _wrap(_ptr.numberOfInputs);

  int get numberOfOutputs() => _wrap(_ptr.numberOfOutputs);

  void connect(destination, int output, [int input = null]) {
    if (destination is AudioParam) {
      if (input === null) {
        _ptr.connect(_unwrap(destination), _unwrap(output));
        return;
      }
    } else {
      if (destination is AudioNode) {
        _ptr.connect(_unwrap(destination), _unwrap(output), _unwrap(input));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void disconnect(int output) {
    _ptr.disconnect(_unwrap(output));
    return;
  }
}

class _AudioPannerNodeImpl extends _AudioNodeImpl implements AudioPannerNode {
  _AudioPannerNodeImpl._wrap(ptr) : super._wrap(ptr);

  AudioGain get coneGain() => _wrap(_ptr.coneGain);

  num get coneInnerAngle() => _wrap(_ptr.coneInnerAngle);

  void set coneInnerAngle(num value) { _ptr.coneInnerAngle = _unwrap(value); }

  num get coneOuterAngle() => _wrap(_ptr.coneOuterAngle);

  void set coneOuterAngle(num value) { _ptr.coneOuterAngle = _unwrap(value); }

  num get coneOuterGain() => _wrap(_ptr.coneOuterGain);

  void set coneOuterGain(num value) { _ptr.coneOuterGain = _unwrap(value); }

  AudioGain get distanceGain() => _wrap(_ptr.distanceGain);

  int get distanceModel() => _wrap(_ptr.distanceModel);

  void set distanceModel(int value) { _ptr.distanceModel = _unwrap(value); }

  num get maxDistance() => _wrap(_ptr.maxDistance);

  void set maxDistance(num value) { _ptr.maxDistance = _unwrap(value); }

  int get panningModel() => _wrap(_ptr.panningModel);

  void set panningModel(int value) { _ptr.panningModel = _unwrap(value); }

  num get refDistance() => _wrap(_ptr.refDistance);

  void set refDistance(num value) { _ptr.refDistance = _unwrap(value); }

  num get rolloffFactor() => _wrap(_ptr.rolloffFactor);

  void set rolloffFactor(num value) { _ptr.rolloffFactor = _unwrap(value); }

  void setOrientation(num x, num y, num z) {
    _ptr.setOrientation(_unwrap(x), _unwrap(y), _unwrap(z));
    return;
  }

  void setPosition(num x, num y, num z) {
    _ptr.setPosition(_unwrap(x), _unwrap(y), _unwrap(z));
    return;
  }

  void setVelocity(num x, num y, num z) {
    _ptr.setVelocity(_unwrap(x), _unwrap(y), _unwrap(z));
    return;
  }
}

class _AudioParamImpl extends _DOMTypeBase implements AudioParam {
  _AudioParamImpl._wrap(ptr) : super._wrap(ptr);

  num get defaultValue() => _wrap(_ptr.defaultValue);

  num get maxValue() => _wrap(_ptr.maxValue);

  num get minValue() => _wrap(_ptr.minValue);

  String get name() => _wrap(_ptr.name);

  int get units() => _wrap(_ptr.units);

  num get value() => _wrap(_ptr.value);

  void set value(num value) { _ptr.value = _unwrap(value); }

  void cancelScheduledValues(num startTime) {
    _ptr.cancelScheduledValues(_unwrap(startTime));
    return;
  }

  void exponentialRampToValueAtTime(num value, num time) {
    _ptr.exponentialRampToValueAtTime(_unwrap(value), _unwrap(time));
    return;
  }

  void linearRampToValueAtTime(num value, num time) {
    _ptr.linearRampToValueAtTime(_unwrap(value), _unwrap(time));
    return;
  }

  void setTargetValueAtTime(num targetValue, num time, num timeConstant) {
    _ptr.setTargetValueAtTime(_unwrap(targetValue), _unwrap(time), _unwrap(timeConstant));
    return;
  }

  void setValueAtTime(num value, num time) {
    _ptr.setValueAtTime(_unwrap(value), _unwrap(time));
    return;
  }

  void setValueCurveAtTime(Float32Array values, num time, num duration) {
    _ptr.setValueCurveAtTime(_unwrap(values), _unwrap(time), _unwrap(duration));
    return;
  }
}

class _AudioProcessingEventImpl extends _EventImpl implements AudioProcessingEvent {
  _AudioProcessingEventImpl._wrap(ptr) : super._wrap(ptr);

  AudioBuffer get inputBuffer() => _wrap(_ptr.inputBuffer);

  AudioBuffer get outputBuffer() => _wrap(_ptr.outputBuffer);
}

class _AudioSourceNodeImpl extends _AudioNodeImpl implements AudioSourceNode {
  _AudioSourceNodeImpl._wrap(ptr) : super._wrap(ptr);
}

class _BRElementImpl extends _ElementImpl implements BRElement {
  _BRElementImpl._wrap(ptr) : super._wrap(ptr);

  String get clear() => _wrap(_ptr.clear);

  void set clear(String value) { _ptr.clear = _unwrap(value); }
}

class _BarInfoImpl extends _DOMTypeBase implements BarInfo {
  _BarInfoImpl._wrap(ptr) : super._wrap(ptr);

  bool get visible() => _wrap(_ptr.visible);
}

class _BaseElementImpl extends _ElementImpl implements BaseElement {
  _BaseElementImpl._wrap(ptr) : super._wrap(ptr);

  String get href() => _wrap(_ptr.href);

  void set href(String value) { _ptr.href = _unwrap(value); }

  String get target() => _wrap(_ptr.target);

  void set target(String value) { _ptr.target = _unwrap(value); }
}

class _BaseFontElementImpl extends _ElementImpl implements BaseFontElement {
  _BaseFontElementImpl._wrap(ptr) : super._wrap(ptr);

  String get color() => _wrap(_ptr.color);

  void set color(String value) { _ptr.color = _unwrap(value); }

  String get face() => _wrap(_ptr.face);

  void set face(String value) { _ptr.face = _unwrap(value); }

  int get size() => _wrap(_ptr.size);

  void set size(int value) { _ptr.size = _unwrap(value); }
}

class _BatteryManagerImpl extends _EventTargetImpl implements BatteryManager {
  _BatteryManagerImpl._wrap(ptr) : super._wrap(ptr);

  _BatteryManagerEventsImpl get on() {
    if (_on == null) _on = new _BatteryManagerEventsImpl(this);
    return _on;
  }

  bool get charging() => _wrap(_ptr.charging);

  num get chargingTime() => _wrap(_ptr.chargingTime);

  num get dischargingTime() => _wrap(_ptr.dischargingTime);

  num get level() => _wrap(_ptr.level);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool $dom_dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _BatteryManagerEventsImpl extends _EventsImpl implements BatteryManagerEvents {
  _BatteryManagerEventsImpl(_ptr) : super(_ptr);

  EventListenerList get chargingChange() => _get('chargingchange');

  EventListenerList get chargingTimeChange() => _get('chargingtimechange');

  EventListenerList get dischargingTimeChange() => _get('dischargingtimechange');

  EventListenerList get levelChange() => _get('levelchange');
}

class _BeforeLoadEventImpl extends _EventImpl implements BeforeLoadEvent {
  _BeforeLoadEventImpl._wrap(ptr) : super._wrap(ptr);

  String get url() => _wrap(_ptr.url);
}

class _BiquadFilterNodeImpl extends _AudioNodeImpl implements BiquadFilterNode {
  _BiquadFilterNodeImpl._wrap(ptr) : super._wrap(ptr);

  AudioParam get Q() => _wrap(_ptr.Q);

  AudioParam get frequency() => _wrap(_ptr.frequency);

  AudioParam get gain() => _wrap(_ptr.gain);

  int get type() => _wrap(_ptr.type);

  void set type(int value) { _ptr.type = _unwrap(value); }

  void getFrequencyResponse(Float32Array frequencyHz, Float32Array magResponse, Float32Array phaseResponse) {
    _ptr.getFrequencyResponse(_unwrap(frequencyHz), _unwrap(magResponse), _unwrap(phaseResponse));
    return;
  }
}

class _BlobImpl extends _DOMTypeBase implements Blob {
  _BlobImpl._wrap(ptr) : super._wrap(ptr);

  int get size() => _wrap(_ptr.size);

  String get type() => _wrap(_ptr.type);

  Blob webkitSlice([int start = null, int end = null, String contentType = null]) {
    if (start === null) {
      if (end === null) {
        if (contentType === null) {
          return _wrap(_ptr.webkitSlice());
        }
      }
    } else {
      if (end === null) {
        if (contentType === null) {
          return _wrap(_ptr.webkitSlice(_unwrap(start)));
        }
      } else {
        if (contentType === null) {
          return _wrap(_ptr.webkitSlice(_unwrap(start), _unwrap(end)));
        } else {
          return _wrap(_ptr.webkitSlice(_unwrap(start), _unwrap(end), _unwrap(contentType)));
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }
}

class _BodyElementImpl extends _ElementImpl implements BodyElement {
  _BodyElementImpl._wrap(ptr) : super._wrap(ptr);

  _BodyElementEventsImpl get on() {
    if (_on == null) _on = new _BodyElementEventsImpl(this);
    return _on;
  }

  String get aLink() => _wrap(_ptr.aLink);

  void set aLink(String value) { _ptr.aLink = _unwrap(value); }

  String get background() => _wrap(_ptr.background);

  void set background(String value) { _ptr.background = _unwrap(value); }

  String get bgColor() => _wrap(_ptr.bgColor);

  void set bgColor(String value) { _ptr.bgColor = _unwrap(value); }

  String get link() => _wrap(_ptr.link);

  void set link(String value) { _ptr.link = _unwrap(value); }

  String get vLink() => _wrap(_ptr.vLink);

  void set vLink(String value) { _ptr.vLink = _unwrap(value); }
}

class _BodyElementEventsImpl extends _ElementEventsImpl implements BodyElementEvents {
  _BodyElementEventsImpl(_ptr) : super(_ptr);

  EventListenerList get beforeUnload() => _get('beforeunload');

  EventListenerList get blur() => _get('blur');

  EventListenerList get error() => _get('error');

  EventListenerList get focus() => _get('focus');

  EventListenerList get hashChange() => _get('hashchange');

  EventListenerList get load() => _get('load');

  EventListenerList get message() => _get('message');

  EventListenerList get offline() => _get('offline');

  EventListenerList get online() => _get('online');

  EventListenerList get popState() => _get('popstate');

  EventListenerList get resize() => _get('resize');

  EventListenerList get storage() => _get('storage');

  EventListenerList get unload() => _get('unload');
}

class _ButtonElementImpl extends _ElementImpl implements ButtonElement {
  _ButtonElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get autofocus() => _wrap(_ptr.autofocus);

  void set autofocus(bool value) { _ptr.autofocus = _unwrap(value); }

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  FormElement get form() => _wrap(_ptr.form);

  String get formAction() => _wrap(_ptr.formAction);

  void set formAction(String value) { _ptr.formAction = _unwrap(value); }

  String get formEnctype() => _wrap(_ptr.formEnctype);

  void set formEnctype(String value) { _ptr.formEnctype = _unwrap(value); }

  String get formMethod() => _wrap(_ptr.formMethod);

  void set formMethod(String value) { _ptr.formMethod = _unwrap(value); }

  bool get formNoValidate() => _wrap(_ptr.formNoValidate);

  void set formNoValidate(bool value) { _ptr.formNoValidate = _unwrap(value); }

  String get formTarget() => _wrap(_ptr.formTarget);

  void set formTarget(String value) { _ptr.formTarget = _unwrap(value); }

  NodeList get labels() => _wrap(_ptr.labels);

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  String get validationMessage() => _wrap(_ptr.validationMessage);

  ValidityState get validity() => _wrap(_ptr.validity);

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }

  bool get willValidate() => _wrap(_ptr.willValidate);

  bool checkValidity() {
    return _wrap(_ptr.checkValidity());
  }

  void setCustomValidity(String error) {
    _ptr.setCustomValidity(_unwrap(error));
    return;
  }
}

class _CDATASectionImpl extends _TextImpl implements CDATASection {
  _CDATASectionImpl._wrap(ptr) : super._wrap(ptr);
}

class _CSSCharsetRuleImpl extends _CSSRuleImpl implements CSSCharsetRule {
  _CSSCharsetRuleImpl._wrap(ptr) : super._wrap(ptr);

  String get encoding() => _wrap(_ptr.encoding);

  void set encoding(String value) { _ptr.encoding = _unwrap(value); }
}

class _CSSFontFaceRuleImpl extends _CSSRuleImpl implements CSSFontFaceRule {
  _CSSFontFaceRuleImpl._wrap(ptr) : super._wrap(ptr);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);
}

class _CSSImportRuleImpl extends _CSSRuleImpl implements CSSImportRule {
  _CSSImportRuleImpl._wrap(ptr) : super._wrap(ptr);

  String get href() => _wrap(_ptr.href);

  MediaList get media() => _wrap(_ptr.media);

  CSSStyleSheet get styleSheet() => _wrap(_ptr.styleSheet);
}

class _CSSKeyframeRuleImpl extends _CSSRuleImpl implements CSSKeyframeRule {
  _CSSKeyframeRuleImpl._wrap(ptr) : super._wrap(ptr);

  String get keyText() => _wrap(_ptr.keyText);

  void set keyText(String value) { _ptr.keyText = _unwrap(value); }

  CSSStyleDeclaration get style() => _wrap(_ptr.style);
}

class _CSSKeyframesRuleImpl extends _CSSRuleImpl implements CSSKeyframesRule {
  _CSSKeyframesRuleImpl._wrap(ptr) : super._wrap(ptr);

  CSSRuleList get cssRules() => _wrap(_ptr.cssRules);

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  void deleteRule(String key) {
    _ptr.deleteRule(_unwrap(key));
    return;
  }

  CSSKeyframeRule findRule(String key) {
    return _wrap(_ptr.findRule(_unwrap(key)));
  }

  void insertRule(String rule) {
    _ptr.insertRule(_unwrap(rule));
    return;
  }
}

class _CSSMatrixImpl extends _DOMTypeBase implements CSSMatrix {
  _CSSMatrixImpl._wrap(ptr) : super._wrap(ptr);

  num get a() => _wrap(_ptr.a);

  void set a(num value) { _ptr.a = _unwrap(value); }

  num get b() => _wrap(_ptr.b);

  void set b(num value) { _ptr.b = _unwrap(value); }

  num get c() => _wrap(_ptr.c);

  void set c(num value) { _ptr.c = _unwrap(value); }

  num get d() => _wrap(_ptr.d);

  void set d(num value) { _ptr.d = _unwrap(value); }

  num get e() => _wrap(_ptr.e);

  void set e(num value) { _ptr.e = _unwrap(value); }

  num get f() => _wrap(_ptr.f);

  void set f(num value) { _ptr.f = _unwrap(value); }

  num get m11() => _wrap(_ptr.m11);

  void set m11(num value) { _ptr.m11 = _unwrap(value); }

  num get m12() => _wrap(_ptr.m12);

  void set m12(num value) { _ptr.m12 = _unwrap(value); }

  num get m13() => _wrap(_ptr.m13);

  void set m13(num value) { _ptr.m13 = _unwrap(value); }

  num get m14() => _wrap(_ptr.m14);

  void set m14(num value) { _ptr.m14 = _unwrap(value); }

  num get m21() => _wrap(_ptr.m21);

  void set m21(num value) { _ptr.m21 = _unwrap(value); }

  num get m22() => _wrap(_ptr.m22);

  void set m22(num value) { _ptr.m22 = _unwrap(value); }

  num get m23() => _wrap(_ptr.m23);

  void set m23(num value) { _ptr.m23 = _unwrap(value); }

  num get m24() => _wrap(_ptr.m24);

  void set m24(num value) { _ptr.m24 = _unwrap(value); }

  num get m31() => _wrap(_ptr.m31);

  void set m31(num value) { _ptr.m31 = _unwrap(value); }

  num get m32() => _wrap(_ptr.m32);

  void set m32(num value) { _ptr.m32 = _unwrap(value); }

  num get m33() => _wrap(_ptr.m33);

  void set m33(num value) { _ptr.m33 = _unwrap(value); }

  num get m34() => _wrap(_ptr.m34);

  void set m34(num value) { _ptr.m34 = _unwrap(value); }

  num get m41() => _wrap(_ptr.m41);

  void set m41(num value) { _ptr.m41 = _unwrap(value); }

  num get m42() => _wrap(_ptr.m42);

  void set m42(num value) { _ptr.m42 = _unwrap(value); }

  num get m43() => _wrap(_ptr.m43);

  void set m43(num value) { _ptr.m43 = _unwrap(value); }

  num get m44() => _wrap(_ptr.m44);

  void set m44(num value) { _ptr.m44 = _unwrap(value); }

  CSSMatrix inverse() {
    return _wrap(_ptr.inverse());
  }

  CSSMatrix multiply(CSSMatrix secondMatrix) {
    return _wrap(_ptr.multiply(_unwrap(secondMatrix)));
  }

  CSSMatrix rotate(num rotX, num rotY, num rotZ) {
    return _wrap(_ptr.rotate(_unwrap(rotX), _unwrap(rotY), _unwrap(rotZ)));
  }

  CSSMatrix rotateAxisAngle(num x, num y, num z, num angle) {
    return _wrap(_ptr.rotateAxisAngle(_unwrap(x), _unwrap(y), _unwrap(z), _unwrap(angle)));
  }

  CSSMatrix scale(num scaleX, num scaleY, num scaleZ) {
    return _wrap(_ptr.scale(_unwrap(scaleX), _unwrap(scaleY), _unwrap(scaleZ)));
  }

  void setMatrixValue(String string) {
    _ptr.setMatrixValue(_unwrap(string));
    return;
  }

  CSSMatrix skewX(num angle) {
    return _wrap(_ptr.skewX(_unwrap(angle)));
  }

  CSSMatrix skewY(num angle) {
    return _wrap(_ptr.skewY(_unwrap(angle)));
  }

  String toString() {
    return _wrap(_ptr.toString());
  }

  CSSMatrix translate(num x, num y, num z) {
    return _wrap(_ptr.translate(_unwrap(x), _unwrap(y), _unwrap(z)));
  }
}

class _CSSMediaRuleImpl extends _CSSRuleImpl implements CSSMediaRule {
  _CSSMediaRuleImpl._wrap(ptr) : super._wrap(ptr);

  CSSRuleList get cssRules() => _wrap(_ptr.cssRules);

  MediaList get media() => _wrap(_ptr.media);

  void deleteRule(int index) {
    _ptr.deleteRule(_unwrap(index));
    return;
  }

  int insertRule(String rule, int index) {
    return _wrap(_ptr.insertRule(_unwrap(rule), _unwrap(index)));
  }
}

class _CSSPageRuleImpl extends _CSSRuleImpl implements CSSPageRule {
  _CSSPageRuleImpl._wrap(ptr) : super._wrap(ptr);

  String get selectorText() => _wrap(_ptr.selectorText);

  void set selectorText(String value) { _ptr.selectorText = _unwrap(value); }

  CSSStyleDeclaration get style() => _wrap(_ptr.style);
}

class _CSSPrimitiveValueImpl extends _CSSValueImpl implements CSSPrimitiveValue {
  _CSSPrimitiveValueImpl._wrap(ptr) : super._wrap(ptr);

  int get primitiveType() => _wrap(_ptr.primitiveType);

  Counter getCounterValue() {
    return _wrap(_ptr.getCounterValue());
  }

  num getFloatValue(int unitType) {
    return _wrap(_ptr.getFloatValue(_unwrap(unitType)));
  }

  RGBColor getRGBColorValue() {
    return _wrap(_ptr.getRGBColorValue());
  }

  Rect getRectValue() {
    return _wrap(_ptr.getRectValue());
  }

  String getStringValue() {
    return _wrap(_ptr.getStringValue());
  }

  void setFloatValue(int unitType, num floatValue) {
    _ptr.setFloatValue(_unwrap(unitType), _unwrap(floatValue));
    return;
  }

  void setStringValue(int stringType, String stringValue) {
    _ptr.setStringValue(_unwrap(stringType), _unwrap(stringValue));
    return;
  }
}

class _CSSRuleImpl extends _DOMTypeBase implements CSSRule {
  _CSSRuleImpl._wrap(ptr) : super._wrap(ptr);

  String get cssText() => _wrap(_ptr.cssText);

  void set cssText(String value) { _ptr.cssText = _unwrap(value); }

  CSSRule get parentRule() => _wrap(_ptr.parentRule);

  CSSStyleSheet get parentStyleSheet() => _wrap(_ptr.parentStyleSheet);

  int get type() => _wrap(_ptr.type);
}

class _CSSRuleListImpl extends _DOMTypeBase implements CSSRuleList {
  _CSSRuleListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  CSSRule item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

String _cachedBrowserPrefix;

String get _browserPrefix() {
  if (_cachedBrowserPrefix === null) {
    if (_Device.isFirefox) {
      _cachedBrowserPrefix = '-moz-';
    } else {
      _cachedBrowserPrefix = '-webkit-';
    }
    // TODO(jacobr): support IE 9.0 and Opera as well.
  }
  return _cachedBrowserPrefix;
}

class _CSSStyleDeclarationImpl extends _DOMTypeBase implements CSSStyleDeclaration {

  _CSSStyleDeclarationImpl._wrap(ptr) : super._wrap(ptr);

  String get cssText() => _wrap(_ptr.cssText);

  void set cssText(String value) { _ptr.cssText = _unwrap(value); }

  int get length() => _wrap(_ptr.length);

  CSSRule get parentRule() => _wrap(_ptr.parentRule);

  CSSValue getPropertyCSSValue(String propertyName) {
    return _wrap(_ptr.getPropertyCSSValue(_unwrap(propertyName)));
  }

  String getPropertyPriority(String propertyName) {
    return _wrap(_ptr.getPropertyPriority(_unwrap(propertyName)));
  }

  String getPropertyShorthand(String propertyName) {
    return _wrap(_ptr.getPropertyShorthand(_unwrap(propertyName)));
  }

  String getPropertyValue(String propertyName) {
    return _wrap(_ptr.getPropertyValue(_unwrap(propertyName)));
  }

  bool isPropertyImplicit(String propertyName) {
    return _wrap(_ptr.isPropertyImplicit(_unwrap(propertyName)));
  }

  String item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }

  String removeProperty(String propertyName) {
    return _wrap(_ptr.removeProperty(_unwrap(propertyName)));
  }

  void setProperty(String propertyName, String value, [String priority = null]) {
    if (priority === null) {
      _ptr.setProperty(_unwrap(propertyName), _unwrap(value));
      return;
    } else {
      _ptr.setProperty(_unwrap(propertyName), _unwrap(value), _unwrap(priority));
      return;
    }
  }


  // TODO(jacobr): generate this list of properties using the existing script.
    /** Gets the value of "animation" */
  String get animation() =>
    getPropertyValue('${_browserPrefix}animation');

  /** Sets the value of "animation" */
  void set animation(var value) {
    setProperty('${_browserPrefix}animation', value, '');
  }

  /** Gets the value of "animation-delay" */
  String get animationDelay() =>
    getPropertyValue('${_browserPrefix}animation-delay');

  /** Sets the value of "animation-delay" */
  void set animationDelay(var value) {
    setProperty('${_browserPrefix}animation-delay', value, '');
  }

  /** Gets the value of "animation-direction" */
  String get animationDirection() =>
    getPropertyValue('${_browserPrefix}animation-direction');

  /** Sets the value of "animation-direction" */
  void set animationDirection(var value) {
    setProperty('${_browserPrefix}animation-direction', value, '');
  }

  /** Gets the value of "animation-duration" */
  String get animationDuration() =>
    getPropertyValue('${_browserPrefix}animation-duration');

  /** Sets the value of "animation-duration" */
  void set animationDuration(var value) {
    setProperty('${_browserPrefix}animation-duration', value, '');
  }

  /** Gets the value of "animation-fill-mode" */
  String get animationFillMode() =>
    getPropertyValue('${_browserPrefix}animation-fill-mode');

  /** Sets the value of "animation-fill-mode" */
  void set animationFillMode(var value) {
    setProperty('${_browserPrefix}animation-fill-mode', value, '');
  }

  /** Gets the value of "animation-iteration-count" */
  String get animationIterationCount() =>
    getPropertyValue('${_browserPrefix}animation-iteration-count');

  /** Sets the value of "animation-iteration-count" */
  void set animationIterationCount(var value) {
    setProperty('${_browserPrefix}animation-iteration-count', value, '');
  }

  /** Gets the value of "animation-name" */
  String get animationName() =>
    getPropertyValue('${_browserPrefix}animation-name');

  /** Sets the value of "animation-name" */
  void set animationName(var value) {
    setProperty('${_browserPrefix}animation-name', value, '');
  }

  /** Gets the value of "animation-play-state" */
  String get animationPlayState() =>
    getPropertyValue('${_browserPrefix}animation-play-state');

  /** Sets the value of "animation-play-state" */
  void set animationPlayState(var value) {
    setProperty('${_browserPrefix}animation-play-state', value, '');
  }

  /** Gets the value of "animation-timing-function" */
  String get animationTimingFunction() =>
    getPropertyValue('${_browserPrefix}animation-timing-function');

  /** Sets the value of "animation-timing-function" */
  void set animationTimingFunction(var value) {
    setProperty('${_browserPrefix}animation-timing-function', value, '');
  }

  /** Gets the value of "appearance" */
  String get appearance() =>
    getPropertyValue('${_browserPrefix}appearance');

  /** Sets the value of "appearance" */
  void set appearance(var value) {
    setProperty('${_browserPrefix}appearance', value, '');
  }

  /** Gets the value of "backface-visibility" */
  String get backfaceVisibility() =>
    getPropertyValue('${_browserPrefix}backface-visibility');

  /** Sets the value of "backface-visibility" */
  void set backfaceVisibility(var value) {
    setProperty('${_browserPrefix}backface-visibility', value, '');
  }

  /** Gets the value of "background" */
  String get background() =>
    getPropertyValue('background');

  /** Sets the value of "background" */
  void set background(var value) {
    setProperty('background', value, '');
  }

  /** Gets the value of "background-attachment" */
  String get backgroundAttachment() =>
    getPropertyValue('background-attachment');

  /** Sets the value of "background-attachment" */
  void set backgroundAttachment(var value) {
    setProperty('background-attachment', value, '');
  }

  /** Gets the value of "background-clip" */
  String get backgroundClip() =>
    getPropertyValue('background-clip');

  /** Sets the value of "background-clip" */
  void set backgroundClip(var value) {
    setProperty('background-clip', value, '');
  }

  /** Gets the value of "background-color" */
  String get backgroundColor() =>
    getPropertyValue('background-color');

  /** Sets the value of "background-color" */
  void set backgroundColor(var value) {
    setProperty('background-color', value, '');
  }

  /** Gets the value of "background-composite" */
  String get backgroundComposite() =>
    getPropertyValue('${_browserPrefix}background-composite');

  /** Sets the value of "background-composite" */
  void set backgroundComposite(var value) {
    setProperty('${_browserPrefix}background-composite', value, '');
  }

  /** Gets the value of "background-image" */
  String get backgroundImage() =>
    getPropertyValue('background-image');

  /** Sets the value of "background-image" */
  void set backgroundImage(var value) {
    setProperty('background-image', value, '');
  }

  /** Gets the value of "background-origin" */
  String get backgroundOrigin() =>
    getPropertyValue('background-origin');

  /** Sets the value of "background-origin" */
  void set backgroundOrigin(var value) {
    setProperty('background-origin', value, '');
  }

  /** Gets the value of "background-position" */
  String get backgroundPosition() =>
    getPropertyValue('background-position');

  /** Sets the value of "background-position" */
  void set backgroundPosition(var value) {
    setProperty('background-position', value, '');
  }

  /** Gets the value of "background-position-x" */
  String get backgroundPositionX() =>
    getPropertyValue('background-position-x');

  /** Sets the value of "background-position-x" */
  void set backgroundPositionX(var value) {
    setProperty('background-position-x', value, '');
  }

  /** Gets the value of "background-position-y" */
  String get backgroundPositionY() =>
    getPropertyValue('background-position-y');

  /** Sets the value of "background-position-y" */
  void set backgroundPositionY(var value) {
    setProperty('background-position-y', value, '');
  }

  /** Gets the value of "background-repeat" */
  String get backgroundRepeat() =>
    getPropertyValue('background-repeat');

  /** Sets the value of "background-repeat" */
  void set backgroundRepeat(var value) {
    setProperty('background-repeat', value, '');
  }

  /** Gets the value of "background-repeat-x" */
  String get backgroundRepeatX() =>
    getPropertyValue('background-repeat-x');

  /** Sets the value of "background-repeat-x" */
  void set backgroundRepeatX(var value) {
    setProperty('background-repeat-x', value, '');
  }

  /** Gets the value of "background-repeat-y" */
  String get backgroundRepeatY() =>
    getPropertyValue('background-repeat-y');

  /** Sets the value of "background-repeat-y" */
  void set backgroundRepeatY(var value) {
    setProperty('background-repeat-y', value, '');
  }

  /** Gets the value of "background-size" */
  String get backgroundSize() =>
    getPropertyValue('background-size');

  /** Sets the value of "background-size" */
  void set backgroundSize(var value) {
    setProperty('background-size', value, '');
  }

  /** Gets the value of "border" */
  String get border() =>
    getPropertyValue('border');

  /** Sets the value of "border" */
  void set border(var value) {
    setProperty('border', value, '');
  }

  /** Gets the value of "border-after" */
  String get borderAfter() =>
    getPropertyValue('${_browserPrefix}border-after');

  /** Sets the value of "border-after" */
  void set borderAfter(var value) {
    setProperty('${_browserPrefix}border-after', value, '');
  }

  /** Gets the value of "border-after-color" */
  String get borderAfterColor() =>
    getPropertyValue('${_browserPrefix}border-after-color');

  /** Sets the value of "border-after-color" */
  void set borderAfterColor(var value) {
    setProperty('${_browserPrefix}border-after-color', value, '');
  }

  /** Gets the value of "border-after-style" */
  String get borderAfterStyle() =>
    getPropertyValue('${_browserPrefix}border-after-style');

  /** Sets the value of "border-after-style" */
  void set borderAfterStyle(var value) {
    setProperty('${_browserPrefix}border-after-style', value, '');
  }

  /** Gets the value of "border-after-width" */
  String get borderAfterWidth() =>
    getPropertyValue('${_browserPrefix}border-after-width');

  /** Sets the value of "border-after-width" */
  void set borderAfterWidth(var value) {
    setProperty('${_browserPrefix}border-after-width', value, '');
  }

  /** Gets the value of "border-before" */
  String get borderBefore() =>
    getPropertyValue('${_browserPrefix}border-before');

  /** Sets the value of "border-before" */
  void set borderBefore(var value) {
    setProperty('${_browserPrefix}border-before', value, '');
  }

  /** Gets the value of "border-before-color" */
  String get borderBeforeColor() =>
    getPropertyValue('${_browserPrefix}border-before-color');

  /** Sets the value of "border-before-color" */
  void set borderBeforeColor(var value) {
    setProperty('${_browserPrefix}border-before-color', value, '');
  }

  /** Gets the value of "border-before-style" */
  String get borderBeforeStyle() =>
    getPropertyValue('${_browserPrefix}border-before-style');

  /** Sets the value of "border-before-style" */
  void set borderBeforeStyle(var value) {
    setProperty('${_browserPrefix}border-before-style', value, '');
  }

  /** Gets the value of "border-before-width" */
  String get borderBeforeWidth() =>
    getPropertyValue('${_browserPrefix}border-before-width');

  /** Sets the value of "border-before-width" */
  void set borderBeforeWidth(var value) {
    setProperty('${_browserPrefix}border-before-width', value, '');
  }

  /** Gets the value of "border-bottom" */
  String get borderBottom() =>
    getPropertyValue('border-bottom');

  /** Sets the value of "border-bottom" */
  void set borderBottom(var value) {
    setProperty('border-bottom', value, '');
  }

  /** Gets the value of "border-bottom-color" */
  String get borderBottomColor() =>
    getPropertyValue('border-bottom-color');

  /** Sets the value of "border-bottom-color" */
  void set borderBottomColor(var value) {
    setProperty('border-bottom-color', value, '');
  }

  /** Gets the value of "border-bottom-left-radius" */
  String get borderBottomLeftRadius() =>
    getPropertyValue('border-bottom-left-radius');

  /** Sets the value of "border-bottom-left-radius" */
  void set borderBottomLeftRadius(var value) {
    setProperty('border-bottom-left-radius', value, '');
  }

  /** Gets the value of "border-bottom-right-radius" */
  String get borderBottomRightRadius() =>
    getPropertyValue('border-bottom-right-radius');

  /** Sets the value of "border-bottom-right-radius" */
  void set borderBottomRightRadius(var value) {
    setProperty('border-bottom-right-radius', value, '');
  }

  /** Gets the value of "border-bottom-style" */
  String get borderBottomStyle() =>
    getPropertyValue('border-bottom-style');

  /** Sets the value of "border-bottom-style" */
  void set borderBottomStyle(var value) {
    setProperty('border-bottom-style', value, '');
  }

  /** Gets the value of "border-bottom-width" */
  String get borderBottomWidth() =>
    getPropertyValue('border-bottom-width');

  /** Sets the value of "border-bottom-width" */
  void set borderBottomWidth(var value) {
    setProperty('border-bottom-width', value, '');
  }

  /** Gets the value of "border-collapse" */
  String get borderCollapse() =>
    getPropertyValue('border-collapse');

  /** Sets the value of "border-collapse" */
  void set borderCollapse(var value) {
    setProperty('border-collapse', value, '');
  }

  /** Gets the value of "border-color" */
  String get borderColor() =>
    getPropertyValue('border-color');

  /** Sets the value of "border-color" */
  void set borderColor(var value) {
    setProperty('border-color', value, '');
  }

  /** Gets the value of "border-end" */
  String get borderEnd() =>
    getPropertyValue('${_browserPrefix}border-end');

  /** Sets the value of "border-end" */
  void set borderEnd(var value) {
    setProperty('${_browserPrefix}border-end', value, '');
  }

  /** Gets the value of "border-end-color" */
  String get borderEndColor() =>
    getPropertyValue('${_browserPrefix}border-end-color');

  /** Sets the value of "border-end-color" */
  void set borderEndColor(var value) {
    setProperty('${_browserPrefix}border-end-color', value, '');
  }

  /** Gets the value of "border-end-style" */
  String get borderEndStyle() =>
    getPropertyValue('${_browserPrefix}border-end-style');

  /** Sets the value of "border-end-style" */
  void set borderEndStyle(var value) {
    setProperty('${_browserPrefix}border-end-style', value, '');
  }

  /** Gets the value of "border-end-width" */
  String get borderEndWidth() =>
    getPropertyValue('${_browserPrefix}border-end-width');

  /** Sets the value of "border-end-width" */
  void set borderEndWidth(var value) {
    setProperty('${_browserPrefix}border-end-width', value, '');
  }

  /** Gets the value of "border-fit" */
  String get borderFit() =>
    getPropertyValue('${_browserPrefix}border-fit');

  /** Sets the value of "border-fit" */
  void set borderFit(var value) {
    setProperty('${_browserPrefix}border-fit', value, '');
  }

  /** Gets the value of "border-horizontal-spacing" */
  String get borderHorizontalSpacing() =>
    getPropertyValue('${_browserPrefix}border-horizontal-spacing');

  /** Sets the value of "border-horizontal-spacing" */
  void set borderHorizontalSpacing(var value) {
    setProperty('${_browserPrefix}border-horizontal-spacing', value, '');
  }

  /** Gets the value of "border-image" */
  String get borderImage() =>
    getPropertyValue('border-image');

  /** Sets the value of "border-image" */
  void set borderImage(var value) {
    setProperty('border-image', value, '');
  }

  /** Gets the value of "border-image-outset" */
  String get borderImageOutset() =>
    getPropertyValue('border-image-outset');

  /** Sets the value of "border-image-outset" */
  void set borderImageOutset(var value) {
    setProperty('border-image-outset', value, '');
  }

  /** Gets the value of "border-image-repeat" */
  String get borderImageRepeat() =>
    getPropertyValue('border-image-repeat');

  /** Sets the value of "border-image-repeat" */
  void set borderImageRepeat(var value) {
    setProperty('border-image-repeat', value, '');
  }

  /** Gets the value of "border-image-slice" */
  String get borderImageSlice() =>
    getPropertyValue('border-image-slice');

  /** Sets the value of "border-image-slice" */
  void set borderImageSlice(var value) {
    setProperty('border-image-slice', value, '');
  }

  /** Gets the value of "border-image-source" */
  String get borderImageSource() =>
    getPropertyValue('border-image-source');

  /** Sets the value of "border-image-source" */
  void set borderImageSource(var value) {
    setProperty('border-image-source', value, '');
  }

  /** Gets the value of "border-image-width" */
  String get borderImageWidth() =>
    getPropertyValue('border-image-width');

  /** Sets the value of "border-image-width" */
  void set borderImageWidth(var value) {
    setProperty('border-image-width', value, '');
  }

  /** Gets the value of "border-left" */
  String get borderLeft() =>
    getPropertyValue('border-left');

  /** Sets the value of "border-left" */
  void set borderLeft(var value) {
    setProperty('border-left', value, '');
  }

  /** Gets the value of "border-left-color" */
  String get borderLeftColor() =>
    getPropertyValue('border-left-color');

  /** Sets the value of "border-left-color" */
  void set borderLeftColor(var value) {
    setProperty('border-left-color', value, '');
  }

  /** Gets the value of "border-left-style" */
  String get borderLeftStyle() =>
    getPropertyValue('border-left-style');

  /** Sets the value of "border-left-style" */
  void set borderLeftStyle(var value) {
    setProperty('border-left-style', value, '');
  }

  /** Gets the value of "border-left-width" */
  String get borderLeftWidth() =>
    getPropertyValue('border-left-width');

  /** Sets the value of "border-left-width" */
  void set borderLeftWidth(var value) {
    setProperty('border-left-width', value, '');
  }

  /** Gets the value of "border-radius" */
  String get borderRadius() =>
    getPropertyValue('border-radius');

  /** Sets the value of "border-radius" */
  void set borderRadius(var value) {
    setProperty('border-radius', value, '');
  }

  /** Gets the value of "border-right" */
  String get borderRight() =>
    getPropertyValue('border-right');

  /** Sets the value of "border-right" */
  void set borderRight(var value) {
    setProperty('border-right', value, '');
  }

  /** Gets the value of "border-right-color" */
  String get borderRightColor() =>
    getPropertyValue('border-right-color');

  /** Sets the value of "border-right-color" */
  void set borderRightColor(var value) {
    setProperty('border-right-color', value, '');
  }

  /** Gets the value of "border-right-style" */
  String get borderRightStyle() =>
    getPropertyValue('border-right-style');

  /** Sets the value of "border-right-style" */
  void set borderRightStyle(var value) {
    setProperty('border-right-style', value, '');
  }

  /** Gets the value of "border-right-width" */
  String get borderRightWidth() =>
    getPropertyValue('border-right-width');

  /** Sets the value of "border-right-width" */
  void set borderRightWidth(var value) {
    setProperty('border-right-width', value, '');
  }

  /** Gets the value of "border-spacing" */
  String get borderSpacing() =>
    getPropertyValue('border-spacing');

  /** Sets the value of "border-spacing" */
  void set borderSpacing(var value) {
    setProperty('border-spacing', value, '');
  }

  /** Gets the value of "border-start" */
  String get borderStart() =>
    getPropertyValue('${_browserPrefix}border-start');

  /** Sets the value of "border-start" */
  void set borderStart(var value) {
    setProperty('${_browserPrefix}border-start', value, '');
  }

  /** Gets the value of "border-start-color" */
  String get borderStartColor() =>
    getPropertyValue('${_browserPrefix}border-start-color');

  /** Sets the value of "border-start-color" */
  void set borderStartColor(var value) {
    setProperty('${_browserPrefix}border-start-color', value, '');
  }

  /** Gets the value of "border-start-style" */
  String get borderStartStyle() =>
    getPropertyValue('${_browserPrefix}border-start-style');

  /** Sets the value of "border-start-style" */
  void set borderStartStyle(var value) {
    setProperty('${_browserPrefix}border-start-style', value, '');
  }

  /** Gets the value of "border-start-width" */
  String get borderStartWidth() =>
    getPropertyValue('${_browserPrefix}border-start-width');

  /** Sets the value of "border-start-width" */
  void set borderStartWidth(var value) {
    setProperty('${_browserPrefix}border-start-width', value, '');
  }

  /** Gets the value of "border-style" */
  String get borderStyle() =>
    getPropertyValue('border-style');

  /** Sets the value of "border-style" */
  void set borderStyle(var value) {
    setProperty('border-style', value, '');
  }

  /** Gets the value of "border-top" */
  String get borderTop() =>
    getPropertyValue('border-top');

  /** Sets the value of "border-top" */
  void set borderTop(var value) {
    setProperty('border-top', value, '');
  }

  /** Gets the value of "border-top-color" */
  String get borderTopColor() =>
    getPropertyValue('border-top-color');

  /** Sets the value of "border-top-color" */
  void set borderTopColor(var value) {
    setProperty('border-top-color', value, '');
  }

  /** Gets the value of "border-top-left-radius" */
  String get borderTopLeftRadius() =>
    getPropertyValue('border-top-left-radius');

  /** Sets the value of "border-top-left-radius" */
  void set borderTopLeftRadius(var value) {
    setProperty('border-top-left-radius', value, '');
  }

  /** Gets the value of "border-top-right-radius" */
  String get borderTopRightRadius() =>
    getPropertyValue('border-top-right-radius');

  /** Sets the value of "border-top-right-radius" */
  void set borderTopRightRadius(var value) {
    setProperty('border-top-right-radius', value, '');
  }

  /** Gets the value of "border-top-style" */
  String get borderTopStyle() =>
    getPropertyValue('border-top-style');

  /** Sets the value of "border-top-style" */
  void set borderTopStyle(var value) {
    setProperty('border-top-style', value, '');
  }

  /** Gets the value of "border-top-width" */
  String get borderTopWidth() =>
    getPropertyValue('border-top-width');

  /** Sets the value of "border-top-width" */
  void set borderTopWidth(var value) {
    setProperty('border-top-width', value, '');
  }

  /** Gets the value of "border-vertical-spacing" */
  String get borderVerticalSpacing() =>
    getPropertyValue('${_browserPrefix}border-vertical-spacing');

  /** Sets the value of "border-vertical-spacing" */
  void set borderVerticalSpacing(var value) {
    setProperty('${_browserPrefix}border-vertical-spacing', value, '');
  }

  /** Gets the value of "border-width" */
  String get borderWidth() =>
    getPropertyValue('border-width');

  /** Sets the value of "border-width" */
  void set borderWidth(var value) {
    setProperty('border-width', value, '');
  }

  /** Gets the value of "bottom" */
  String get bottom() =>
    getPropertyValue('bottom');

  /** Sets the value of "bottom" */
  void set bottom(var value) {
    setProperty('bottom', value, '');
  }

  /** Gets the value of "box-align" */
  String get boxAlign() =>
    getPropertyValue('${_browserPrefix}box-align');

  /** Sets the value of "box-align" */
  void set boxAlign(var value) {
    setProperty('${_browserPrefix}box-align', value, '');
  }

  /** Gets the value of "box-direction" */
  String get boxDirection() =>
    getPropertyValue('${_browserPrefix}box-direction');

  /** Sets the value of "box-direction" */
  void set boxDirection(var value) {
    setProperty('${_browserPrefix}box-direction', value, '');
  }

  /** Gets the value of "box-flex" */
  String get boxFlex() =>
    getPropertyValue('${_browserPrefix}box-flex');

  /** Sets the value of "box-flex" */
  void set boxFlex(var value) {
    setProperty('${_browserPrefix}box-flex', value, '');
  }

  /** Gets the value of "box-flex-group" */
  String get boxFlexGroup() =>
    getPropertyValue('${_browserPrefix}box-flex-group');

  /** Sets the value of "box-flex-group" */
  void set boxFlexGroup(var value) {
    setProperty('${_browserPrefix}box-flex-group', value, '');
  }

  /** Gets the value of "box-lines" */
  String get boxLines() =>
    getPropertyValue('${_browserPrefix}box-lines');

  /** Sets the value of "box-lines" */
  void set boxLines(var value) {
    setProperty('${_browserPrefix}box-lines', value, '');
  }

  /** Gets the value of "box-ordinal-group" */
  String get boxOrdinalGroup() =>
    getPropertyValue('${_browserPrefix}box-ordinal-group');

  /** Sets the value of "box-ordinal-group" */
  void set boxOrdinalGroup(var value) {
    setProperty('${_browserPrefix}box-ordinal-group', value, '');
  }

  /** Gets the value of "box-orient" */
  String get boxOrient() =>
    getPropertyValue('${_browserPrefix}box-orient');

  /** Sets the value of "box-orient" */
  void set boxOrient(var value) {
    setProperty('${_browserPrefix}box-orient', value, '');
  }

  /** Gets the value of "box-pack" */
  String get boxPack() =>
    getPropertyValue('${_browserPrefix}box-pack');

  /** Sets the value of "box-pack" */
  void set boxPack(var value) {
    setProperty('${_browserPrefix}box-pack', value, '');
  }

  /** Gets the value of "box-reflect" */
  String get boxReflect() =>
    getPropertyValue('${_browserPrefix}box-reflect');

  /** Sets the value of "box-reflect" */
  void set boxReflect(var value) {
    setProperty('${_browserPrefix}box-reflect', value, '');
  }

  /** Gets the value of "box-shadow" */
  String get boxShadow() =>
    getPropertyValue('box-shadow');

  /** Sets the value of "box-shadow" */
  void set boxShadow(var value) {
    setProperty('box-shadow', value, '');
  }

  /** Gets the value of "box-sizing" */
  String get boxSizing() =>
    getPropertyValue('box-sizing');

  /** Sets the value of "box-sizing" */
  void set boxSizing(var value) {
    setProperty('box-sizing', value, '');
  }

  /** Gets the value of "caption-side" */
  String get captionSide() =>
    getPropertyValue('caption-side');

  /** Sets the value of "caption-side" */
  void set captionSide(var value) {
    setProperty('caption-side', value, '');
  }

  /** Gets the value of "clear" */
  String get clear() =>
    getPropertyValue('clear');

  /** Sets the value of "clear" */
  void set clear(var value) {
    setProperty('clear', value, '');
  }

  /** Gets the value of "clip" */
  String get clip() =>
    getPropertyValue('clip');

  /** Sets the value of "clip" */
  void set clip(var value) {
    setProperty('clip', value, '');
  }

  /** Gets the value of "color" */
  String get color() =>
    getPropertyValue('color');

  /** Sets the value of "color" */
  void set color(var value) {
    setProperty('color', value, '');
  }

  /** Gets the value of "color-correction" */
  String get colorCorrection() =>
    getPropertyValue('${_browserPrefix}color-correction');

  /** Sets the value of "color-correction" */
  void set colorCorrection(var value) {
    setProperty('${_browserPrefix}color-correction', value, '');
  }

  /** Gets the value of "column-break-after" */
  String get columnBreakAfter() =>
    getPropertyValue('${_browserPrefix}column-break-after');

  /** Sets the value of "column-break-after" */
  void set columnBreakAfter(var value) {
    setProperty('${_browserPrefix}column-break-after', value, '');
  }

  /** Gets the value of "column-break-before" */
  String get columnBreakBefore() =>
    getPropertyValue('${_browserPrefix}column-break-before');

  /** Sets the value of "column-break-before" */
  void set columnBreakBefore(var value) {
    setProperty('${_browserPrefix}column-break-before', value, '');
  }

  /** Gets the value of "column-break-inside" */
  String get columnBreakInside() =>
    getPropertyValue('${_browserPrefix}column-break-inside');

  /** Sets the value of "column-break-inside" */
  void set columnBreakInside(var value) {
    setProperty('${_browserPrefix}column-break-inside', value, '');
  }

  /** Gets the value of "column-count" */
  String get columnCount() =>
    getPropertyValue('${_browserPrefix}column-count');

  /** Sets the value of "column-count" */
  void set columnCount(var value) {
    setProperty('${_browserPrefix}column-count', value, '');
  }

  /** Gets the value of "column-gap" */
  String get columnGap() =>
    getPropertyValue('${_browserPrefix}column-gap');

  /** Sets the value of "column-gap" */
  void set columnGap(var value) {
    setProperty('${_browserPrefix}column-gap', value, '');
  }

  /** Gets the value of "column-rule" */
  String get columnRule() =>
    getPropertyValue('${_browserPrefix}column-rule');

  /** Sets the value of "column-rule" */
  void set columnRule(var value) {
    setProperty('${_browserPrefix}column-rule', value, '');
  }

  /** Gets the value of "column-rule-color" */
  String get columnRuleColor() =>
    getPropertyValue('${_browserPrefix}column-rule-color');

  /** Sets the value of "column-rule-color" */
  void set columnRuleColor(var value) {
    setProperty('${_browserPrefix}column-rule-color', value, '');
  }

  /** Gets the value of "column-rule-style" */
  String get columnRuleStyle() =>
    getPropertyValue('${_browserPrefix}column-rule-style');

  /** Sets the value of "column-rule-style" */
  void set columnRuleStyle(var value) {
    setProperty('${_browserPrefix}column-rule-style', value, '');
  }

  /** Gets the value of "column-rule-width" */
  String get columnRuleWidth() =>
    getPropertyValue('${_browserPrefix}column-rule-width');

  /** Sets the value of "column-rule-width" */
  void set columnRuleWidth(var value) {
    setProperty('${_browserPrefix}column-rule-width', value, '');
  }

  /** Gets the value of "column-span" */
  String get columnSpan() =>
    getPropertyValue('${_browserPrefix}column-span');

  /** Sets the value of "column-span" */
  void set columnSpan(var value) {
    setProperty('${_browserPrefix}column-span', value, '');
  }

  /** Gets the value of "column-width" */
  String get columnWidth() =>
    getPropertyValue('${_browserPrefix}column-width');

  /** Sets the value of "column-width" */
  void set columnWidth(var value) {
    setProperty('${_browserPrefix}column-width', value, '');
  }

  /** Gets the value of "columns" */
  String get columns() =>
    getPropertyValue('${_browserPrefix}columns');

  /** Sets the value of "columns" */
  void set columns(var value) {
    setProperty('${_browserPrefix}columns', value, '');
  }

  /** Gets the value of "content" */
  String get content() =>
    getPropertyValue('content');

  /** Sets the value of "content" */
  void set content(var value) {
    setProperty('content', value, '');
  }

  /** Gets the value of "counter-increment" */
  String get counterIncrement() =>
    getPropertyValue('counter-increment');

  /** Sets the value of "counter-increment" */
  void set counterIncrement(var value) {
    setProperty('counter-increment', value, '');
  }

  /** Gets the value of "counter-reset" */
  String get counterReset() =>
    getPropertyValue('counter-reset');

  /** Sets the value of "counter-reset" */
  void set counterReset(var value) {
    setProperty('counter-reset', value, '');
  }

  /** Gets the value of "cursor" */
  String get cursor() =>
    getPropertyValue('cursor');

  /** Sets the value of "cursor" */
  void set cursor(var value) {
    setProperty('cursor', value, '');
  }

  /** Gets the value of "direction" */
  String get direction() =>
    getPropertyValue('direction');

  /** Sets the value of "direction" */
  void set direction(var value) {
    setProperty('direction', value, '');
  }

  /** Gets the value of "display" */
  String get display() =>
    getPropertyValue('display');

  /** Sets the value of "display" */
  void set display(var value) {
    setProperty('display', value, '');
  }

  /** Gets the value of "empty-cells" */
  String get emptyCells() =>
    getPropertyValue('empty-cells');

  /** Sets the value of "empty-cells" */
  void set emptyCells(var value) {
    setProperty('empty-cells', value, '');
  }

  /** Gets the value of "filter" */
  String get filter() =>
    getPropertyValue('${_browserPrefix}filter');

  /** Sets the value of "filter" */
  void set filter(var value) {
    setProperty('${_browserPrefix}filter', value, '');
  }

  /** Gets the value of "flex-align" */
  String get flexAlign() =>
    getPropertyValue('${_browserPrefix}flex-align');

  /** Sets the value of "flex-align" */
  void set flexAlign(var value) {
    setProperty('${_browserPrefix}flex-align', value, '');
  }

  /** Gets the value of "flex-flow" */
  String get flexFlow() =>
    getPropertyValue('${_browserPrefix}flex-flow');

  /** Sets the value of "flex-flow" */
  void set flexFlow(var value) {
    setProperty('${_browserPrefix}flex-flow', value, '');
  }

  /** Gets the value of "flex-order" */
  String get flexOrder() =>
    getPropertyValue('${_browserPrefix}flex-order');

  /** Sets the value of "flex-order" */
  void set flexOrder(var value) {
    setProperty('${_browserPrefix}flex-order', value, '');
  }

  /** Gets the value of "flex-pack" */
  String get flexPack() =>
    getPropertyValue('${_browserPrefix}flex-pack');

  /** Sets the value of "flex-pack" */
  void set flexPack(var value) {
    setProperty('${_browserPrefix}flex-pack', value, '');
  }

  /** Gets the value of "float" */
  String get float() =>
    getPropertyValue('float');

  /** Sets the value of "float" */
  void set float(var value) {
    setProperty('float', value, '');
  }

  /** Gets the value of "flow-from" */
  String get flowFrom() =>
    getPropertyValue('${_browserPrefix}flow-from');

  /** Sets the value of "flow-from" */
  void set flowFrom(var value) {
    setProperty('${_browserPrefix}flow-from', value, '');
  }

  /** Gets the value of "flow-into" */
  String get flowInto() =>
    getPropertyValue('${_browserPrefix}flow-into');

  /** Sets the value of "flow-into" */
  void set flowInto(var value) {
    setProperty('${_browserPrefix}flow-into', value, '');
  }

  /** Gets the value of "font" */
  String get font() =>
    getPropertyValue('font');

  /** Sets the value of "font" */
  void set font(var value) {
    setProperty('font', value, '');
  }

  /** Gets the value of "font-family" */
  String get fontFamily() =>
    getPropertyValue('font-family');

  /** Sets the value of "font-family" */
  void set fontFamily(var value) {
    setProperty('font-family', value, '');
  }

  /** Gets the value of "font-feature-settings" */
  String get fontFeatureSettings() =>
    getPropertyValue('${_browserPrefix}font-feature-settings');

  /** Sets the value of "font-feature-settings" */
  void set fontFeatureSettings(var value) {
    setProperty('${_browserPrefix}font-feature-settings', value, '');
  }

  /** Gets the value of "font-size" */
  String get fontSize() =>
    getPropertyValue('font-size');

  /** Sets the value of "font-size" */
  void set fontSize(var value) {
    setProperty('font-size', value, '');
  }

  /** Gets the value of "font-size-delta" */
  String get fontSizeDelta() =>
    getPropertyValue('${_browserPrefix}font-size-delta');

  /** Sets the value of "font-size-delta" */
  void set fontSizeDelta(var value) {
    setProperty('${_browserPrefix}font-size-delta', value, '');
  }

  /** Gets the value of "font-smoothing" */
  String get fontSmoothing() =>
    getPropertyValue('${_browserPrefix}font-smoothing');

  /** Sets the value of "font-smoothing" */
  void set fontSmoothing(var value) {
    setProperty('${_browserPrefix}font-smoothing', value, '');
  }

  /** Gets the value of "font-stretch" */
  String get fontStretch() =>
    getPropertyValue('font-stretch');

  /** Sets the value of "font-stretch" */
  void set fontStretch(var value) {
    setProperty('font-stretch', value, '');
  }

  /** Gets the value of "font-style" */
  String get fontStyle() =>
    getPropertyValue('font-style');

  /** Sets the value of "font-style" */
  void set fontStyle(var value) {
    setProperty('font-style', value, '');
  }

  /** Gets the value of "font-variant" */
  String get fontVariant() =>
    getPropertyValue('font-variant');

  /** Sets the value of "font-variant" */
  void set fontVariant(var value) {
    setProperty('font-variant', value, '');
  }

  /** Gets the value of "font-weight" */
  String get fontWeight() =>
    getPropertyValue('font-weight');

  /** Sets the value of "font-weight" */
  void set fontWeight(var value) {
    setProperty('font-weight', value, '');
  }

  /** Gets the value of "height" */
  String get height() =>
    getPropertyValue('height');

  /** Sets the value of "height" */
  void set height(var value) {
    setProperty('height', value, '');
  }

  /** Gets the value of "highlight" */
  String get highlight() =>
    getPropertyValue('${_browserPrefix}highlight');

  /** Sets the value of "highlight" */
  void set highlight(var value) {
    setProperty('${_browserPrefix}highlight', value, '');
  }

  /** Gets the value of "hyphenate-character" */
  String get hyphenateCharacter() =>
    getPropertyValue('${_browserPrefix}hyphenate-character');

  /** Sets the value of "hyphenate-character" */
  void set hyphenateCharacter(var value) {
    setProperty('${_browserPrefix}hyphenate-character', value, '');
  }

  /** Gets the value of "hyphenate-limit-after" */
  String get hyphenateLimitAfter() =>
    getPropertyValue('${_browserPrefix}hyphenate-limit-after');

  /** Sets the value of "hyphenate-limit-after" */
  void set hyphenateLimitAfter(var value) {
    setProperty('${_browserPrefix}hyphenate-limit-after', value, '');
  }

  /** Gets the value of "hyphenate-limit-before" */
  String get hyphenateLimitBefore() =>
    getPropertyValue('${_browserPrefix}hyphenate-limit-before');

  /** Sets the value of "hyphenate-limit-before" */
  void set hyphenateLimitBefore(var value) {
    setProperty('${_browserPrefix}hyphenate-limit-before', value, '');
  }

  /** Gets the value of "hyphenate-limit-lines" */
  String get hyphenateLimitLines() =>
    getPropertyValue('${_browserPrefix}hyphenate-limit-lines');

  /** Sets the value of "hyphenate-limit-lines" */
  void set hyphenateLimitLines(var value) {
    setProperty('${_browserPrefix}hyphenate-limit-lines', value, '');
  }

  /** Gets the value of "hyphens" */
  String get hyphens() =>
    getPropertyValue('${_browserPrefix}hyphens');

  /** Sets the value of "hyphens" */
  void set hyphens(var value) {
    setProperty('${_browserPrefix}hyphens', value, '');
  }

  /** Gets the value of "image-rendering" */
  String get imageRendering() =>
    getPropertyValue('image-rendering');

  /** Sets the value of "image-rendering" */
  void set imageRendering(var value) {
    setProperty('image-rendering', value, '');
  }

  /** Gets the value of "left" */
  String get left() =>
    getPropertyValue('left');

  /** Sets the value of "left" */
  void set left(var value) {
    setProperty('left', value, '');
  }

  /** Gets the value of "letter-spacing" */
  String get letterSpacing() =>
    getPropertyValue('letter-spacing');

  /** Sets the value of "letter-spacing" */
  void set letterSpacing(var value) {
    setProperty('letter-spacing', value, '');
  }

  /** Gets the value of "line-box-contain" */
  String get lineBoxContain() =>
    getPropertyValue('${_browserPrefix}line-box-contain');

  /** Sets the value of "line-box-contain" */
  void set lineBoxContain(var value) {
    setProperty('${_browserPrefix}line-box-contain', value, '');
  }

  /** Gets the value of "line-break" */
  String get lineBreak() =>
    getPropertyValue('${_browserPrefix}line-break');

  /** Sets the value of "line-break" */
  void set lineBreak(var value) {
    setProperty('${_browserPrefix}line-break', value, '');
  }

  /** Gets the value of "line-clamp" */
  String get lineClamp() =>
    getPropertyValue('${_browserPrefix}line-clamp');

  /** Sets the value of "line-clamp" */
  void set lineClamp(var value) {
    setProperty('${_browserPrefix}line-clamp', value, '');
  }

  /** Gets the value of "line-height" */
  String get lineHeight() =>
    getPropertyValue('line-height');

  /** Sets the value of "line-height" */
  void set lineHeight(var value) {
    setProperty('line-height', value, '');
  }

  /** Gets the value of "list-style" */
  String get listStyle() =>
    getPropertyValue('list-style');

  /** Sets the value of "list-style" */
  void set listStyle(var value) {
    setProperty('list-style', value, '');
  }

  /** Gets the value of "list-style-image" */
  String get listStyleImage() =>
    getPropertyValue('list-style-image');

  /** Sets the value of "list-style-image" */
  void set listStyleImage(var value) {
    setProperty('list-style-image', value, '');
  }

  /** Gets the value of "list-style-position" */
  String get listStylePosition() =>
    getPropertyValue('list-style-position');

  /** Sets the value of "list-style-position" */
  void set listStylePosition(var value) {
    setProperty('list-style-position', value, '');
  }

  /** Gets the value of "list-style-type" */
  String get listStyleType() =>
    getPropertyValue('list-style-type');

  /** Sets the value of "list-style-type" */
  void set listStyleType(var value) {
    setProperty('list-style-type', value, '');
  }

  /** Gets the value of "locale" */
  String get locale() =>
    getPropertyValue('${_browserPrefix}locale');

  /** Sets the value of "locale" */
  void set locale(var value) {
    setProperty('${_browserPrefix}locale', value, '');
  }

  /** Gets the value of "logical-height" */
  String get logicalHeight() =>
    getPropertyValue('${_browserPrefix}logical-height');

  /** Sets the value of "logical-height" */
  void set logicalHeight(var value) {
    setProperty('${_browserPrefix}logical-height', value, '');
  }

  /** Gets the value of "logical-width" */
  String get logicalWidth() =>
    getPropertyValue('${_browserPrefix}logical-width');

  /** Sets the value of "logical-width" */
  void set logicalWidth(var value) {
    setProperty('${_browserPrefix}logical-width', value, '');
  }

  /** Gets the value of "margin" */
  String get margin() =>
    getPropertyValue('margin');

  /** Sets the value of "margin" */
  void set margin(var value) {
    setProperty('margin', value, '');
  }

  /** Gets the value of "margin-after" */
  String get marginAfter() =>
    getPropertyValue('${_browserPrefix}margin-after');

  /** Sets the value of "margin-after" */
  void set marginAfter(var value) {
    setProperty('${_browserPrefix}margin-after', value, '');
  }

  /** Gets the value of "margin-after-collapse" */
  String get marginAfterCollapse() =>
    getPropertyValue('${_browserPrefix}margin-after-collapse');

  /** Sets the value of "margin-after-collapse" */
  void set marginAfterCollapse(var value) {
    setProperty('${_browserPrefix}margin-after-collapse', value, '');
  }

  /** Gets the value of "margin-before" */
  String get marginBefore() =>
    getPropertyValue('${_browserPrefix}margin-before');

  /** Sets the value of "margin-before" */
  void set marginBefore(var value) {
    setProperty('${_browserPrefix}margin-before', value, '');
  }

  /** Gets the value of "margin-before-collapse" */
  String get marginBeforeCollapse() =>
    getPropertyValue('${_browserPrefix}margin-before-collapse');

  /** Sets the value of "margin-before-collapse" */
  void set marginBeforeCollapse(var value) {
    setProperty('${_browserPrefix}margin-before-collapse', value, '');
  }

  /** Gets the value of "margin-bottom" */
  String get marginBottom() =>
    getPropertyValue('margin-bottom');

  /** Sets the value of "margin-bottom" */
  void set marginBottom(var value) {
    setProperty('margin-bottom', value, '');
  }

  /** Gets the value of "margin-bottom-collapse" */
  String get marginBottomCollapse() =>
    getPropertyValue('${_browserPrefix}margin-bottom-collapse');

  /** Sets the value of "margin-bottom-collapse" */
  void set marginBottomCollapse(var value) {
    setProperty('${_browserPrefix}margin-bottom-collapse', value, '');
  }

  /** Gets the value of "margin-collapse" */
  String get marginCollapse() =>
    getPropertyValue('${_browserPrefix}margin-collapse');

  /** Sets the value of "margin-collapse" */
  void set marginCollapse(var value) {
    setProperty('${_browserPrefix}margin-collapse', value, '');
  }

  /** Gets the value of "margin-end" */
  String get marginEnd() =>
    getPropertyValue('${_browserPrefix}margin-end');

  /** Sets the value of "margin-end" */
  void set marginEnd(var value) {
    setProperty('${_browserPrefix}margin-end', value, '');
  }

  /** Gets the value of "margin-left" */
  String get marginLeft() =>
    getPropertyValue('margin-left');

  /** Sets the value of "margin-left" */
  void set marginLeft(var value) {
    setProperty('margin-left', value, '');
  }

  /** Gets the value of "margin-right" */
  String get marginRight() =>
    getPropertyValue('margin-right');

  /** Sets the value of "margin-right" */
  void set marginRight(var value) {
    setProperty('margin-right', value, '');
  }

  /** Gets the value of "margin-start" */
  String get marginStart() =>
    getPropertyValue('${_browserPrefix}margin-start');

  /** Sets the value of "margin-start" */
  void set marginStart(var value) {
    setProperty('${_browserPrefix}margin-start', value, '');
  }

  /** Gets the value of "margin-top" */
  String get marginTop() =>
    getPropertyValue('margin-top');

  /** Sets the value of "margin-top" */
  void set marginTop(var value) {
    setProperty('margin-top', value, '');
  }

  /** Gets the value of "margin-top-collapse" */
  String get marginTopCollapse() =>
    getPropertyValue('${_browserPrefix}margin-top-collapse');

  /** Sets the value of "margin-top-collapse" */
  void set marginTopCollapse(var value) {
    setProperty('${_browserPrefix}margin-top-collapse', value, '');
  }

  /** Gets the value of "marquee" */
  String get marquee() =>
    getPropertyValue('${_browserPrefix}marquee');

  /** Sets the value of "marquee" */
  void set marquee(var value) {
    setProperty('${_browserPrefix}marquee', value, '');
  }

  /** Gets the value of "marquee-direction" */
  String get marqueeDirection() =>
    getPropertyValue('${_browserPrefix}marquee-direction');

  /** Sets the value of "marquee-direction" */
  void set marqueeDirection(var value) {
    setProperty('${_browserPrefix}marquee-direction', value, '');
  }

  /** Gets the value of "marquee-increment" */
  String get marqueeIncrement() =>
    getPropertyValue('${_browserPrefix}marquee-increment');

  /** Sets the value of "marquee-increment" */
  void set marqueeIncrement(var value) {
    setProperty('${_browserPrefix}marquee-increment', value, '');
  }

  /** Gets the value of "marquee-repetition" */
  String get marqueeRepetition() =>
    getPropertyValue('${_browserPrefix}marquee-repetition');

  /** Sets the value of "marquee-repetition" */
  void set marqueeRepetition(var value) {
    setProperty('${_browserPrefix}marquee-repetition', value, '');
  }

  /** Gets the value of "marquee-speed" */
  String get marqueeSpeed() =>
    getPropertyValue('${_browserPrefix}marquee-speed');

  /** Sets the value of "marquee-speed" */
  void set marqueeSpeed(var value) {
    setProperty('${_browserPrefix}marquee-speed', value, '');
  }

  /** Gets the value of "marquee-style" */
  String get marqueeStyle() =>
    getPropertyValue('${_browserPrefix}marquee-style');

  /** Sets the value of "marquee-style" */
  void set marqueeStyle(var value) {
    setProperty('${_browserPrefix}marquee-style', value, '');
  }

  /** Gets the value of "mask" */
  String get mask() =>
    getPropertyValue('${_browserPrefix}mask');

  /** Sets the value of "mask" */
  void set mask(var value) {
    setProperty('${_browserPrefix}mask', value, '');
  }

  /** Gets the value of "mask-attachment" */
  String get maskAttachment() =>
    getPropertyValue('${_browserPrefix}mask-attachment');

  /** Sets the value of "mask-attachment" */
  void set maskAttachment(var value) {
    setProperty('${_browserPrefix}mask-attachment', value, '');
  }

  /** Gets the value of "mask-box-image" */
  String get maskBoxImage() =>
    getPropertyValue('${_browserPrefix}mask-box-image');

  /** Sets the value of "mask-box-image" */
  void set maskBoxImage(var value) {
    setProperty('${_browserPrefix}mask-box-image', value, '');
  }

  /** Gets the value of "mask-box-image-outset" */
  String get maskBoxImageOutset() =>
    getPropertyValue('${_browserPrefix}mask-box-image-outset');

  /** Sets the value of "mask-box-image-outset" */
  void set maskBoxImageOutset(var value) {
    setProperty('${_browserPrefix}mask-box-image-outset', value, '');
  }

  /** Gets the value of "mask-box-image-repeat" */
  String get maskBoxImageRepeat() =>
    getPropertyValue('${_browserPrefix}mask-box-image-repeat');

  /** Sets the value of "mask-box-image-repeat" */
  void set maskBoxImageRepeat(var value) {
    setProperty('${_browserPrefix}mask-box-image-repeat', value, '');
  }

  /** Gets the value of "mask-box-image-slice" */
  String get maskBoxImageSlice() =>
    getPropertyValue('${_browserPrefix}mask-box-image-slice');

  /** Sets the value of "mask-box-image-slice" */
  void set maskBoxImageSlice(var value) {
    setProperty('${_browserPrefix}mask-box-image-slice', value, '');
  }

  /** Gets the value of "mask-box-image-source" */
  String get maskBoxImageSource() =>
    getPropertyValue('${_browserPrefix}mask-box-image-source');

  /** Sets the value of "mask-box-image-source" */
  void set maskBoxImageSource(var value) {
    setProperty('${_browserPrefix}mask-box-image-source', value, '');
  }

  /** Gets the value of "mask-box-image-width" */
  String get maskBoxImageWidth() =>
    getPropertyValue('${_browserPrefix}mask-box-image-width');

  /** Sets the value of "mask-box-image-width" */
  void set maskBoxImageWidth(var value) {
    setProperty('${_browserPrefix}mask-box-image-width', value, '');
  }

  /** Gets the value of "mask-clip" */
  String get maskClip() =>
    getPropertyValue('${_browserPrefix}mask-clip');

  /** Sets the value of "mask-clip" */
  void set maskClip(var value) {
    setProperty('${_browserPrefix}mask-clip', value, '');
  }

  /** Gets the value of "mask-composite" */
  String get maskComposite() =>
    getPropertyValue('${_browserPrefix}mask-composite');

  /** Sets the value of "mask-composite" */
  void set maskComposite(var value) {
    setProperty('${_browserPrefix}mask-composite', value, '');
  }

  /** Gets the value of "mask-image" */
  String get maskImage() =>
    getPropertyValue('${_browserPrefix}mask-image');

  /** Sets the value of "mask-image" */
  void set maskImage(var value) {
    setProperty('${_browserPrefix}mask-image', value, '');
  }

  /** Gets the value of "mask-origin" */
  String get maskOrigin() =>
    getPropertyValue('${_browserPrefix}mask-origin');

  /** Sets the value of "mask-origin" */
  void set maskOrigin(var value) {
    setProperty('${_browserPrefix}mask-origin', value, '');
  }

  /** Gets the value of "mask-position" */
  String get maskPosition() =>
    getPropertyValue('${_browserPrefix}mask-position');

  /** Sets the value of "mask-position" */
  void set maskPosition(var value) {
    setProperty('${_browserPrefix}mask-position', value, '');
  }

  /** Gets the value of "mask-position-x" */
  String get maskPositionX() =>
    getPropertyValue('${_browserPrefix}mask-position-x');

  /** Sets the value of "mask-position-x" */
  void set maskPositionX(var value) {
    setProperty('${_browserPrefix}mask-position-x', value, '');
  }

  /** Gets the value of "mask-position-y" */
  String get maskPositionY() =>
    getPropertyValue('${_browserPrefix}mask-position-y');

  /** Sets the value of "mask-position-y" */
  void set maskPositionY(var value) {
    setProperty('${_browserPrefix}mask-position-y', value, '');
  }

  /** Gets the value of "mask-repeat" */
  String get maskRepeat() =>
    getPropertyValue('${_browserPrefix}mask-repeat');

  /** Sets the value of "mask-repeat" */
  void set maskRepeat(var value) {
    setProperty('${_browserPrefix}mask-repeat', value, '');
  }

  /** Gets the value of "mask-repeat-x" */
  String get maskRepeatX() =>
    getPropertyValue('${_browserPrefix}mask-repeat-x');

  /** Sets the value of "mask-repeat-x" */
  void set maskRepeatX(var value) {
    setProperty('${_browserPrefix}mask-repeat-x', value, '');
  }

  /** Gets the value of "mask-repeat-y" */
  String get maskRepeatY() =>
    getPropertyValue('${_browserPrefix}mask-repeat-y');

  /** Sets the value of "mask-repeat-y" */
  void set maskRepeatY(var value) {
    setProperty('${_browserPrefix}mask-repeat-y', value, '');
  }

  /** Gets the value of "mask-size" */
  String get maskSize() =>
    getPropertyValue('${_browserPrefix}mask-size');

  /** Sets the value of "mask-size" */
  void set maskSize(var value) {
    setProperty('${_browserPrefix}mask-size', value, '');
  }

  /** Gets the value of "match-nearest-mail-blockquote-color" */
  String get matchNearestMailBlockquoteColor() =>
    getPropertyValue('${_browserPrefix}match-nearest-mail-blockquote-color');

  /** Sets the value of "match-nearest-mail-blockquote-color" */
  void set matchNearestMailBlockquoteColor(var value) {
    setProperty('${_browserPrefix}match-nearest-mail-blockquote-color', value, '');
  }

  /** Gets the value of "max-height" */
  String get maxHeight() =>
    getPropertyValue('max-height');

  /** Sets the value of "max-height" */
  void set maxHeight(var value) {
    setProperty('max-height', value, '');
  }

  /** Gets the value of "max-logical-height" */
  String get maxLogicalHeight() =>
    getPropertyValue('${_browserPrefix}max-logical-height');

  /** Sets the value of "max-logical-height" */
  void set maxLogicalHeight(var value) {
    setProperty('${_browserPrefix}max-logical-height', value, '');
  }

  /** Gets the value of "max-logical-width" */
  String get maxLogicalWidth() =>
    getPropertyValue('${_browserPrefix}max-logical-width');

  /** Sets the value of "max-logical-width" */
  void set maxLogicalWidth(var value) {
    setProperty('${_browserPrefix}max-logical-width', value, '');
  }

  /** Gets the value of "max-width" */
  String get maxWidth() =>
    getPropertyValue('max-width');

  /** Sets the value of "max-width" */
  void set maxWidth(var value) {
    setProperty('max-width', value, '');
  }

  /** Gets the value of "min-height" */
  String get minHeight() =>
    getPropertyValue('min-height');

  /** Sets the value of "min-height" */
  void set minHeight(var value) {
    setProperty('min-height', value, '');
  }

  /** Gets the value of "min-logical-height" */
  String get minLogicalHeight() =>
    getPropertyValue('${_browserPrefix}min-logical-height');

  /** Sets the value of "min-logical-height" */
  void set minLogicalHeight(var value) {
    setProperty('${_browserPrefix}min-logical-height', value, '');
  }

  /** Gets the value of "min-logical-width" */
  String get minLogicalWidth() =>
    getPropertyValue('${_browserPrefix}min-logical-width');

  /** Sets the value of "min-logical-width" */
  void set minLogicalWidth(var value) {
    setProperty('${_browserPrefix}min-logical-width', value, '');
  }

  /** Gets the value of "min-width" */
  String get minWidth() =>
    getPropertyValue('min-width');

  /** Sets the value of "min-width" */
  void set minWidth(var value) {
    setProperty('min-width', value, '');
  }

  /** Gets the value of "nbsp-mode" */
  String get nbspMode() =>
    getPropertyValue('${_browserPrefix}nbsp-mode');

  /** Sets the value of "nbsp-mode" */
  void set nbspMode(var value) {
    setProperty('${_browserPrefix}nbsp-mode', value, '');
  }

  /** Gets the value of "opacity" */
  String get opacity() =>
    getPropertyValue('opacity');

  /** Sets the value of "opacity" */
  void set opacity(var value) {
    setProperty('opacity', value, '');
  }

  /** Gets the value of "orphans" */
  String get orphans() =>
    getPropertyValue('orphans');

  /** Sets the value of "orphans" */
  void set orphans(var value) {
    setProperty('orphans', value, '');
  }

  /** Gets the value of "outline" */
  String get outline() =>
    getPropertyValue('outline');

  /** Sets the value of "outline" */
  void set outline(var value) {
    setProperty('outline', value, '');
  }

  /** Gets the value of "outline-color" */
  String get outlineColor() =>
    getPropertyValue('outline-color');

  /** Sets the value of "outline-color" */
  void set outlineColor(var value) {
    setProperty('outline-color', value, '');
  }

  /** Gets the value of "outline-offset" */
  String get outlineOffset() =>
    getPropertyValue('outline-offset');

  /** Sets the value of "outline-offset" */
  void set outlineOffset(var value) {
    setProperty('outline-offset', value, '');
  }

  /** Gets the value of "outline-style" */
  String get outlineStyle() =>
    getPropertyValue('outline-style');

  /** Sets the value of "outline-style" */
  void set outlineStyle(var value) {
    setProperty('outline-style', value, '');
  }

  /** Gets the value of "outline-width" */
  String get outlineWidth() =>
    getPropertyValue('outline-width');

  /** Sets the value of "outline-width" */
  void set outlineWidth(var value) {
    setProperty('outline-width', value, '');
  }

  /** Gets the value of "overflow" */
  String get overflow() =>
    getPropertyValue('overflow');

  /** Sets the value of "overflow" */
  void set overflow(var value) {
    setProperty('overflow', value, '');
  }

  /** Gets the value of "overflow-x" */
  String get overflowX() =>
    getPropertyValue('overflow-x');

  /** Sets the value of "overflow-x" */
  void set overflowX(var value) {
    setProperty('overflow-x', value, '');
  }

  /** Gets the value of "overflow-y" */
  String get overflowY() =>
    getPropertyValue('overflow-y');

  /** Sets the value of "overflow-y" */
  void set overflowY(var value) {
    setProperty('overflow-y', value, '');
  }

  /** Gets the value of "padding" */
  String get padding() =>
    getPropertyValue('padding');

  /** Sets the value of "padding" */
  void set padding(var value) {
    setProperty('padding', value, '');
  }

  /** Gets the value of "padding-after" */
  String get paddingAfter() =>
    getPropertyValue('${_browserPrefix}padding-after');

  /** Sets the value of "padding-after" */
  void set paddingAfter(var value) {
    setProperty('${_browserPrefix}padding-after', value, '');
  }

  /** Gets the value of "padding-before" */
  String get paddingBefore() =>
    getPropertyValue('${_browserPrefix}padding-before');

  /** Sets the value of "padding-before" */
  void set paddingBefore(var value) {
    setProperty('${_browserPrefix}padding-before', value, '');
  }

  /** Gets the value of "padding-bottom" */
  String get paddingBottom() =>
    getPropertyValue('padding-bottom');

  /** Sets the value of "padding-bottom" */
  void set paddingBottom(var value) {
    setProperty('padding-bottom', value, '');
  }

  /** Gets the value of "padding-end" */
  String get paddingEnd() =>
    getPropertyValue('${_browserPrefix}padding-end');

  /** Sets the value of "padding-end" */
  void set paddingEnd(var value) {
    setProperty('${_browserPrefix}padding-end', value, '');
  }

  /** Gets the value of "padding-left" */
  String get paddingLeft() =>
    getPropertyValue('padding-left');

  /** Sets the value of "padding-left" */
  void set paddingLeft(var value) {
    setProperty('padding-left', value, '');
  }

  /** Gets the value of "padding-right" */
  String get paddingRight() =>
    getPropertyValue('padding-right');

  /** Sets the value of "padding-right" */
  void set paddingRight(var value) {
    setProperty('padding-right', value, '');
  }

  /** Gets the value of "padding-start" */
  String get paddingStart() =>
    getPropertyValue('${_browserPrefix}padding-start');

  /** Sets the value of "padding-start" */
  void set paddingStart(var value) {
    setProperty('${_browserPrefix}padding-start', value, '');
  }

  /** Gets the value of "padding-top" */
  String get paddingTop() =>
    getPropertyValue('padding-top');

  /** Sets the value of "padding-top" */
  void set paddingTop(var value) {
    setProperty('padding-top', value, '');
  }

  /** Gets the value of "page" */
  String get page() =>
    getPropertyValue('page');

  /** Sets the value of "page" */
  void set page(var value) {
    setProperty('page', value, '');
  }

  /** Gets the value of "page-break-after" */
  String get pageBreakAfter() =>
    getPropertyValue('page-break-after');

  /** Sets the value of "page-break-after" */
  void set pageBreakAfter(var value) {
    setProperty('page-break-after', value, '');
  }

  /** Gets the value of "page-break-before" */
  String get pageBreakBefore() =>
    getPropertyValue('page-break-before');

  /** Sets the value of "page-break-before" */
  void set pageBreakBefore(var value) {
    setProperty('page-break-before', value, '');
  }

  /** Gets the value of "page-break-inside" */
  String get pageBreakInside() =>
    getPropertyValue('page-break-inside');

  /** Sets the value of "page-break-inside" */
  void set pageBreakInside(var value) {
    setProperty('page-break-inside', value, '');
  }

  /** Gets the value of "perspective" */
  String get perspective() =>
    getPropertyValue('${_browserPrefix}perspective');

  /** Sets the value of "perspective" */
  void set perspective(var value) {
    setProperty('${_browserPrefix}perspective', value, '');
  }

  /** Gets the value of "perspective-origin" */
  String get perspectiveOrigin() =>
    getPropertyValue('${_browserPrefix}perspective-origin');

  /** Sets the value of "perspective-origin" */
  void set perspectiveOrigin(var value) {
    setProperty('${_browserPrefix}perspective-origin', value, '');
  }

  /** Gets the value of "perspective-origin-x" */
  String get perspectiveOriginX() =>
    getPropertyValue('${_browserPrefix}perspective-origin-x');

  /** Sets the value of "perspective-origin-x" */
  void set perspectiveOriginX(var value) {
    setProperty('${_browserPrefix}perspective-origin-x', value, '');
  }

  /** Gets the value of "perspective-origin-y" */
  String get perspectiveOriginY() =>
    getPropertyValue('${_browserPrefix}perspective-origin-y');

  /** Sets the value of "perspective-origin-y" */
  void set perspectiveOriginY(var value) {
    setProperty('${_browserPrefix}perspective-origin-y', value, '');
  }

  /** Gets the value of "pointer-events" */
  String get pointerEvents() =>
    getPropertyValue('pointer-events');

  /** Sets the value of "pointer-events" */
  void set pointerEvents(var value) {
    setProperty('pointer-events', value, '');
  }

  /** Gets the value of "position" */
  String get position() =>
    getPropertyValue('position');

  /** Sets the value of "position" */
  void set position(var value) {
    setProperty('position', value, '');
  }

  /** Gets the value of "quotes" */
  String get quotes() =>
    getPropertyValue('quotes');

  /** Sets the value of "quotes" */
  void set quotes(var value) {
    setProperty('quotes', value, '');
  }

  /** Gets the value of "region-break-after" */
  String get regionBreakAfter() =>
    getPropertyValue('${_browserPrefix}region-break-after');

  /** Sets the value of "region-break-after" */
  void set regionBreakAfter(var value) {
    setProperty('${_browserPrefix}region-break-after', value, '');
  }

  /** Gets the value of "region-break-before" */
  String get regionBreakBefore() =>
    getPropertyValue('${_browserPrefix}region-break-before');

  /** Sets the value of "region-break-before" */
  void set regionBreakBefore(var value) {
    setProperty('${_browserPrefix}region-break-before', value, '');
  }

  /** Gets the value of "region-break-inside" */
  String get regionBreakInside() =>
    getPropertyValue('${_browserPrefix}region-break-inside');

  /** Sets the value of "region-break-inside" */
  void set regionBreakInside(var value) {
    setProperty('${_browserPrefix}region-break-inside', value, '');
  }

  /** Gets the value of "region-overflow" */
  String get regionOverflow() =>
    getPropertyValue('${_browserPrefix}region-overflow');

  /** Sets the value of "region-overflow" */
  void set regionOverflow(var value) {
    setProperty('${_browserPrefix}region-overflow', value, '');
  }

  /** Gets the value of "resize" */
  String get resize() =>
    getPropertyValue('resize');

  /** Sets the value of "resize" */
  void set resize(var value) {
    setProperty('resize', value, '');
  }

  /** Gets the value of "right" */
  String get right() =>
    getPropertyValue('right');

  /** Sets the value of "right" */
  void set right(var value) {
    setProperty('right', value, '');
  }

  /** Gets the value of "rtl-ordering" */
  String get rtlOrdering() =>
    getPropertyValue('${_browserPrefix}rtl-ordering');

  /** Sets the value of "rtl-ordering" */
  void set rtlOrdering(var value) {
    setProperty('${_browserPrefix}rtl-ordering', value, '');
  }

  /** Gets the value of "size" */
  String get size() =>
    getPropertyValue('size');

  /** Sets the value of "size" */
  void set size(var value) {
    setProperty('size', value, '');
  }

  /** Gets the value of "speak" */
  String get speak() =>
    getPropertyValue('speak');

  /** Sets the value of "speak" */
  void set speak(var value) {
    setProperty('speak', value, '');
  }

  /** Gets the value of "src" */
  String get src() =>
    getPropertyValue('src');

  /** Sets the value of "src" */
  void set src(var value) {
    setProperty('src', value, '');
  }

  /** Gets the value of "table-layout" */
  String get tableLayout() =>
    getPropertyValue('table-layout');

  /** Sets the value of "table-layout" */
  void set tableLayout(var value) {
    setProperty('table-layout', value, '');
  }

  /** Gets the value of "tap-highlight-color" */
  String get tapHighlightColor() =>
    getPropertyValue('${_browserPrefix}tap-highlight-color');

  /** Sets the value of "tap-highlight-color" */
  void set tapHighlightColor(var value) {
    setProperty('${_browserPrefix}tap-highlight-color', value, '');
  }

  /** Gets the value of "text-align" */
  String get textAlign() =>
    getPropertyValue('text-align');

  /** Sets the value of "text-align" */
  void set textAlign(var value) {
    setProperty('text-align', value, '');
  }

  /** Gets the value of "text-combine" */
  String get textCombine() =>
    getPropertyValue('${_browserPrefix}text-combine');

  /** Sets the value of "text-combine" */
  void set textCombine(var value) {
    setProperty('${_browserPrefix}text-combine', value, '');
  }

  /** Gets the value of "text-decoration" */
  String get textDecoration() =>
    getPropertyValue('text-decoration');

  /** Sets the value of "text-decoration" */
  void set textDecoration(var value) {
    setProperty('text-decoration', value, '');
  }

  /** Gets the value of "text-decorations-in-effect" */
  String get textDecorationsInEffect() =>
    getPropertyValue('${_browserPrefix}text-decorations-in-effect');

  /** Sets the value of "text-decorations-in-effect" */
  void set textDecorationsInEffect(var value) {
    setProperty('${_browserPrefix}text-decorations-in-effect', value, '');
  }

  /** Gets the value of "text-emphasis" */
  String get textEmphasis() =>
    getPropertyValue('${_browserPrefix}text-emphasis');

  /** Sets the value of "text-emphasis" */
  void set textEmphasis(var value) {
    setProperty('${_browserPrefix}text-emphasis', value, '');
  }

  /** Gets the value of "text-emphasis-color" */
  String get textEmphasisColor() =>
    getPropertyValue('${_browserPrefix}text-emphasis-color');

  /** Sets the value of "text-emphasis-color" */
  void set textEmphasisColor(var value) {
    setProperty('${_browserPrefix}text-emphasis-color', value, '');
  }

  /** Gets the value of "text-emphasis-position" */
  String get textEmphasisPosition() =>
    getPropertyValue('${_browserPrefix}text-emphasis-position');

  /** Sets the value of "text-emphasis-position" */
  void set textEmphasisPosition(var value) {
    setProperty('${_browserPrefix}text-emphasis-position', value, '');
  }

  /** Gets the value of "text-emphasis-style" */
  String get textEmphasisStyle() =>
    getPropertyValue('${_browserPrefix}text-emphasis-style');

  /** Sets the value of "text-emphasis-style" */
  void set textEmphasisStyle(var value) {
    setProperty('${_browserPrefix}text-emphasis-style', value, '');
  }

  /** Gets the value of "text-fill-color" */
  String get textFillColor() =>
    getPropertyValue('${_browserPrefix}text-fill-color');

  /** Sets the value of "text-fill-color" */
  void set textFillColor(var value) {
    setProperty('${_browserPrefix}text-fill-color', value, '');
  }

  /** Gets the value of "text-indent" */
  String get textIndent() =>
    getPropertyValue('text-indent');

  /** Sets the value of "text-indent" */
  void set textIndent(var value) {
    setProperty('text-indent', value, '');
  }

  /** Gets the value of "text-line-through" */
  String get textLineThrough() =>
    getPropertyValue('text-line-through');

  /** Sets the value of "text-line-through" */
  void set textLineThrough(var value) {
    setProperty('text-line-through', value, '');
  }

  /** Gets the value of "text-line-through-color" */
  String get textLineThroughColor() =>
    getPropertyValue('text-line-through-color');

  /** Sets the value of "text-line-through-color" */
  void set textLineThroughColor(var value) {
    setProperty('text-line-through-color', value, '');
  }

  /** Gets the value of "text-line-through-mode" */
  String get textLineThroughMode() =>
    getPropertyValue('text-line-through-mode');

  /** Sets the value of "text-line-through-mode" */
  void set textLineThroughMode(var value) {
    setProperty('text-line-through-mode', value, '');
  }

  /** Gets the value of "text-line-through-style" */
  String get textLineThroughStyle() =>
    getPropertyValue('text-line-through-style');

  /** Sets the value of "text-line-through-style" */
  void set textLineThroughStyle(var value) {
    setProperty('text-line-through-style', value, '');
  }

  /** Gets the value of "text-line-through-width" */
  String get textLineThroughWidth() =>
    getPropertyValue('text-line-through-width');

  /** Sets the value of "text-line-through-width" */
  void set textLineThroughWidth(var value) {
    setProperty('text-line-through-width', value, '');
  }

  /** Gets the value of "text-orientation" */
  String get textOrientation() =>
    getPropertyValue('${_browserPrefix}text-orientation');

  /** Sets the value of "text-orientation" */
  void set textOrientation(var value) {
    setProperty('${_browserPrefix}text-orientation', value, '');
  }

  /** Gets the value of "text-overflow" */
  String get textOverflow() =>
    getPropertyValue('text-overflow');

  /** Sets the value of "text-overflow" */
  void set textOverflow(var value) {
    setProperty('text-overflow', value, '');
  }

  /** Gets the value of "text-overline" */
  String get textOverline() =>
    getPropertyValue('text-overline');

  /** Sets the value of "text-overline" */
  void set textOverline(var value) {
    setProperty('text-overline', value, '');
  }

  /** Gets the value of "text-overline-color" */
  String get textOverlineColor() =>
    getPropertyValue('text-overline-color');

  /** Sets the value of "text-overline-color" */
  void set textOverlineColor(var value) {
    setProperty('text-overline-color', value, '');
  }

  /** Gets the value of "text-overline-mode" */
  String get textOverlineMode() =>
    getPropertyValue('text-overline-mode');

  /** Sets the value of "text-overline-mode" */
  void set textOverlineMode(var value) {
    setProperty('text-overline-mode', value, '');
  }

  /** Gets the value of "text-overline-style" */
  String get textOverlineStyle() =>
    getPropertyValue('text-overline-style');

  /** Sets the value of "text-overline-style" */
  void set textOverlineStyle(var value) {
    setProperty('text-overline-style', value, '');
  }

  /** Gets the value of "text-overline-width" */
  String get textOverlineWidth() =>
    getPropertyValue('text-overline-width');

  /** Sets the value of "text-overline-width" */
  void set textOverlineWidth(var value) {
    setProperty('text-overline-width', value, '');
  }

  /** Gets the value of "text-rendering" */
  String get textRendering() =>
    getPropertyValue('text-rendering');

  /** Sets the value of "text-rendering" */
  void set textRendering(var value) {
    setProperty('text-rendering', value, '');
  }

  /** Gets the value of "text-security" */
  String get textSecurity() =>
    getPropertyValue('${_browserPrefix}text-security');

  /** Sets the value of "text-security" */
  void set textSecurity(var value) {
    setProperty('${_browserPrefix}text-security', value, '');
  }

  /** Gets the value of "text-shadow" */
  String get textShadow() =>
    getPropertyValue('text-shadow');

  /** Sets the value of "text-shadow" */
  void set textShadow(var value) {
    setProperty('text-shadow', value, '');
  }

  /** Gets the value of "text-size-adjust" */
  String get textSizeAdjust() =>
    getPropertyValue('${_browserPrefix}text-size-adjust');

  /** Sets the value of "text-size-adjust" */
  void set textSizeAdjust(var value) {
    setProperty('${_browserPrefix}text-size-adjust', value, '');
  }

  /** Gets the value of "text-stroke" */
  String get textStroke() =>
    getPropertyValue('${_browserPrefix}text-stroke');

  /** Sets the value of "text-stroke" */
  void set textStroke(var value) {
    setProperty('${_browserPrefix}text-stroke', value, '');
  }

  /** Gets the value of "text-stroke-color" */
  String get textStrokeColor() =>
    getPropertyValue('${_browserPrefix}text-stroke-color');

  /** Sets the value of "text-stroke-color" */
  void set textStrokeColor(var value) {
    setProperty('${_browserPrefix}text-stroke-color', value, '');
  }

  /** Gets the value of "text-stroke-width" */
  String get textStrokeWidth() =>
    getPropertyValue('${_browserPrefix}text-stroke-width');

  /** Sets the value of "text-stroke-width" */
  void set textStrokeWidth(var value) {
    setProperty('${_browserPrefix}text-stroke-width', value, '');
  }

  /** Gets the value of "text-transform" */
  String get textTransform() =>
    getPropertyValue('text-transform');

  /** Sets the value of "text-transform" */
  void set textTransform(var value) {
    setProperty('text-transform', value, '');
  }

  /** Gets the value of "text-underline" */
  String get textUnderline() =>
    getPropertyValue('text-underline');

  /** Sets the value of "text-underline" */
  void set textUnderline(var value) {
    setProperty('text-underline', value, '');
  }

  /** Gets the value of "text-underline-color" */
  String get textUnderlineColor() =>
    getPropertyValue('text-underline-color');

  /** Sets the value of "text-underline-color" */
  void set textUnderlineColor(var value) {
    setProperty('text-underline-color', value, '');
  }

  /** Gets the value of "text-underline-mode" */
  String get textUnderlineMode() =>
    getPropertyValue('text-underline-mode');

  /** Sets the value of "text-underline-mode" */
  void set textUnderlineMode(var value) {
    setProperty('text-underline-mode', value, '');
  }

  /** Gets the value of "text-underline-style" */
  String get textUnderlineStyle() =>
    getPropertyValue('text-underline-style');

  /** Sets the value of "text-underline-style" */
  void set textUnderlineStyle(var value) {
    setProperty('text-underline-style', value, '');
  }

  /** Gets the value of "text-underline-width" */
  String get textUnderlineWidth() =>
    getPropertyValue('text-underline-width');

  /** Sets the value of "text-underline-width" */
  void set textUnderlineWidth(var value) {
    setProperty('text-underline-width', value, '');
  }

  /** Gets the value of "top" */
  String get top() =>
    getPropertyValue('top');

  /** Sets the value of "top" */
  void set top(var value) {
    setProperty('top', value, '');
  }

  /** Gets the value of "transform" */
  String get transform() =>
    getPropertyValue('${_browserPrefix}transform');

  /** Sets the value of "transform" */
  void set transform(var value) {
    setProperty('${_browserPrefix}transform', value, '');
  }

  /** Gets the value of "transform-origin" */
  String get transformOrigin() =>
    getPropertyValue('${_browserPrefix}transform-origin');

  /** Sets the value of "transform-origin" */
  void set transformOrigin(var value) {
    setProperty('${_browserPrefix}transform-origin', value, '');
  }

  /** Gets the value of "transform-origin-x" */
  String get transformOriginX() =>
    getPropertyValue('${_browserPrefix}transform-origin-x');

  /** Sets the value of "transform-origin-x" */
  void set transformOriginX(var value) {
    setProperty('${_browserPrefix}transform-origin-x', value, '');
  }

  /** Gets the value of "transform-origin-y" */
  String get transformOriginY() =>
    getPropertyValue('${_browserPrefix}transform-origin-y');

  /** Sets the value of "transform-origin-y" */
  void set transformOriginY(var value) {
    setProperty('${_browserPrefix}transform-origin-y', value, '');
  }

  /** Gets the value of "transform-origin-z" */
  String get transformOriginZ() =>
    getPropertyValue('${_browserPrefix}transform-origin-z');

  /** Sets the value of "transform-origin-z" */
  void set transformOriginZ(var value) {
    setProperty('${_browserPrefix}transform-origin-z', value, '');
  }

  /** Gets the value of "transform-style" */
  String get transformStyle() =>
    getPropertyValue('${_browserPrefix}transform-style');

  /** Sets the value of "transform-style" */
  void set transformStyle(var value) {
    setProperty('${_browserPrefix}transform-style', value, '');
  }

  /** Gets the value of "transition" */
  String get transition() =>
    getPropertyValue('${_browserPrefix}transition');

  /** Sets the value of "transition" */
  void set transition(var value) {
    setProperty('${_browserPrefix}transition', value, '');
  }

  /** Gets the value of "transition-delay" */
  String get transitionDelay() =>
    getPropertyValue('${_browserPrefix}transition-delay');

  /** Sets the value of "transition-delay" */
  void set transitionDelay(var value) {
    setProperty('${_browserPrefix}transition-delay', value, '');
  }

  /** Gets the value of "transition-duration" */
  String get transitionDuration() =>
    getPropertyValue('${_browserPrefix}transition-duration');

  /** Sets the value of "transition-duration" */
  void set transitionDuration(var value) {
    setProperty('${_browserPrefix}transition-duration', value, '');
  }

  /** Gets the value of "transition-property" */
  String get transitionProperty() =>
    getPropertyValue('${_browserPrefix}transition-property');

  /** Sets the value of "transition-property" */
  void set transitionProperty(var value) {
    setProperty('${_browserPrefix}transition-property', value, '');
  }

  /** Gets the value of "transition-timing-function" */
  String get transitionTimingFunction() =>
    getPropertyValue('${_browserPrefix}transition-timing-function');

  /** Sets the value of "transition-timing-function" */
  void set transitionTimingFunction(var value) {
    setProperty('${_browserPrefix}transition-timing-function', value, '');
  }

  /** Gets the value of "unicode-bidi" */
  String get unicodeBidi() =>
    getPropertyValue('unicode-bidi');

  /** Sets the value of "unicode-bidi" */
  void set unicodeBidi(var value) {
    setProperty('unicode-bidi', value, '');
  }

  /** Gets the value of "unicode-range" */
  String get unicodeRange() =>
    getPropertyValue('unicode-range');

  /** Sets the value of "unicode-range" */
  void set unicodeRange(var value) {
    setProperty('unicode-range', value, '');
  }

  /** Gets the value of "user-drag" */
  String get userDrag() =>
    getPropertyValue('${_browserPrefix}user-drag');

  /** Sets the value of "user-drag" */
  void set userDrag(var value) {
    setProperty('${_browserPrefix}user-drag', value, '');
  }

  /** Gets the value of "user-modify" */
  String get userModify() =>
    getPropertyValue('${_browserPrefix}user-modify');

  /** Sets the value of "user-modify" */
  void set userModify(var value) {
    setProperty('${_browserPrefix}user-modify', value, '');
  }

  /** Gets the value of "user-select" */
  String get userSelect() =>
    getPropertyValue('${_browserPrefix}user-select');

  /** Sets the value of "user-select" */
  void set userSelect(var value) {
    setProperty('${_browserPrefix}user-select', value, '');
  }

  /** Gets the value of "vertical-align" */
  String get verticalAlign() =>
    getPropertyValue('vertical-align');

  /** Sets the value of "vertical-align" */
  void set verticalAlign(var value) {
    setProperty('vertical-align', value, '');
  }

  /** Gets the value of "visibility" */
  String get visibility() =>
    getPropertyValue('visibility');

  /** Sets the value of "visibility" */
  void set visibility(var value) {
    setProperty('visibility', value, '');
  }

  /** Gets the value of "white-space" */
  String get whiteSpace() =>
    getPropertyValue('white-space');

  /** Sets the value of "white-space" */
  void set whiteSpace(var value) {
    setProperty('white-space', value, '');
  }

  /** Gets the value of "widows" */
  String get widows() =>
    getPropertyValue('widows');

  /** Sets the value of "widows" */
  void set widows(var value) {
    setProperty('widows', value, '');
  }

  /** Gets the value of "width" */
  String get width() =>
    getPropertyValue('width');

  /** Sets the value of "width" */
  void set width(var value) {
    setProperty('width', value, '');
  }

  /** Gets the value of "word-break" */
  String get wordBreak() =>
    getPropertyValue('word-break');

  /** Sets the value of "word-break" */
  void set wordBreak(var value) {
    setProperty('word-break', value, '');
  }

  /** Gets the value of "word-spacing" */
  String get wordSpacing() =>
    getPropertyValue('word-spacing');

  /** Sets the value of "word-spacing" */
  void set wordSpacing(var value) {
    setProperty('word-spacing', value, '');
  }

  /** Gets the value of "word-wrap" */
  String get wordWrap() =>
    getPropertyValue('word-wrap');

  /** Sets the value of "word-wrap" */
  void set wordWrap(var value) {
    setProperty('word-wrap', value, '');
  }

  /** Gets the value of "wrap-shape" */
  String get wrapShape() =>
    getPropertyValue('${_browserPrefix}wrap-shape');

  /** Sets the value of "wrap-shape" */
  void set wrapShape(var value) {
    setProperty('${_browserPrefix}wrap-shape', value, '');
  }

  /** Gets the value of "writing-mode" */
  String get writingMode() =>
    getPropertyValue('${_browserPrefix}writing-mode');

  /** Sets the value of "writing-mode" */
  void set writingMode(var value) {
    setProperty('${_browserPrefix}writing-mode', value, '');
  }

  /** Gets the value of "z-index" */
  String get zIndex() =>
    getPropertyValue('z-index');

  /** Sets the value of "z-index" */
  void set zIndex(var value) {
    setProperty('z-index', value, '');
  }

  /** Gets the value of "zoom" */
  String get zoom() =>
    getPropertyValue('zoom');

  /** Sets the value of "zoom" */
  void set zoom(var value) {
    setProperty('zoom', value, '');
  }
}

class _CSSStyleRuleImpl extends _CSSRuleImpl implements CSSStyleRule {
  _CSSStyleRuleImpl._wrap(ptr) : super._wrap(ptr);

  String get selectorText() => _wrap(_ptr.selectorText);

  void set selectorText(String value) { _ptr.selectorText = _unwrap(value); }

  CSSStyleDeclaration get style() => _wrap(_ptr.style);
}

class _CSSStyleSheetImpl extends _StyleSheetImpl implements CSSStyleSheet {
  _CSSStyleSheetImpl._wrap(ptr) : super._wrap(ptr);

  CSSRuleList get cssRules() => _wrap(_ptr.cssRules);

  CSSRule get ownerRule() => _wrap(_ptr.ownerRule);

  CSSRuleList get rules() => _wrap(_ptr.rules);

  int addRule(String selector, String style, [int index = null]) {
    if (index === null) {
      return _wrap(_ptr.addRule(_unwrap(selector), _unwrap(style)));
    } else {
      return _wrap(_ptr.addRule(_unwrap(selector), _unwrap(style), _unwrap(index)));
    }
  }

  void deleteRule(int index) {
    _ptr.deleteRule(_unwrap(index));
    return;
  }

  int insertRule(String rule, int index) {
    return _wrap(_ptr.insertRule(_unwrap(rule), _unwrap(index)));
  }

  void removeRule(int index) {
    _ptr.removeRule(_unwrap(index));
    return;
  }
}

class _CSSTransformValueImpl extends _CSSValueListImpl implements CSSTransformValue {
  _CSSTransformValueImpl._wrap(ptr) : super._wrap(ptr);

  int get operationType() => _wrap(_ptr.operationType);
}

class _CSSUnknownRuleImpl extends _CSSRuleImpl implements CSSUnknownRule {
  _CSSUnknownRuleImpl._wrap(ptr) : super._wrap(ptr);
}

class _CSSValueImpl extends _DOMTypeBase implements CSSValue {
  _CSSValueImpl._wrap(ptr) : super._wrap(ptr);

  String get cssText() => _wrap(_ptr.cssText);

  void set cssText(String value) { _ptr.cssText = _unwrap(value); }

  int get cssValueType() => _wrap(_ptr.cssValueType);
}

class _CSSValueListImpl extends _CSSValueImpl implements CSSValueList {
  _CSSValueListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  CSSValue item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _CanvasElementImpl extends _ElementImpl implements CanvasElement {
  _CanvasElementImpl._wrap(ptr) : super._wrap(ptr);

  int get height() => _wrap(_ptr.height);

  void set height(int value) { _ptr.height = _unwrap(value); }

  int get width() => _wrap(_ptr.width);

  void set width(int value) { _ptr.width = _unwrap(value); }

  Object getContext(String contextId) {
    return _wrap(_ptr.getContext(_unwrap(contextId)));
  }

  String toDataURL(String type) {
    return _wrap(_ptr.toDataURL(_unwrap(type)));
  }
}

class _CanvasGradientImpl extends _DOMTypeBase implements CanvasGradient {
  _CanvasGradientImpl._wrap(ptr) : super._wrap(ptr);

  void addColorStop(num offset, String color) {
    _ptr.addColorStop(_unwrap(offset), _unwrap(color));
    return;
  }
}

class _CanvasPatternImpl extends _DOMTypeBase implements CanvasPattern {
  _CanvasPatternImpl._wrap(ptr) : super._wrap(ptr);
}

class _CanvasRenderingContextImpl extends _DOMTypeBase implements CanvasRenderingContext {
  _CanvasRenderingContextImpl._wrap(ptr) : super._wrap(ptr);

  CanvasElement get canvas() => _wrap(_ptr.canvas);
}

class _CanvasRenderingContext2DImpl extends _CanvasRenderingContextImpl implements CanvasRenderingContext2D {
  _CanvasRenderingContext2DImpl._wrap(ptr) : super._wrap(ptr);

  Dynamic get fillStyle() => _wrap(_ptr.fillStyle);

  void set fillStyle(Dynamic value) { _ptr.fillStyle = _unwrap(value); }

  String get font() => _wrap(_ptr.font);

  void set font(String value) { _ptr.font = _unwrap(value); }

  num get globalAlpha() => _wrap(_ptr.globalAlpha);

  void set globalAlpha(num value) { _ptr.globalAlpha = _unwrap(value); }

  String get globalCompositeOperation() => _wrap(_ptr.globalCompositeOperation);

  void set globalCompositeOperation(String value) { _ptr.globalCompositeOperation = _unwrap(value); }

  String get lineCap() => _wrap(_ptr.lineCap);

  void set lineCap(String value) { _ptr.lineCap = _unwrap(value); }

  String get lineJoin() => _wrap(_ptr.lineJoin);

  void set lineJoin(String value) { _ptr.lineJoin = _unwrap(value); }

  num get lineWidth() => _wrap(_ptr.lineWidth);

  void set lineWidth(num value) { _ptr.lineWidth = _unwrap(value); }

  num get miterLimit() => _wrap(_ptr.miterLimit);

  void set miterLimit(num value) { _ptr.miterLimit = _unwrap(value); }

  num get shadowBlur() => _wrap(_ptr.shadowBlur);

  void set shadowBlur(num value) { _ptr.shadowBlur = _unwrap(value); }

  String get shadowColor() => _wrap(_ptr.shadowColor);

  void set shadowColor(String value) { _ptr.shadowColor = _unwrap(value); }

  num get shadowOffsetX() => _wrap(_ptr.shadowOffsetX);

  void set shadowOffsetX(num value) { _ptr.shadowOffsetX = _unwrap(value); }

  num get shadowOffsetY() => _wrap(_ptr.shadowOffsetY);

  void set shadowOffsetY(num value) { _ptr.shadowOffsetY = _unwrap(value); }

  Dynamic get strokeStyle() => _wrap(_ptr.strokeStyle);

  void set strokeStyle(Dynamic value) { _ptr.strokeStyle = _unwrap(value); }

  String get textAlign() => _wrap(_ptr.textAlign);

  void set textAlign(String value) { _ptr.textAlign = _unwrap(value); }

  String get textBaseline() => _wrap(_ptr.textBaseline);

  void set textBaseline(String value) { _ptr.textBaseline = _unwrap(value); }

  num get webkitBackingStorePixelRatio() => _wrap(_ptr.webkitBackingStorePixelRatio);

  List get webkitLineDash() => _wrap(_ptr.webkitLineDash);

  void set webkitLineDash(List value) { _ptr.webkitLineDash = _unwrap(value); }

  num get webkitLineDashOffset() => _wrap(_ptr.webkitLineDashOffset);

  void set webkitLineDashOffset(num value) { _ptr.webkitLineDashOffset = _unwrap(value); }

  void arc(num x, num y, num radius, num startAngle, num endAngle, bool anticlockwise) {
    _ptr.arc(_unwrap(x), _unwrap(y), _unwrap(radius), _unwrap(startAngle), _unwrap(endAngle), _unwrap(anticlockwise));
    return;
  }

  void arcTo(num x1, num y1, num x2, num y2, num radius) {
    _ptr.arcTo(_unwrap(x1), _unwrap(y1), _unwrap(x2), _unwrap(y2), _unwrap(radius));
    return;
  }

  void beginPath() {
    _ptr.beginPath();
    return;
  }

  void bezierCurveTo(num cp1x, num cp1y, num cp2x, num cp2y, num x, num y) {
    _ptr.bezierCurveTo(_unwrap(cp1x), _unwrap(cp1y), _unwrap(cp2x), _unwrap(cp2y), _unwrap(x), _unwrap(y));
    return;
  }

  void clearRect(num x, num y, num width, num height) {
    _ptr.clearRect(_unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height));
    return;
  }

  void clearShadow() {
    _ptr.clearShadow();
    return;
  }

  void clip() {
    _ptr.clip();
    return;
  }

  void closePath() {
    _ptr.closePath();
    return;
  }

  ImageData createImageData(imagedata_OR_sw, [num sh = null]) {
    if (imagedata_OR_sw is ImageData) {
      if (sh === null) {
        return _wrap(_ptr.createImageData(_unwrap(imagedata_OR_sw)));
      }
    } else {
      if (imagedata_OR_sw is num) {
        return _wrap(_ptr.createImageData(_unwrap(imagedata_OR_sw), _unwrap(sh)));
      }
    }
    throw "Incorrect number or type of arguments";
  }

  CanvasGradient createLinearGradient(num x0, num y0, num x1, num y1) {
    return _wrap(_ptr.createLinearGradient(_unwrap(x0), _unwrap(y0), _unwrap(x1), _unwrap(y1)));
  }

  CanvasPattern createPattern(canvas_OR_image, String repetitionType) {
    if (canvas_OR_image is CanvasElement) {
      return _wrap(_ptr.createPattern(_unwrap(canvas_OR_image), _unwrap(repetitionType)));
    } else {
      if (canvas_OR_image is ImageElement) {
        return _wrap(_ptr.createPattern(_unwrap(canvas_OR_image), _unwrap(repetitionType)));
      }
    }
    throw "Incorrect number or type of arguments";
  }

  CanvasGradient createRadialGradient(num x0, num y0, num r0, num x1, num y1, num r1) {
    return _wrap(_ptr.createRadialGradient(_unwrap(x0), _unwrap(y0), _unwrap(r0), _unwrap(x1), _unwrap(y1), _unwrap(r1)));
  }

  void drawImage(canvas_OR_image_OR_video, num sx_OR_x, num sy_OR_y, [num sw_OR_width = null, num height_OR_sh = null, num dx = null, num dy = null, num dw = null, num dh = null]) {
    if (canvas_OR_image_OR_video is ImageElement) {
      if (sw_OR_width === null) {
        if (height_OR_sh === null) {
          if (dx === null) {
            if (dy === null) {
              if (dw === null) {
                if (dh === null) {
                  _ptr.drawImage(_unwrap(canvas_OR_image_OR_video), _unwrap(sx_OR_x), _unwrap(sy_OR_y));
                  return;
                }
              }
            }
          }
        }
      } else {
        if (dx === null) {
          if (dy === null) {
            if (dw === null) {
              if (dh === null) {
                _ptr.drawImage(_unwrap(canvas_OR_image_OR_video), _unwrap(sx_OR_x), _unwrap(sy_OR_y), _unwrap(sw_OR_width), _unwrap(height_OR_sh));
                return;
              }
            }
          }
        } else {
          _ptr.drawImage(_unwrap(canvas_OR_image_OR_video), _unwrap(sx_OR_x), _unwrap(sy_OR_y), _unwrap(sw_OR_width), _unwrap(height_OR_sh), _unwrap(dx), _unwrap(dy), _unwrap(dw), _unwrap(dh));
          return;
        }
      }
    } else {
      if (canvas_OR_image_OR_video is CanvasElement) {
        if (sw_OR_width === null) {
          if (height_OR_sh === null) {
            if (dx === null) {
              if (dy === null) {
                if (dw === null) {
                  if (dh === null) {
                    _ptr.drawImage(_unwrap(canvas_OR_image_OR_video), _unwrap(sx_OR_x), _unwrap(sy_OR_y));
                    return;
                  }
                }
              }
            }
          }
        } else {
          if (dx === null) {
            if (dy === null) {
              if (dw === null) {
                if (dh === null) {
                  _ptr.drawImage(_unwrap(canvas_OR_image_OR_video), _unwrap(sx_OR_x), _unwrap(sy_OR_y), _unwrap(sw_OR_width), _unwrap(height_OR_sh));
                  return;
                }
              }
            }
          } else {
            _ptr.drawImage(_unwrap(canvas_OR_image_OR_video), _unwrap(sx_OR_x), _unwrap(sy_OR_y), _unwrap(sw_OR_width), _unwrap(height_OR_sh), _unwrap(dx), _unwrap(dy), _unwrap(dw), _unwrap(dh));
            return;
          }
        }
      } else {
        if (canvas_OR_image_OR_video is VideoElement) {
          if (sw_OR_width === null) {
            if (height_OR_sh === null) {
              if (dx === null) {
                if (dy === null) {
                  if (dw === null) {
                    if (dh === null) {
                      _ptr.drawImage(_unwrap(canvas_OR_image_OR_video), _unwrap(sx_OR_x), _unwrap(sy_OR_y));
                      return;
                    }
                  }
                }
              }
            }
          } else {
            if (dx === null) {
              if (dy === null) {
                if (dw === null) {
                  if (dh === null) {
                    _ptr.drawImage(_unwrap(canvas_OR_image_OR_video), _unwrap(sx_OR_x), _unwrap(sy_OR_y), _unwrap(sw_OR_width), _unwrap(height_OR_sh));
                    return;
                  }
                }
              }
            } else {
              _ptr.drawImage(_unwrap(canvas_OR_image_OR_video), _unwrap(sx_OR_x), _unwrap(sy_OR_y), _unwrap(sw_OR_width), _unwrap(height_OR_sh), _unwrap(dx), _unwrap(dy), _unwrap(dw), _unwrap(dh));
              return;
            }
          }
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void drawImageFromRect(ImageElement image, [num sx = null, num sy = null, num sw = null, num sh = null, num dx = null, num dy = null, num dw = null, num dh = null, String compositeOperation = null]) {
    if (sx === null) {
      if (sy === null) {
        if (sw === null) {
          if (sh === null) {
            if (dx === null) {
              if (dy === null) {
                if (dw === null) {
                  if (dh === null) {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(_unwrap(image));
                      return;
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
      if (sy === null) {
        if (sw === null) {
          if (sh === null) {
            if (dx === null) {
              if (dy === null) {
                if (dw === null) {
                  if (dh === null) {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(_unwrap(image), _unwrap(sx));
                      return;
                    }
                  }
                }
              }
            }
          }
        }
      } else {
        if (sw === null) {
          if (sh === null) {
            if (dx === null) {
              if (dy === null) {
                if (dw === null) {
                  if (dh === null) {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(_unwrap(image), _unwrap(sx), _unwrap(sy));
                      return;
                    }
                  }
                }
              }
            }
          }
        } else {
          if (sh === null) {
            if (dx === null) {
              if (dy === null) {
                if (dw === null) {
                  if (dh === null) {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(_unwrap(image), _unwrap(sx), _unwrap(sy), _unwrap(sw));
                      return;
                    }
                  }
                }
              }
            }
          } else {
            if (dx === null) {
              if (dy === null) {
                if (dw === null) {
                  if (dh === null) {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(_unwrap(image), _unwrap(sx), _unwrap(sy), _unwrap(sw), _unwrap(sh));
                      return;
                    }
                  }
                }
              }
            } else {
              if (dy === null) {
                if (dw === null) {
                  if (dh === null) {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(_unwrap(image), _unwrap(sx), _unwrap(sy), _unwrap(sw), _unwrap(sh), _unwrap(dx));
                      return;
                    }
                  }
                }
              } else {
                if (dw === null) {
                  if (dh === null) {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(_unwrap(image), _unwrap(sx), _unwrap(sy), _unwrap(sw), _unwrap(sh), _unwrap(dx), _unwrap(dy));
                      return;
                    }
                  }
                } else {
                  if (dh === null) {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(_unwrap(image), _unwrap(sx), _unwrap(sy), _unwrap(sw), _unwrap(sh), _unwrap(dx), _unwrap(dy), _unwrap(dw));
                      return;
                    }
                  } else {
                    if (compositeOperation === null) {
                      _ptr.drawImageFromRect(_unwrap(image), _unwrap(sx), _unwrap(sy), _unwrap(sw), _unwrap(sh), _unwrap(dx), _unwrap(dy), _unwrap(dw), _unwrap(dh));
                      return;
                    } else {
                      _ptr.drawImageFromRect(_unwrap(image), _unwrap(sx), _unwrap(sy), _unwrap(sw), _unwrap(sh), _unwrap(dx), _unwrap(dy), _unwrap(dw), _unwrap(dh), _unwrap(compositeOperation));
                      return;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void fill() {
    _ptr.fill();
    return;
  }

  void fillRect(num x, num y, num width, num height) {
    _ptr.fillRect(_unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height));
    return;
  }

  void fillText(String text, num x, num y, [num maxWidth = null]) {
    if (maxWidth === null) {
      _ptr.fillText(_unwrap(text), _unwrap(x), _unwrap(y));
      return;
    } else {
      _ptr.fillText(_unwrap(text), _unwrap(x), _unwrap(y), _unwrap(maxWidth));
      return;
    }
  }

  ImageData getImageData(num sx, num sy, num sw, num sh) {
    return _wrap(_ptr.getImageData(_unwrap(sx), _unwrap(sy), _unwrap(sw), _unwrap(sh)));
  }

  bool isPointInPath(num x, num y) {
    return _wrap(_ptr.isPointInPath(_unwrap(x), _unwrap(y)));
  }

  void lineTo(num x, num y) {
    _ptr.lineTo(_unwrap(x), _unwrap(y));
    return;
  }

  TextMetrics measureText(String text) {
    return _wrap(_ptr.measureText(_unwrap(text)));
  }

  void moveTo(num x, num y) {
    _ptr.moveTo(_unwrap(x), _unwrap(y));
    return;
  }

  void putImageData(ImageData imagedata, num dx, num dy, [num dirtyX = null, num dirtyY = null, num dirtyWidth = null, num dirtyHeight = null]) {
    if (dirtyX === null) {
      if (dirtyY === null) {
        if (dirtyWidth === null) {
          if (dirtyHeight === null) {
            _ptr.putImageData(_unwrap(imagedata), _unwrap(dx), _unwrap(dy));
            return;
          }
        }
      }
    } else {
      _ptr.putImageData(_unwrap(imagedata), _unwrap(dx), _unwrap(dy), _unwrap(dirtyX), _unwrap(dirtyY), _unwrap(dirtyWidth), _unwrap(dirtyHeight));
      return;
    }
    throw "Incorrect number or type of arguments";
  }

  void quadraticCurveTo(num cpx, num cpy, num x, num y) {
    _ptr.quadraticCurveTo(_unwrap(cpx), _unwrap(cpy), _unwrap(x), _unwrap(y));
    return;
  }

  void rect(num x, num y, num width, num height) {
    _ptr.rect(_unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height));
    return;
  }

  void restore() {
    _ptr.restore();
    return;
  }

  void rotate(num angle) {
    _ptr.rotate(_unwrap(angle));
    return;
  }

  void save() {
    _ptr.save();
    return;
  }

  void scale(num sx, num sy) {
    _ptr.scale(_unwrap(sx), _unwrap(sy));
    return;
  }

  void setAlpha(num alpha) {
    _ptr.setAlpha(_unwrap(alpha));
    return;
  }

  void setCompositeOperation(String compositeOperation) {
    _ptr.setCompositeOperation(_unwrap(compositeOperation));
    return;
  }

  void setFillColor(c_OR_color_OR_grayLevel_OR_r, [num alpha_OR_g_OR_m = null, num b_OR_y = null, num a_OR_k = null, num a = null]) {
    if (c_OR_color_OR_grayLevel_OR_r is String) {
      if (alpha_OR_g_OR_m === null) {
        if (b_OR_y === null) {
          if (a_OR_k === null) {
            if (a === null) {
              _ptr.setFillColor(_unwrap(c_OR_color_OR_grayLevel_OR_r));
              return;
            }
          }
        }
      } else {
        if (b_OR_y === null) {
          if (a_OR_k === null) {
            if (a === null) {
              _ptr.setFillColor(_unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m));
              return;
            }
          }
        }
      }
    } else {
      if (c_OR_color_OR_grayLevel_OR_r is num) {
        if (alpha_OR_g_OR_m === null) {
          if (b_OR_y === null) {
            if (a_OR_k === null) {
              if (a === null) {
                _ptr.setFillColor(_unwrap(c_OR_color_OR_grayLevel_OR_r));
                return;
              }
            }
          }
        } else {
          if (b_OR_y === null) {
            if (a_OR_k === null) {
              if (a === null) {
                _ptr.setFillColor(_unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m));
                return;
              }
            }
          } else {
            if (a === null) {
              _ptr.setFillColor(_unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m), _unwrap(b_OR_y), _unwrap(a_OR_k));
              return;
            } else {
              _ptr.setFillColor(_unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m), _unwrap(b_OR_y), _unwrap(a_OR_k), _unwrap(a));
              return;
            }
          }
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void setLineCap(String cap) {
    _ptr.setLineCap(_unwrap(cap));
    return;
  }

  void setLineJoin(String join) {
    _ptr.setLineJoin(_unwrap(join));
    return;
  }

  void setLineWidth(num width) {
    _ptr.setLineWidth(_unwrap(width));
    return;
  }

  void setMiterLimit(num limit) {
    _ptr.setMiterLimit(_unwrap(limit));
    return;
  }

  void setShadow(num width, num height, num blur, [c_OR_color_OR_grayLevel_OR_r = null, num alpha_OR_g_OR_m = null, num b_OR_y = null, num a_OR_k = null, num a = null]) {
    if (c_OR_color_OR_grayLevel_OR_r === null) {
      if (alpha_OR_g_OR_m === null) {
        if (b_OR_y === null) {
          if (a_OR_k === null) {
            if (a === null) {
              _ptr.setShadow(_unwrap(width), _unwrap(height), _unwrap(blur));
              return;
            }
          }
        }
      }
    } else {
      if (c_OR_color_OR_grayLevel_OR_r is String) {
        if (alpha_OR_g_OR_m === null) {
          if (b_OR_y === null) {
            if (a_OR_k === null) {
              if (a === null) {
                _ptr.setShadow(_unwrap(width), _unwrap(height), _unwrap(blur), _unwrap(c_OR_color_OR_grayLevel_OR_r));
                return;
              }
            }
          }
        } else {
          if (b_OR_y === null) {
            if (a_OR_k === null) {
              if (a === null) {
                _ptr.setShadow(_unwrap(width), _unwrap(height), _unwrap(blur), _unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m));
                return;
              }
            }
          }
        }
      } else {
        if (c_OR_color_OR_grayLevel_OR_r is num) {
          if (alpha_OR_g_OR_m === null) {
            if (b_OR_y === null) {
              if (a_OR_k === null) {
                if (a === null) {
                  _ptr.setShadow(_unwrap(width), _unwrap(height), _unwrap(blur), _unwrap(c_OR_color_OR_grayLevel_OR_r));
                  return;
                }
              }
            }
          } else {
            if (b_OR_y === null) {
              if (a_OR_k === null) {
                if (a === null) {
                  _ptr.setShadow(_unwrap(width), _unwrap(height), _unwrap(blur), _unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m));
                  return;
                }
              }
            } else {
              if (a === null) {
                _ptr.setShadow(_unwrap(width), _unwrap(height), _unwrap(blur), _unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m), _unwrap(b_OR_y), _unwrap(a_OR_k));
                return;
              } else {
                _ptr.setShadow(_unwrap(width), _unwrap(height), _unwrap(blur), _unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m), _unwrap(b_OR_y), _unwrap(a_OR_k), _unwrap(a));
                return;
              }
            }
          }
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void setStrokeColor(c_OR_color_OR_grayLevel_OR_r, [num alpha_OR_g_OR_m = null, num b_OR_y = null, num a_OR_k = null, num a = null]) {
    if (c_OR_color_OR_grayLevel_OR_r is String) {
      if (alpha_OR_g_OR_m === null) {
        if (b_OR_y === null) {
          if (a_OR_k === null) {
            if (a === null) {
              _ptr.setStrokeColor(_unwrap(c_OR_color_OR_grayLevel_OR_r));
              return;
            }
          }
        }
      } else {
        if (b_OR_y === null) {
          if (a_OR_k === null) {
            if (a === null) {
              _ptr.setStrokeColor(_unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m));
              return;
            }
          }
        }
      }
    } else {
      if (c_OR_color_OR_grayLevel_OR_r is num) {
        if (alpha_OR_g_OR_m === null) {
          if (b_OR_y === null) {
            if (a_OR_k === null) {
              if (a === null) {
                _ptr.setStrokeColor(_unwrap(c_OR_color_OR_grayLevel_OR_r));
                return;
              }
            }
          }
        } else {
          if (b_OR_y === null) {
            if (a_OR_k === null) {
              if (a === null) {
                _ptr.setStrokeColor(_unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m));
                return;
              }
            }
          } else {
            if (a === null) {
              _ptr.setStrokeColor(_unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m), _unwrap(b_OR_y), _unwrap(a_OR_k));
              return;
            } else {
              _ptr.setStrokeColor(_unwrap(c_OR_color_OR_grayLevel_OR_r), _unwrap(alpha_OR_g_OR_m), _unwrap(b_OR_y), _unwrap(a_OR_k), _unwrap(a));
              return;
            }
          }
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void setTransform(num m11, num m12, num m21, num m22, num dx, num dy) {
    _ptr.setTransform(_unwrap(m11), _unwrap(m12), _unwrap(m21), _unwrap(m22), _unwrap(dx), _unwrap(dy));
    return;
  }

  void stroke() {
    _ptr.stroke();
    return;
  }

  void strokeRect(num x, num y, num width, num height, [num lineWidth = null]) {
    if (lineWidth === null) {
      _ptr.strokeRect(_unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height));
      return;
    } else {
      _ptr.strokeRect(_unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height), _unwrap(lineWidth));
      return;
    }
  }

  void strokeText(String text, num x, num y, [num maxWidth = null]) {
    if (maxWidth === null) {
      _ptr.strokeText(_unwrap(text), _unwrap(x), _unwrap(y));
      return;
    } else {
      _ptr.strokeText(_unwrap(text), _unwrap(x), _unwrap(y), _unwrap(maxWidth));
      return;
    }
  }

  void transform(num m11, num m12, num m21, num m22, num dx, num dy) {
    _ptr.transform(_unwrap(m11), _unwrap(m12), _unwrap(m21), _unwrap(m22), _unwrap(dx), _unwrap(dy));
    return;
  }

  void translate(num tx, num ty) {
    _ptr.translate(_unwrap(tx), _unwrap(ty));
    return;
  }

  ImageData webkitGetImageDataHD(num sx, num sy, num sw, num sh) {
    return _wrap(_ptr.webkitGetImageDataHD(_unwrap(sx), _unwrap(sy), _unwrap(sw), _unwrap(sh)));
  }

  void webkitPutImageDataHD(ImageData imagedata, num dx, num dy, [num dirtyX = null, num dirtyY = null, num dirtyWidth = null, num dirtyHeight = null]) {
    if (dirtyX === null) {
      if (dirtyY === null) {
        if (dirtyWidth === null) {
          if (dirtyHeight === null) {
            _ptr.webkitPutImageDataHD(_unwrap(imagedata), _unwrap(dx), _unwrap(dy));
            return;
          }
        }
      }
    } else {
      _ptr.webkitPutImageDataHD(_unwrap(imagedata), _unwrap(dx), _unwrap(dy), _unwrap(dirtyX), _unwrap(dirtyY), _unwrap(dirtyWidth), _unwrap(dirtyHeight));
      return;
    }
    throw "Incorrect number or type of arguments";
  }
}

class _CharacterDataImpl extends _NodeImpl implements CharacterData {
  _CharacterDataImpl._wrap(ptr) : super._wrap(ptr);

  String get data() => _wrap(_ptr.data);

  void set data(String value) { _ptr.data = _unwrap(value); }

  int get length() => _wrap(_ptr.length);

  void appendData(String data) {
    _ptr.appendData(_unwrap(data));
    return;
  }

  void deleteData(int offset, int length) {
    _ptr.deleteData(_unwrap(offset), _unwrap(length));
    return;
  }

  void insertData(int offset, String data) {
    _ptr.insertData(_unwrap(offset), _unwrap(data));
    return;
  }

  void replaceData(int offset, int length, String data) {
    _ptr.replaceData(_unwrap(offset), _unwrap(length), _unwrap(data));
    return;
  }

  String substringData(int offset, int length) {
    return _wrap(_ptr.substringData(_unwrap(offset), _unwrap(length)));
  }
}

class _ClientRectImpl extends _DOMTypeBase implements ClientRect {
  _ClientRectImpl._wrap(ptr) : super._wrap(ptr);

  num get bottom() => _wrap(_ptr.bottom);

  num get height() => _wrap(_ptr.height);

  num get left() => _wrap(_ptr.left);

  num get right() => _wrap(_ptr.right);

  num get top() => _wrap(_ptr.top);

  num get width() => _wrap(_ptr.width);
}

class _ClientRectListImpl extends _DOMTypeBase implements ClientRectList {
  _ClientRectListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  ClientRect item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _ClipboardImpl extends _DOMTypeBase implements Clipboard {
  _ClipboardImpl._wrap(ptr) : super._wrap(ptr);

  String get dropEffect() => _wrap(_ptr.dropEffect);

  void set dropEffect(String value) { _ptr.dropEffect = _unwrap(value); }

  String get effectAllowed() => _wrap(_ptr.effectAllowed);

  void set effectAllowed(String value) { _ptr.effectAllowed = _unwrap(value); }

  FileList get files() => _wrap(_ptr.files);

  DataTransferItemList get items() => _wrap(_ptr.items);

  List get types() => _wrap(_ptr.types);

  void clearData([String type = null]) {
    if (type === null) {
      _ptr.clearData();
      return;
    } else {
      _ptr.clearData(_unwrap(type));
      return;
    }
  }

  String getData(String type) {
    return _wrap(_ptr.getData(_unwrap(type)));
  }

  bool setData(String type, String data) {
    return _wrap(_ptr.setData(_unwrap(type), _unwrap(data)));
  }

  void setDragImage(ImageElement image, int x, int y) {
    _ptr.setDragImage(_unwrap(image), _unwrap(x), _unwrap(y));
    return;
  }
}

class _CloseEventImpl extends _EventImpl implements CloseEvent {
  _CloseEventImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get reason() => _wrap(_ptr.reason);

  bool get wasClean() => _wrap(_ptr.wasClean);
}

class _CommentImpl extends _CharacterDataImpl implements Comment {
  _CommentImpl._wrap(ptr) : super._wrap(ptr);
}

class _CompositionEventImpl extends _UIEventImpl implements CompositionEvent {
  _CompositionEventImpl._wrap(ptr) : super._wrap(ptr);

  String get data() => _wrap(_ptr.data);

  void initCompositionEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Window viewArg, String dataArg) {
    _ptr.initCompositionEvent(_unwrap(typeArg), _unwrap(canBubbleArg), _unwrap(cancelableArg), _unwrap(viewArg), _unwrap(dataArg));
    return;
  }
}

class _ConsoleImpl extends _DOMTypeBase implements Console {
  _ConsoleImpl._wrap(ptr) : super._wrap(ptr);

  MemoryInfo get memory() => _wrap(_ptr.memory);

  List<ScriptProfile> get profiles() => _wrap(_ptr.profiles);

  void assertCondition(bool condition, Object arg) {
    _ptr.assertCondition(_unwrap(condition), _unwrap(arg));
    return;
  }

  void count() {
    _ptr.count();
    return;
  }

  void debug(Object arg) {
    _ptr.debug(_unwrap(arg));
    return;
  }

  void dir() {
    _ptr.dir();
    return;
  }

  void dirxml() {
    _ptr.dirxml();
    return;
  }

  void error(Object arg) {
    _ptr.error(_unwrap(arg));
    return;
  }

  void group(Object arg) {
    _ptr.group(_unwrap(arg));
    return;
  }

  void groupCollapsed(Object arg) {
    _ptr.groupCollapsed(_unwrap(arg));
    return;
  }

  void groupEnd() {
    _ptr.groupEnd();
    return;
  }

  void info(Object arg) {
    _ptr.info(_unwrap(arg));
    return;
  }

  void log(Object arg) {
    _ptr.log(_unwrap(arg));
    return;
  }

  void markTimeline() {
    _ptr.markTimeline();
    return;
  }

  void profile(String title) {
    _ptr.profile(_unwrap(title));
    return;
  }

  void profileEnd(String title) {
    _ptr.profileEnd(_unwrap(title));
    return;
  }

  void time(String title) {
    _ptr.time(_unwrap(title));
    return;
  }

  void timeEnd(String title, Object arg) {
    _ptr.timeEnd(_unwrap(title), _unwrap(arg));
    return;
  }

  void timeStamp(Object arg) {
    _ptr.timeStamp(_unwrap(arg));
    return;
  }

  void trace(Object arg) {
    _ptr.trace(_unwrap(arg));
    return;
  }

  void warn(Object arg) {
    _ptr.warn(_unwrap(arg));
    return;
  }
}

class _ContentElementImpl extends _ElementImpl implements ContentElement {
  _ContentElementImpl._wrap(ptr) : super._wrap(ptr);

  String get select() => _wrap(_ptr.select);

  void set select(String value) { _ptr.select = _unwrap(value); }
}

class _ConvolverNodeImpl extends _AudioNodeImpl implements ConvolverNode {
  _ConvolverNodeImpl._wrap(ptr) : super._wrap(ptr);

  AudioBuffer get buffer() => _wrap(_ptr.buffer);

  void set buffer(AudioBuffer value) { _ptr.buffer = _unwrap(value); }

  bool get normalize() => _wrap(_ptr.normalize);

  void set normalize(bool value) { _ptr.normalize = _unwrap(value); }
}

class _CoordinatesImpl extends _DOMTypeBase implements Coordinates {
  _CoordinatesImpl._wrap(ptr) : super._wrap(ptr);

  num get accuracy() => _wrap(_ptr.accuracy);

  num get altitude() => _wrap(_ptr.altitude);

  num get altitudeAccuracy() => _wrap(_ptr.altitudeAccuracy);

  num get heading() => _wrap(_ptr.heading);

  num get latitude() => _wrap(_ptr.latitude);

  num get longitude() => _wrap(_ptr.longitude);

  num get speed() => _wrap(_ptr.speed);
}

class _CounterImpl extends _DOMTypeBase implements Counter {
  _CounterImpl._wrap(ptr) : super._wrap(ptr);

  String get identifier() => _wrap(_ptr.identifier);

  String get listStyle() => _wrap(_ptr.listStyle);

  String get separator() => _wrap(_ptr.separator);
}

class _CryptoImpl extends _DOMTypeBase implements Crypto {
  _CryptoImpl._wrap(ptr) : super._wrap(ptr);

  void getRandomValues(ArrayBufferView array) {
    _ptr.getRandomValues(_unwrap(array));
    return;
  }
}

class _CustomEventImpl extends _EventImpl implements CustomEvent {
  _CustomEventImpl._wrap(ptr) : super._wrap(ptr);

  Object get detail() => _wrap(_ptr.detail);

  void initCustomEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object detailArg) {
    _ptr.initCustomEvent(_unwrap(typeArg), _unwrap(canBubbleArg), _unwrap(cancelableArg), _unwrap(detailArg));
    return;
  }
}

class _DListElementImpl extends _ElementImpl implements DListElement {
  _DListElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get compact() => _wrap(_ptr.compact);

  void set compact(bool value) { _ptr.compact = _unwrap(value); }
}

class _DOMApplicationCacheImpl extends _EventTargetImpl implements DOMApplicationCache {
  _DOMApplicationCacheImpl._wrap(ptr) : super._wrap(ptr);

  _DOMApplicationCacheEventsImpl get on() {
    if (_on == null) _on = new _DOMApplicationCacheEventsImpl(this);
    return _on;
  }

  int get status() => _wrap(_ptr.status);

  void abort() {
    _ptr.abort();
    return;
  }

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool $dom_dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void swapCache() {
    _ptr.swapCache();
    return;
  }

  void update() {
    _ptr.update();
    return;
  }
}

class _DOMApplicationCacheEventsImpl extends _EventsImpl implements DOMApplicationCacheEvents {
  _DOMApplicationCacheEventsImpl(_ptr) : super(_ptr);

  EventListenerList get cached() => _get('cached');

  EventListenerList get checking() => _get('checking');

  EventListenerList get downloading() => _get('downloading');

  EventListenerList get error() => _get('error');

  EventListenerList get noUpdate() => _get('noupdate');

  EventListenerList get obsolete() => _get('obsolete');

  EventListenerList get progress() => _get('progress');

  EventListenerList get updateReady() => _get('updateready');
}

class _DOMExceptionImpl extends _DOMTypeBase implements DOMException {
  _DOMExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _DOMFileSystemImpl extends _DOMTypeBase implements DOMFileSystem {
  _DOMFileSystemImpl._wrap(ptr) : super._wrap(ptr);

  String get name() => _wrap(_ptr.name);

  DirectoryEntry get root() => _wrap(_ptr.root);
}

class _DOMFileSystemSyncImpl extends _DOMTypeBase implements DOMFileSystemSync {
  _DOMFileSystemSyncImpl._wrap(ptr) : super._wrap(ptr);

  String get name() => _wrap(_ptr.name);

  DirectoryEntrySync get root() => _wrap(_ptr.root);
}

class _DOMFormDataImpl extends _DOMTypeBase implements DOMFormData {
  _DOMFormDataImpl._wrap(ptr) : super._wrap(ptr);

  void append(String name, String value, String filename) {
    _ptr.append(_unwrap(name), _unwrap(value), _unwrap(filename));
    return;
  }
}

class _DOMImplementationImpl extends _DOMTypeBase implements DOMImplementation {
  _DOMImplementationImpl._wrap(ptr) : super._wrap(ptr);

  CSSStyleSheet createCSSStyleSheet(String title, String media) {
    return _wrap(_ptr.createCSSStyleSheet(_unwrap(title), _unwrap(media)));
  }

  Document createDocument(String namespaceURI, String qualifiedName, DocumentType doctype) {
    return _wrap(_ptr.createDocument(_unwrap(namespaceURI), _unwrap(qualifiedName), _unwrap(doctype)));
  }

  DocumentType createDocumentType(String qualifiedName, String publicId, String systemId) {
    return _wrap(_ptr.createDocumentType(_unwrap(qualifiedName), _unwrap(publicId), _unwrap(systemId)));
  }

  Document createHTMLDocument(String title) {
    return _wrap(_ptr.createHTMLDocument(_unwrap(title)));
  }

  bool hasFeature(String feature, String version) {
    return _wrap(_ptr.hasFeature(_unwrap(feature), _unwrap(version)));
  }
}

class _DOMMimeTypeImpl extends _DOMTypeBase implements DOMMimeType {
  _DOMMimeTypeImpl._wrap(ptr) : super._wrap(ptr);

  String get description() => _wrap(_ptr.description);

  DOMPlugin get enabledPlugin() => _wrap(_ptr.enabledPlugin);

  String get suffixes() => _wrap(_ptr.suffixes);

  String get type() => _wrap(_ptr.type);
}

class _DOMMimeTypeArrayImpl extends _DOMTypeBase implements DOMMimeTypeArray {
  _DOMMimeTypeArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  DOMMimeType item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }

  DOMMimeType namedItem(String name) {
    return _wrap(_ptr.namedItem(_unwrap(name)));
  }
}

class _DOMParserImpl extends _DOMTypeBase implements DOMParser {
  _DOMParserImpl._wrap(ptr) : super._wrap(ptr);

  Document parseFromString(String str, String contentType) {
    return _wrap(_ptr.parseFromString(_unwrap(str), _unwrap(contentType)));
  }
}

class _DOMPluginImpl extends _DOMTypeBase implements DOMPlugin {
  _DOMPluginImpl._wrap(ptr) : super._wrap(ptr);

  String get description() => _wrap(_ptr.description);

  String get filename() => _wrap(_ptr.filename);

  int get length() => _wrap(_ptr.length);

  String get name() => _wrap(_ptr.name);

  DOMMimeType item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }

  DOMMimeType namedItem(String name) {
    return _wrap(_ptr.namedItem(_unwrap(name)));
  }
}

class _DOMPluginArrayImpl extends _DOMTypeBase implements DOMPluginArray {
  _DOMPluginArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  DOMPlugin item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }

  DOMPlugin namedItem(String name) {
    return _wrap(_ptr.namedItem(_unwrap(name)));
  }

  void refresh(bool reload) {
    _ptr.refresh(_unwrap(reload));
    return;
  }
}

class _DOMSelectionImpl extends _DOMTypeBase implements DOMSelection {
  _DOMSelectionImpl._wrap(ptr) : super._wrap(ptr);

  Node get anchorNode() => _wrap(_ptr.anchorNode);

  int get anchorOffset() => _wrap(_ptr.anchorOffset);

  Node get baseNode() => _wrap(_ptr.baseNode);

  int get baseOffset() => _wrap(_ptr.baseOffset);

  Node get extentNode() => _wrap(_ptr.extentNode);

  int get extentOffset() => _wrap(_ptr.extentOffset);

  Node get focusNode() => _wrap(_ptr.focusNode);

  int get focusOffset() => _wrap(_ptr.focusOffset);

  bool get isCollapsed() => _wrap(_ptr.isCollapsed);

  int get rangeCount() => _wrap(_ptr.rangeCount);

  String get type() => _wrap(_ptr.type);

  void addRange(Range range) {
    _ptr.addRange(_unwrap(range));
    return;
  }

  void collapse(Node node, int index) {
    _ptr.collapse(_unwrap(node), _unwrap(index));
    return;
  }

  void collapseToEnd() {
    _ptr.collapseToEnd();
    return;
  }

  void collapseToStart() {
    _ptr.collapseToStart();
    return;
  }

  bool containsNode(Node node, bool allowPartial) {
    return _wrap(_ptr.containsNode(_unwrap(node), _unwrap(allowPartial)));
  }

  void deleteFromDocument() {
    _ptr.deleteFromDocument();
    return;
  }

  void empty() {
    _ptr.empty();
    return;
  }

  void extend(Node node, int offset) {
    _ptr.extend(_unwrap(node), _unwrap(offset));
    return;
  }

  Range getRangeAt(int index) {
    return _wrap(_ptr.getRangeAt(_unwrap(index)));
  }

  void modify(String alter, String direction, String granularity) {
    _ptr.modify(_unwrap(alter), _unwrap(direction), _unwrap(granularity));
    return;
  }

  void removeAllRanges() {
    _ptr.removeAllRanges();
    return;
  }

  void selectAllChildren(Node node) {
    _ptr.selectAllChildren(_unwrap(node));
    return;
  }

  void setBaseAndExtent(Node baseNode, int baseOffset, Node extentNode, int extentOffset) {
    _ptr.setBaseAndExtent(_unwrap(baseNode), _unwrap(baseOffset), _unwrap(extentNode), _unwrap(extentOffset));
    return;
  }

  void setPosition(Node node, int offset) {
    _ptr.setPosition(_unwrap(node), _unwrap(offset));
    return;
  }

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _DOMSettableTokenListImpl extends _DOMTokenListImpl implements DOMSettableTokenList {
  _DOMSettableTokenListImpl._wrap(ptr) : super._wrap(ptr);

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }
}

class _DOMStringListImpl extends _DOMTypeBase implements DOMStringList {
  _DOMStringListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  String operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, String value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }
  // -- start List<String> mixins.
  // String is the element type.

  // From Iterable<String>:

  Iterator<String> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<String>(this);
  }

  // From Collection<String>:

  void add(String value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(String value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<String> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(String element)) => _Collections.forEach(this, f);

  Collection map(f(String element)) => _Collections.map(this, [], f);

  Collection<String> filter(bool f(String element)) =>
     _Collections.filter(this, <String>[], f);

  bool every(bool f(String element)) => _Collections.every(this, f);

  bool some(bool f(String element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<String>:

  void sort(int compare(String a, String b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(String element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(String element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  String last() => this[length - 1];

  String removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<String> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [String initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<String> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <String>[]);

  // -- end List<String> mixins.

  bool contains(String string) {
    return _wrap(_ptr.contains(_unwrap(string)));
  }

  String item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _DOMTokenListImpl extends _DOMTypeBase implements DOMTokenList {
  _DOMTokenListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  void add(String token) {
    _ptr.add(_unwrap(token));
    return;
  }

  bool contains(String token) {
    return _wrap(_ptr.contains(_unwrap(token)));
  }

  String item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }

  void remove(String token) {
    _ptr.remove(_unwrap(token));
    return;
  }

  String toString() {
    return _wrap(_ptr.toString());
  }

  bool toggle(String token) {
    return _wrap(_ptr.toggle(_unwrap(token)));
  }
}

class _DOMURLImpl extends _DOMTypeBase implements DOMURL {
  _DOMURLImpl._wrap(ptr) : super._wrap(ptr);
}

class _DataTransferItemImpl extends _DOMTypeBase implements DataTransferItem {
  _DataTransferItemImpl._wrap(ptr) : super._wrap(ptr);

  String get kind() => _wrap(_ptr.kind);

  String get type() => _wrap(_ptr.type);

  Blob getAsFile() {
    return _wrap(_ptr.getAsFile());
  }

  void getAsString([StringCallback callback = null]) {
    if (callback === null) {
      _ptr.getAsString();
      return;
    } else {
      _ptr.getAsString(_unwrap(callback));
      return;
    }
  }

  void webkitGetAsEntry([EntryCallback callback = null]) {
    if (callback === null) {
      _ptr.webkitGetAsEntry();
      return;
    } else {
      _ptr.webkitGetAsEntry(_unwrap(callback));
      return;
    }
  }
}

class _DataTransferItemListImpl extends _DOMTypeBase implements DataTransferItemList {
  _DataTransferItemListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  void add(data_OR_file, [String type = null]) {
    if (data_OR_file is File) {
      if (type === null) {
        _ptr.add(_unwrap(data_OR_file));
        return;
      }
    } else {
      if (data_OR_file is String) {
        _ptr.add(_unwrap(data_OR_file), _unwrap(type));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void clear() {
    _ptr.clear();
    return;
  }

  DataTransferItem item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _DataViewImpl extends _ArrayBufferViewImpl implements DataView {
  _DataViewImpl._wrap(ptr) : super._wrap(ptr);

  num getFloat32(int byteOffset, [bool littleEndian = null]) {
    if (littleEndian === null) {
      return _wrap(_ptr.getFloat32(_unwrap(byteOffset)));
    } else {
      return _wrap(_ptr.getFloat32(_unwrap(byteOffset), _unwrap(littleEndian)));
    }
  }

  num getFloat64(int byteOffset, [bool littleEndian = null]) {
    if (littleEndian === null) {
      return _wrap(_ptr.getFloat64(_unwrap(byteOffset)));
    } else {
      return _wrap(_ptr.getFloat64(_unwrap(byteOffset), _unwrap(littleEndian)));
    }
  }

  int getInt16(int byteOffset, [bool littleEndian = null]) {
    if (littleEndian === null) {
      return _wrap(_ptr.getInt16(_unwrap(byteOffset)));
    } else {
      return _wrap(_ptr.getInt16(_unwrap(byteOffset), _unwrap(littleEndian)));
    }
  }

  int getInt32(int byteOffset, [bool littleEndian = null]) {
    if (littleEndian === null) {
      return _wrap(_ptr.getInt32(_unwrap(byteOffset)));
    } else {
      return _wrap(_ptr.getInt32(_unwrap(byteOffset), _unwrap(littleEndian)));
    }
  }

  Object getInt8() {
    return _wrap(_ptr.getInt8());
  }

  int getUint16(int byteOffset, [bool littleEndian = null]) {
    if (littleEndian === null) {
      return _wrap(_ptr.getUint16(_unwrap(byteOffset)));
    } else {
      return _wrap(_ptr.getUint16(_unwrap(byteOffset), _unwrap(littleEndian)));
    }
  }

  int getUint32(int byteOffset, [bool littleEndian = null]) {
    if (littleEndian === null) {
      return _wrap(_ptr.getUint32(_unwrap(byteOffset)));
    } else {
      return _wrap(_ptr.getUint32(_unwrap(byteOffset), _unwrap(littleEndian)));
    }
  }

  Object getUint8() {
    return _wrap(_ptr.getUint8());
  }

  void setFloat32(int byteOffset, num value, [bool littleEndian = null]) {
    if (littleEndian === null) {
      _ptr.setFloat32(_unwrap(byteOffset), _unwrap(value));
      return;
    } else {
      _ptr.setFloat32(_unwrap(byteOffset), _unwrap(value), _unwrap(littleEndian));
      return;
    }
  }

  void setFloat64(int byteOffset, num value, [bool littleEndian = null]) {
    if (littleEndian === null) {
      _ptr.setFloat64(_unwrap(byteOffset), _unwrap(value));
      return;
    } else {
      _ptr.setFloat64(_unwrap(byteOffset), _unwrap(value), _unwrap(littleEndian));
      return;
    }
  }

  void setInt16(int byteOffset, int value, [bool littleEndian = null]) {
    if (littleEndian === null) {
      _ptr.setInt16(_unwrap(byteOffset), _unwrap(value));
      return;
    } else {
      _ptr.setInt16(_unwrap(byteOffset), _unwrap(value), _unwrap(littleEndian));
      return;
    }
  }

  void setInt32(int byteOffset, int value, [bool littleEndian = null]) {
    if (littleEndian === null) {
      _ptr.setInt32(_unwrap(byteOffset), _unwrap(value));
      return;
    } else {
      _ptr.setInt32(_unwrap(byteOffset), _unwrap(value), _unwrap(littleEndian));
      return;
    }
  }

  void setInt8() {
    _ptr.setInt8();
    return;
  }

  void setUint16(int byteOffset, int value, [bool littleEndian = null]) {
    if (littleEndian === null) {
      _ptr.setUint16(_unwrap(byteOffset), _unwrap(value));
      return;
    } else {
      _ptr.setUint16(_unwrap(byteOffset), _unwrap(value), _unwrap(littleEndian));
      return;
    }
  }

  void setUint32(int byteOffset, int value, [bool littleEndian = null]) {
    if (littleEndian === null) {
      _ptr.setUint32(_unwrap(byteOffset), _unwrap(value));
      return;
    } else {
      _ptr.setUint32(_unwrap(byteOffset), _unwrap(value), _unwrap(littleEndian));
      return;
    }
  }

  void setUint8() {
    _ptr.setUint8();
    return;
  }
}

class _DatabaseImpl extends _DOMTypeBase implements Database {
  _DatabaseImpl._wrap(ptr) : super._wrap(ptr);

  String get version() => _wrap(_ptr.version);

  void changeVersion(String oldVersion, String newVersion, [SQLTransactionCallback callback = null, SQLTransactionErrorCallback errorCallback = null, VoidCallback successCallback = null]) {
    if (callback === null) {
      if (errorCallback === null) {
        if (successCallback === null) {
          _ptr.changeVersion(_unwrap(oldVersion), _unwrap(newVersion));
          return;
        }
      }
    } else {
      if (errorCallback === null) {
        if (successCallback === null) {
          _ptr.changeVersion(_unwrap(oldVersion), _unwrap(newVersion), _unwrap(callback));
          return;
        }
      } else {
        if (successCallback === null) {
          _ptr.changeVersion(_unwrap(oldVersion), _unwrap(newVersion), _unwrap(callback), _unwrap(errorCallback));
          return;
        } else {
          _ptr.changeVersion(_unwrap(oldVersion), _unwrap(newVersion), _unwrap(callback), _unwrap(errorCallback), _unwrap(successCallback));
          return;
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void readTransaction(SQLTransactionCallback callback, [SQLTransactionErrorCallback errorCallback = null, VoidCallback successCallback = null]) {
    if (errorCallback === null) {
      if (successCallback === null) {
        _ptr.readTransaction(_unwrap(callback));
        return;
      }
    } else {
      if (successCallback === null) {
        _ptr.readTransaction(_unwrap(callback), _unwrap(errorCallback));
        return;
      } else {
        _ptr.readTransaction(_unwrap(callback), _unwrap(errorCallback), _unwrap(successCallback));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void transaction(SQLTransactionCallback callback, [SQLTransactionErrorCallback errorCallback = null, VoidCallback successCallback = null]) {
    if (errorCallback === null) {
      if (successCallback === null) {
        _ptr.transaction(_unwrap(callback));
        return;
      }
    } else {
      if (successCallback === null) {
        _ptr.transaction(_unwrap(callback), _unwrap(errorCallback));
        return;
      } else {
        _ptr.transaction(_unwrap(callback), _unwrap(errorCallback), _unwrap(successCallback));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }
}

class _DatabaseSyncImpl extends _DOMTypeBase implements DatabaseSync {
  _DatabaseSyncImpl._wrap(ptr) : super._wrap(ptr);

  String get lastErrorMessage() => _wrap(_ptr.lastErrorMessage);

  String get version() => _wrap(_ptr.version);

  void changeVersion(String oldVersion, String newVersion, [SQLTransactionSyncCallback callback = null]) {
    if (callback === null) {
      _ptr.changeVersion(_unwrap(oldVersion), _unwrap(newVersion));
      return;
    } else {
      _ptr.changeVersion(_unwrap(oldVersion), _unwrap(newVersion), _unwrap(callback));
      return;
    }
  }

  void readTransaction(SQLTransactionSyncCallback callback) {
    _ptr.readTransaction(_unwrap(callback));
    return;
  }

  void transaction(SQLTransactionSyncCallback callback) {
    _ptr.transaction(_unwrap(callback));
    return;
  }
}

class _DedicatedWorkerContextImpl extends _WorkerContextImpl implements DedicatedWorkerContext {
  _DedicatedWorkerContextImpl._wrap(ptr) : super._wrap(ptr);

  _DedicatedWorkerContextEventsImpl get on() {
    if (_on == null) _on = new _DedicatedWorkerContextEventsImpl(this);
    return _on;
  }

  void postMessage(Object message, [List messagePorts = null]) {
    if (messagePorts === null) {
      _ptr.postMessage(_unwrap(message));
      return;
    } else {
      _ptr.postMessage(_unwrap(message), _unwrap(messagePorts));
      return;
    }
  }

  void webkitPostMessage(Object message, [List transferList = null]) {
    if (transferList === null) {
      _ptr.webkitPostMessage(_unwrap(message));
      return;
    } else {
      _ptr.webkitPostMessage(_unwrap(message), _unwrap(transferList));
      return;
    }
  }
}

class _DedicatedWorkerContextEventsImpl extends _WorkerContextEventsImpl implements DedicatedWorkerContextEvents {
  _DedicatedWorkerContextEventsImpl(_ptr) : super(_ptr);

  EventListenerList get message() => _get('message');
}

class _DelayNodeImpl extends _AudioNodeImpl implements DelayNode {
  _DelayNodeImpl._wrap(ptr) : super._wrap(ptr);

  AudioParam get delayTime() => _wrap(_ptr.delayTime);
}

class _DeprecatedPeerConnectionImpl extends _EventTargetImpl implements DeprecatedPeerConnection {
  _DeprecatedPeerConnectionImpl._wrap(ptr) : super._wrap(ptr);

  _DeprecatedPeerConnectionEventsImpl get on() {
    if (_on == null) _on = new _DeprecatedPeerConnectionEventsImpl(this);
    return _on;
  }

  MediaStreamList get localStreams() => _wrap(_ptr.localStreams);

  int get readyState() => _wrap(_ptr.readyState);

  MediaStreamList get remoteStreams() => _wrap(_ptr.remoteStreams);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void addStream(MediaStream stream) {
    _ptr.addStream(_unwrap(stream));
    return;
  }

  void close() {
    _ptr.close();
    return;
  }

  bool $dom_dispatchEvent(Event event) {
    return _wrap(_ptr.dispatchEvent(_unwrap(event)));
  }

  void processSignalingMessage(String message) {
    _ptr.processSignalingMessage(_unwrap(message));
    return;
  }

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void removeStream(MediaStream stream) {
    _ptr.removeStream(_unwrap(stream));
    return;
  }

  void send(String text) {
    _ptr.send(_unwrap(text));
    return;
  }
}

class _DeprecatedPeerConnectionEventsImpl extends _EventsImpl implements DeprecatedPeerConnectionEvents {
  _DeprecatedPeerConnectionEventsImpl(_ptr) : super(_ptr);

  EventListenerList get addStream() => _get('addstream');

  EventListenerList get connecting() => _get('connecting');

  EventListenerList get message() => _get('message');

  EventListenerList get open() => _get('open');

  EventListenerList get removeStream() => _get('removestream');

  EventListenerList get stateChange() => _get('statechange');
}

class _DetailsElementImpl extends _ElementImpl implements DetailsElement {
  _DetailsElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get open() => _wrap(_ptr.open);

  void set open(bool value) { _ptr.open = _unwrap(value); }
}

class _DeviceMotionEventImpl extends _EventImpl implements DeviceMotionEvent {
  _DeviceMotionEventImpl._wrap(ptr) : super._wrap(ptr);

  num get interval() => _wrap(_ptr.interval);
}

class _DeviceOrientationEventImpl extends _EventImpl implements DeviceOrientationEvent {
  _DeviceOrientationEventImpl._wrap(ptr) : super._wrap(ptr);

  bool get absolute() => _wrap(_ptr.absolute);

  num get alpha() => _wrap(_ptr.alpha);

  num get beta() => _wrap(_ptr.beta);

  num get gamma() => _wrap(_ptr.gamma);

  void initDeviceOrientationEvent(String type, bool bubbles, bool cancelable, num alpha, num beta, num gamma, bool absolute) {
    _ptr.initDeviceOrientationEvent(_unwrap(type), _unwrap(bubbles), _unwrap(cancelable), _unwrap(alpha), _unwrap(beta), _unwrap(gamma), _unwrap(absolute));
    return;
  }
}

class _DirectoryElementImpl extends _ElementImpl implements DirectoryElement {
  _DirectoryElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get compact() => _wrap(_ptr.compact);

  void set compact(bool value) { _ptr.compact = _unwrap(value); }
}

class _DirectoryEntryImpl extends _EntryImpl implements DirectoryEntry {
  _DirectoryEntryImpl._wrap(ptr) : super._wrap(ptr);

  DirectoryReader createReader() {
    return _wrap(_ptr.createReader());
  }

  void getDirectory(String path, [Object flags = null, EntryCallback successCallback = null, ErrorCallback errorCallback = null]) {
    if (flags === null) {
      if (successCallback === null) {
        if (errorCallback === null) {
          _ptr.getDirectory(_unwrap(path));
          return;
        }
      }
    } else {
      if (successCallback === null) {
        if (errorCallback === null) {
          _ptr.getDirectory(_unwrap(path), _unwrap(flags));
          return;
        }
      } else {
        if (errorCallback === null) {
          _ptr.getDirectory(_unwrap(path), _unwrap(flags), _unwrap(successCallback));
          return;
        } else {
          _ptr.getDirectory(_unwrap(path), _unwrap(flags), _unwrap(successCallback), _unwrap(errorCallback));
          return;
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void getFile(String path, [Object flags = null, EntryCallback successCallback = null, ErrorCallback errorCallback = null]) {
    if (flags === null) {
      if (successCallback === null) {
        if (errorCallback === null) {
          _ptr.getFile(_unwrap(path));
          return;
        }
      }
    } else {
      if (successCallback === null) {
        if (errorCallback === null) {
          _ptr.getFile(_unwrap(path), _unwrap(flags));
          return;
        }
      } else {
        if (errorCallback === null) {
          _ptr.getFile(_unwrap(path), _unwrap(flags), _unwrap(successCallback));
          return;
        } else {
          _ptr.getFile(_unwrap(path), _unwrap(flags), _unwrap(successCallback), _unwrap(errorCallback));
          return;
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void removeRecursively(VoidCallback successCallback, [ErrorCallback errorCallback = null]) {
    if (errorCallback === null) {
      _ptr.removeRecursively(_unwrap(successCallback));
      return;
    } else {
      _ptr.removeRecursively(_unwrap(successCallback), _unwrap(errorCallback));
      return;
    }
  }
}

class _DirectoryEntrySyncImpl extends _EntrySyncImpl implements DirectoryEntrySync {
  _DirectoryEntrySyncImpl._wrap(ptr) : super._wrap(ptr);

  DirectoryReaderSync createReader() {
    return _wrap(_ptr.createReader());
  }

  DirectoryEntrySync getDirectory(String path, Object flags) {
    return _wrap(_ptr.getDirectory(_unwrap(path), _unwrap(flags)));
  }

  FileEntrySync getFile(String path, Object flags) {
    return _wrap(_ptr.getFile(_unwrap(path), _unwrap(flags)));
  }

  void removeRecursively() {
    _ptr.removeRecursively();
    return;
  }
}

class _DirectoryReaderImpl extends _DOMTypeBase implements DirectoryReader {
  _DirectoryReaderImpl._wrap(ptr) : super._wrap(ptr);

  void readEntries(EntriesCallback successCallback, [ErrorCallback errorCallback = null]) {
    if (errorCallback === null) {
      _ptr.readEntries(_unwrap(successCallback));
      return;
    } else {
      _ptr.readEntries(_unwrap(successCallback), _unwrap(errorCallback));
      return;
    }
  }
}

class _DirectoryReaderSyncImpl extends _DOMTypeBase implements DirectoryReaderSync {
  _DirectoryReaderSyncImpl._wrap(ptr) : super._wrap(ptr);

  EntryArraySync readEntries() {
    return _wrap(_ptr.readEntries());
  }
}

class _DivElementImpl extends _ElementImpl implements DivElement {
  _DivElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _DocumentImpl extends _NodeImpl
    implements Document
    {

  _DocumentImpl._wrap(ptr) : super._wrap(ptr);

  _DocumentEventsImpl get on() {
    if (_on == null) _on = new _DocumentEventsImpl(this);
    return _on;
  }

  Element get activeElement() => _wrap(_ptr.activeElement);

  Element get body() => _wrap(_ptr.body);

  void set body(Element value) { _ptr.body = _unwrap(value); }

  String get charset() => _wrap(_ptr.charset);

  void set charset(String value) { _ptr.charset = _unwrap(value); }

  String get cookie() => _wrap(_ptr.cookie);

  void set cookie(String value) { _ptr.cookie = _unwrap(value); }

  Window get window() => _wrap(_ptr.defaultView);

  Element get documentElement() => _wrap(_ptr.documentElement);

  String get domain() => _wrap(_ptr.domain);

  HeadElement get head() => _wrap(_ptr.head);

  String get lastModified() => _wrap(_ptr.lastModified);

  String get preferredStylesheetSet() => _wrap(_ptr.preferredStylesheetSet);

  String get readyState() => _wrap(_ptr.readyState);

  String get referrer() => _wrap(_ptr.referrer);

  String get selectedStylesheetSet() => _wrap(_ptr.selectedStylesheetSet);

  void set selectedStylesheetSet(String value) { _ptr.selectedStylesheetSet = _unwrap(value); }

  StyleSheetList get styleSheets() => _wrap(_ptr.styleSheets);

  String get title() => _wrap(_ptr.title);

  void set title(String value) { _ptr.title = _unwrap(value); }

  Element get webkitCurrentFullScreenElement() => _wrap(_ptr.webkitCurrentFullScreenElement);

  bool get webkitFullScreenKeyboardInputAllowed() => _wrap(_ptr.webkitFullScreenKeyboardInputAllowed);

  Element get webkitFullscreenElement() => _wrap(_ptr.webkitFullscreenElement);

  bool get webkitFullscreenEnabled() => _wrap(_ptr.webkitFullscreenEnabled);

  bool get webkitHidden() => _wrap(_ptr.webkitHidden);

  bool get webkitIsFullScreen() => _wrap(_ptr.webkitIsFullScreen);

  String get webkitVisibilityState() => _wrap(_ptr.webkitVisibilityState);

  Range caretRangeFromPoint(int x, int y) {
    return _wrap(_ptr.caretRangeFromPoint(_unwrap(x), _unwrap(y)));
  }

  CDATASection createCDATASection(String data) {
    return _wrap(_ptr.createCDATASection(_unwrap(data)));
  }

  DocumentFragment createDocumentFragment() {
    return _wrap(_ptr.createDocumentFragment());
  }

  Element $dom_createElement(String tagName) {
    return _wrap(_ptr.createElement(_unwrap(tagName)));
  }

  Element $dom_createElementNS(String namespaceURI, String qualifiedName) {
    return _wrap(_ptr.createElementNS(_unwrap(namespaceURI), _unwrap(qualifiedName)));
  }

  Event $dom_createEvent(String eventType) {
    return _wrap(_ptr.createEvent(_unwrap(eventType)));
  }

  Range createRange() {
    return _wrap(_ptr.createRange());
  }

  Text $dom_createTextNode(String data) {
    return _wrap(_ptr.createTextNode(_unwrap(data)));
  }

  Touch createTouch(Window window, EventTarget target, int identifier, int pageX, int pageY, int screenX, int screenY, int webkitRadiusX, int webkitRadiusY, num webkitRotationAngle, num webkitForce) {
    return _wrap(_ptr.createTouch(_unwrap(window), _unwrap(target), _unwrap(identifier), _unwrap(pageX), _unwrap(pageY), _unwrap(screenX), _unwrap(screenY), _unwrap(webkitRadiusX), _unwrap(webkitRadiusY), _unwrap(webkitRotationAngle), _unwrap(webkitForce)));
  }

  TouchList $dom_createTouchList() {
    return _wrap(_ptr.createTouchList());
  }

  Element elementFromPoint(int x, int y) {
    return _wrap(_ptr.elementFromPoint(_unwrap(x), _unwrap(y)));
  }

  bool execCommand(String command, bool userInterface, String value) {
    return _wrap(_ptr.execCommand(_unwrap(command), _unwrap(userInterface), _unwrap(value)));
  }

  CanvasRenderingContext getCSSCanvasContext(String contextId, String name, int width, int height) {
    return _wrap(_ptr.getCSSCanvasContext(_unwrap(contextId), _unwrap(name), _unwrap(width), _unwrap(height)));
  }

  Element $dom_getElementById(String elementId) {
    return _wrap(_ptr.getElementById(_unwrap(elementId)));
  }

  NodeList $dom_getElementsByClassName(String tagname) {
    return _wrap(_ptr.getElementsByClassName(_unwrap(tagname)));
  }

  NodeList $dom_getElementsByName(String elementName) {
    return _wrap(_ptr.getElementsByName(_unwrap(elementName)));
  }

  NodeList $dom_getElementsByTagName(String tagname) {
    return _wrap(_ptr.getElementsByTagName(_unwrap(tagname)));
  }

  bool queryCommandEnabled(String command) {
    return _wrap(_ptr.queryCommandEnabled(_unwrap(command)));
  }

  bool queryCommandIndeterm(String command) {
    return _wrap(_ptr.queryCommandIndeterm(_unwrap(command)));
  }

  bool queryCommandState(String command) {
    return _wrap(_ptr.queryCommandState(_unwrap(command)));
  }

  bool queryCommandSupported(String command) {
    return _wrap(_ptr.queryCommandSupported(_unwrap(command)));
  }

  String queryCommandValue(String command) {
    return _wrap(_ptr.queryCommandValue(_unwrap(command)));
  }

  Element _query(String selectors) {
    return _wrap(_ptr.querySelector(_unwrap(selectors)));
  }

  NodeList $dom_querySelectorAll(String selectors) {
    return _wrap(_ptr.querySelectorAll(_unwrap(selectors)));
  }

  void webkitCancelFullScreen() {
    _ptr.webkitCancelFullScreen();
    return;
  }

  void webkitExitFullscreen() {
    _ptr.webkitExitFullscreen();
    return;
  }

  WebKitNamedFlow webkitGetFlowByName(String name) {
    return _wrap(_ptr.webkitGetFlowByName(_unwrap(name)));
  }

  // TODO(jacobr): implement all Element methods not on Document. 

  _ElementImpl query(String selectors) {
    // It is fine for our RegExp to detect element id query selectors to have
    // false negatives but not false positives.
    if (const RegExp("^#[_a-zA-Z]\\w*\$").hasMatch(selectors)) {
      return $dom_getElementById(selectors.substring(1));
    }
    return $dom_querySelector(selectors);
  }

// TODO(jacobr): autogenerate this method.
  _ElementImpl $dom_querySelector(String selectors) =>
      _wrap(_ptr.querySelector(selectors));

  ElementList queryAll(String selectors) {
    if (const RegExp("""^\\[name=["'][^'"]+['"]\\]\$""").hasMatch(selectors)) {
      final mutableMatches = $dom_getElementsByName(
          selectors.substring(7,selectors.length - 2));
      int len = mutableMatches.length;
      final copyOfMatches = new List<Element>(len);
      for (int i = 0; i < len; ++i) {
        copyOfMatches[i] = mutableMatches[i];
      }
      return new _FrozenElementList._wrap(copyOfMatches);
    } else if (const RegExp("^[*a-zA-Z0-9]+\$").hasMatch(selectors)) {
      final mutableMatches = $dom_getElementsByTagName(selectors);
      int len = mutableMatches.length;
      final copyOfMatches = new List<Element>(len);
      for (int i = 0; i < len; ++i) {
        copyOfMatches[i] = mutableMatches[i];
      }
      return new _FrozenElementList._wrap(copyOfMatches);
    } else {
      return new _FrozenElementList._wrap($dom_querySelectorAll(selectors));
    }
  }
}

class _DocumentEventsImpl extends _ElementEventsImpl implements DocumentEvents {
  _DocumentEventsImpl(_ptr) : super(_ptr);

  EventListenerList get abort() => _get('abort');

  EventListenerList get beforeCopy() => _get('beforecopy');

  EventListenerList get beforeCut() => _get('beforecut');

  EventListenerList get beforePaste() => _get('beforepaste');

  EventListenerList get blur() => _get('blur');

  EventListenerList get change() => _get('change');

  EventListenerList get click() => _get('click');

  EventListenerList get contextMenu() => _get('contextmenu');

  EventListenerList get copy() => _get('copy');

  EventListenerList get cut() => _get('cut');

  EventListenerList get doubleClick() => _get('dblclick');

  EventListenerList get drag() => _get('drag');

  EventListenerList get dragEnd() => _get('dragend');

  EventListenerList get dragEnter() => _get('dragenter');

  EventListenerList get dragLeave() => _get('dragleave');

  EventListenerList get dragOver() => _get('dragover');

  EventListenerList get dragStart() => _get('dragstart');

  EventListenerList get drop() => _get('drop');

  EventListenerList get error() => _get('error');

  EventListenerList get focus() => _get('focus');

  EventListenerList get fullscreenChange() => _get('webkitfullscreenchange');

  EventListenerList get fullscreenError() => _get('webkitfullscreenerror');

  EventListenerList get input() => _get('input');

  EventListenerList get invalid() => _get('invalid');

  EventListenerList get keyDown() => _get('keydown');

  EventListenerList get keyPress() => _get('keypress');

  EventListenerList get keyUp() => _get('keyup');

  EventListenerList get load() => _get('load');

  EventListenerList get mouseDown() => _get('mousedown');

  EventListenerList get mouseMove() => _get('mousemove');

  EventListenerList get mouseOut() => _get('mouseout');

  EventListenerList get mouseOver() => _get('mouseover');

  EventListenerList get mouseUp() => _get('mouseup');

  EventListenerList get mouseWheel() => _get('mousewheel');

  EventListenerList get paste() => _get('paste');

  EventListenerList get readyStateChange() => _get('readystatechange');

  EventListenerList get reset() => _get('reset');

  EventListenerList get scroll() => _get('scroll');

  EventListenerList get search() => _get('search');

  EventListenerList get select() => _get('select');

  EventListenerList get selectStart() => _get('selectstart');

  EventListenerList get selectionChange() => _get('selectionchange');

  EventListenerList get submit() => _get('submit');

  EventListenerList get touchCancel() => _get('touchcancel');

  EventListenerList get touchEnd() => _get('touchend');

  EventListenerList get touchMove() => _get('touchmove');

  EventListenerList get touchStart() => _get('touchstart');
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class FilteredElementList implements ElementList {
  final Node _node;
  final NodeList _childNodes;

  FilteredElementList(Node node): _childNodes = node.nodes, _node = node;

  // We can't memoize this, since it's possible that children will be messed
  // with externally to this class.
  //
  // TODO(nweiz): Do we really need to copy the list to make the types work out?
  List<Element> get _filtered() =>
    new List.from(_childNodes.filter((n) => n is Element));

  // Don't use _filtered.first so we can short-circuit once we find an element.
  Element get first() {
    for (final node in _childNodes) {
      if (node is Element) {
        return node;
      }
    }
    return null;
  }

  void forEach(void f(Element element)) {
    _filtered.forEach(f);
  }

  void operator []=(int index, Element value) {
    this[index].replaceWith(value);
  }

  void set length(int newLength) {
    final len = this.length;
    if (newLength >= len) {
      return;
    } else if (newLength < 0) {
      throw const IllegalArgumentException("Invalid list length");
    }

    removeRange(newLength - 1, len - newLength);
  }

  void add(Element value) {
    _childNodes.add(value);
  }

  void addAll(Collection<Element> collection) {
    collection.forEach(add);
  }

  void addLast(Element value) {
    add(value);
  }

  void sort(int compare(Element a, Element b)) {
    throw const UnsupportedOperationException('TODO(jacobr): should we impl?');
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw const NotImplementedException();
  }

  void setRange(int start, int rangeLength, List from, [int startFrom = 0]) {
    throw const NotImplementedException();
  }

  void removeRange(int start, int rangeLength) {
    _filtered.getRange(start, rangeLength).forEach((el) => el.remove());
  }

  void insertRange(int start, int rangeLength, [initialValue = null]) {
    throw const NotImplementedException();
  }

  void clear() {
    // Currently, ElementList#clear clears even non-element nodes, so we follow
    // that behavior.
    _childNodes.clear();
  }

  Element removeLast() {
    final result = this.last();
    if (result != null) {
      result.remove();
    }
    return result;
  }

  Collection map(f(Element element)) => _filtered.map(f);
  Collection<Element> filter(bool f(Element element)) => _filtered.filter(f);
  bool every(bool f(Element element)) => _filtered.every(f);
  bool some(bool f(Element element)) => _filtered.some(f);
  bool isEmpty() => _filtered.isEmpty();
  int get length() => _filtered.length;
  Element operator [](int index) => _filtered[index];
  Iterator<Element> iterator() => _filtered.iterator();
  List<Element> getRange(int start, int rangeLength) =>
    _filtered.getRange(start, rangeLength);
  int indexOf(Element element, [int start = 0]) =>
    _filtered.indexOf(element, start);

  int lastIndexOf(Element element, [int start = null]) {
    if (start === null) start = length - 1;
    return _filtered.lastIndexOf(element, start);
  }

  Element last() => _filtered.last();
}

Future<CSSStyleDeclaration> _emptyStyleFuture() {
  return _createMeasurementFuture(() => new Element.tag('div').style,
                                  new Completer<CSSStyleDeclaration>());
}

class EmptyElementRect implements ElementRect {
  final ClientRect client = const _SimpleClientRect(0, 0, 0, 0);
  final ClientRect offset = const _SimpleClientRect(0, 0, 0, 0);
  final ClientRect scroll = const _SimpleClientRect(0, 0, 0, 0);
  final ClientRect bounding = const _SimpleClientRect(0, 0, 0, 0);
  final List<ClientRect> clientRects = const <ClientRect>[];

  const EmptyElementRect();
}

class _DocumentFragmentImpl extends _NodeImpl implements DocumentFragment {
  ElementList _elements;

  ElementList get elements() {
    if (_elements == null) {
      _elements = new FilteredElementList(this);
    }
    return _elements;
  }

  // TODO: The type of value should be Collection<Element>. See http://b/5392897
  void set elements(value) {
    // Copy list first since we don't want liveness during iteration.
    List copy = new List.from(value);
    final elements = this.elements;
    elements.clear();
    elements.addAll(copy);
  }

  ElementList queryAll(String selectors) =>
    new _FrozenElementList._wrap($dom_querySelectorAll(selectors));

  String get innerHTML() {
    final e = new Element.tag("div");
    e.nodes.add(this.clone(true));
    return e.innerHTML;
  }

  String get outerHTML() => innerHTML;

  // TODO(nweiz): Do we want to support some variant of innerHTML for XML and/or
  // SVG strings?
  void set innerHTML(String value) {
    this.nodes.clear();

    final e = new Element.tag("div");
    e.innerHTML = value;

    // Copy list first since we don't want liveness during iteration.
    List nodes = new List.from(e.nodes);
    this.nodes.addAll(nodes);
  }

  Node _insertAdjacentNode(String where, Node node) {
    switch (where.toLowerCase()) {
      case "beforebegin": return null;
      case "afterend": return null;
      case "afterbegin":
        this.insertBefore(node, this.nodes.first);
        return node;
      case "beforeend":
        this.nodes.add(node);
        return node;
      default:
        throw new IllegalArgumentException("Invalid position ${where}");
    }
  }

  Element insertAdjacentElement(String where, Element element)
    => this._insertAdjacentNode(where, element);

  void insertAdjacentText(String where, String text) {
    this._insertAdjacentNode(where, new Text(text));
  }

  void insertAdjacentHTML(String where, String text) {
    this._insertAdjacentNode(where, new DocumentFragment.html(text));
  }

  Future<ElementRect> get rect() {
    return _createMeasurementFuture(() => const EmptyElementRect(),
                                    new Completer<ElementRect>());
  }

  // If we can come up with a semi-reasonable default value for an Element
  // getter, we'll use it. In general, these return the same values as an
  // element that has no parent.
  String get contentEditable() => "false";
  bool get isContentEditable() => false;
  bool get draggable() => false;
  bool get hidden() => false;
  bool get spellcheck() => false;
  bool get translate() => false;
  int get tabIndex() => -1;
  String get id() => "";
  String get title() => "";
  String get tagName() => "";
  String get webkitdropzone() => "";
  String get webkitRegionOverflow() => "";
  Element get $dom_firstElementChild() => elements.first();
  Element get $dom_lastElementChild() => elements.last();
  Element get nextElementSibling() => null;
  Element get previousElementSibling() => null;
  Element get offsetParent() => null;
  Element get parent() => null;
  Map<String, String> get attributes() => const {};
  // Issue 174: this should be a const set.
  Set<String> get classes() => new Set<String>();
  Map<String, String> get dataAttributes() => const {};
  CSSStyleDeclaration get style() => new Element.tag('div').style;
  Future<CSSStyleDeclaration> get computedStyle() =>
      _emptyStyleFuture();
  Future<CSSStyleDeclaration> getComputedStyle(String pseudoElement) =>
      _emptyStyleFuture();
  bool matchesSelector(String selectors) => false;

  // Imperative Element methods are made into no-ops, as they are on parentless
  // elements.
  void blur() {}
  void focus() {}
  void click() {}
  void scrollByLines(int lines) {}
  void scrollByPages(int pages) {}
  void scrollIntoView([bool centerIfNeeded]) {}
  void webkitRequestFullScreen(int flags) {}
  void webkitRequestFullscreen() {}

  // Setters throw errors rather than being no-ops because we aren't going to
  // retain the values that were set, and erroring out seems clearer.
  void set attributes(Map<String, String> value) {
    throw new UnsupportedOperationException(
      "Attributes can't be set for document fragments.");
  }

  void set classes(Collection<String> value) {
    throw new UnsupportedOperationException(
      "Classes can't be set for document fragments.");
  }

  void set dataAttributes(Map<String, String> value) {
    throw new UnsupportedOperationException(
      "Data attributes can't be set for document fragments.");
  }

  void set contentEditable(String value) {
    throw new UnsupportedOperationException(
      "Content editable can't be set for document fragments.");
  }

  String get dir() {
    throw new UnsupportedOperationException(
      "Document fragments don't support text direction.");
  }

  void set dir(String value) {
    throw new UnsupportedOperationException(
      "Document fragments don't support text direction.");
  }

  void set draggable(bool value) {
    throw new UnsupportedOperationException(
      "Draggable can't be set for document fragments.");
  }

  void set hidden(bool value) {
    throw new UnsupportedOperationException(
      "Hidden can't be set for document fragments.");
  }

  void set id(String value) {
    throw new UnsupportedOperationException(
      "ID can't be set for document fragments.");
  }

  String get lang() {
    throw new UnsupportedOperationException(
      "Document fragments don't support language.");
  }

  void set lang(String value) {
    throw new UnsupportedOperationException(
      "Document fragments don't support language.");
  }

  void set scrollLeft(int value) {
    throw new UnsupportedOperationException(
      "Document fragments don't support scrolling.");
  }

  void set scrollTop(int value) {
    throw new UnsupportedOperationException(
      "Document fragments don't support scrolling.");
  }

  void set spellcheck(bool value) {
     throw new UnsupportedOperationException(
      "Spellcheck can't be set for document fragments.");
  }

  void set translate(bool value) {
     throw new UnsupportedOperationException(
      "Spellcheck can't be set for document fragments.");
  }

  void set tabIndex(int value) {
    throw new UnsupportedOperationException(
      "Tab index can't be set for document fragments.");
  }

  void set title(String value) {
    throw new UnsupportedOperationException(
      "Title can't be set for document fragments.");
  }

  void set webkitdropzone(String value) {
    throw new UnsupportedOperationException(
      "WebKit drop zone can't be set for document fragments.");
  }

  void set webkitRegionOverflow(String value) {
    throw new UnsupportedOperationException(
      "WebKit region overflow can't be set for document fragments.");
  }

  _DocumentFragmentImpl._wrap(ptr) : super._wrap(ptr);

  _ElementEventsImpl get on() {
    if (_on == null) _on = new _ElementEventsImpl(this);
    return _on;
  }

  Element query(String selectors) {
    return _wrap(_ptr.querySelector(_unwrap(selectors)));
  }

  NodeList $dom_querySelectorAll(String selectors) {
    return _wrap(_ptr.querySelectorAll(_unwrap(selectors)));
  }

}

class _DocumentTypeImpl extends _NodeImpl implements DocumentType {
  _DocumentTypeImpl._wrap(ptr) : super._wrap(ptr);

  NamedNodeMap get entities() => _wrap(_ptr.entities);

  String get internalSubset() => _wrap(_ptr.internalSubset);

  String get name() => _wrap(_ptr.name);

  NamedNodeMap get notations() => _wrap(_ptr.notations);

  String get publicId() => _wrap(_ptr.publicId);

  String get systemId() => _wrap(_ptr.systemId);
}

class _DynamicsCompressorNodeImpl extends _AudioNodeImpl implements DynamicsCompressorNode {
  _DynamicsCompressorNodeImpl._wrap(ptr) : super._wrap(ptr);

  AudioParam get attack() => _wrap(_ptr.attack);

  AudioParam get knee() => _wrap(_ptr.knee);

  AudioParam get ratio() => _wrap(_ptr.ratio);

  AudioParam get reduction() => _wrap(_ptr.reduction);

  AudioParam get release() => _wrap(_ptr.release);

  AudioParam get threshold() => _wrap(_ptr.threshold);
}

class _EXTTextureFilterAnisotropicImpl extends _DOMTypeBase implements EXTTextureFilterAnisotropic {
  _EXTTextureFilterAnisotropicImpl._wrap(ptr) : super._wrap(ptr);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// TODO(jacobr): use _Lists.dart to remove some of the duplicated
// functionality.
class _ChildrenElementList implements ElementList {
  // Raw Element.
  final _ElementImpl _element;
  final _HTMLCollectionImpl _childElements;

  _ChildrenElementList._wrap(_ElementImpl element)
    : _childElements = element.$dom_children,
      _element = element;

  List<Element> _toList() {
    final output = new List(_childElements.length);
    for (int i = 0, len = _childElements.length; i < len; i++) {
      output[i] = _childElements[i];
    }
    return output;
  }

  _ElementImpl get first() {
    return _element.$dom_firstElementChild;
  }

  void forEach(void f(Element element)) {
    for (_ElementImpl element in _childElements) {
      f(element);
    }
  }

  ElementList filter(bool f(Element element)) {
    final output = <Element>[];
    forEach((Element element) {
      if (f(element)) {
        output.add(element);
      }
    });
    return new _FrozenElementList._wrap(output);
  }

  bool every(bool f(Element element)) {
    for(Element element in this) {
      if (!f(element)) {
        return false;
      }
    };
    return true;
  }

  bool some(bool f(Element element)) {
    for(Element element in this) {
      if (f(element)) {
        return true;
      }
    };
    return false;
  }

  Collection map(f(Element element)) {
    final out = [];
    for (Element el in this) {
      out.add(f(el));
    }
    return out;
  }

  bool isEmpty() {
    return _element.$dom_firstElementChild == null;
  }

  int get length() {
    return _childElements.length;
  }

  _ElementImpl operator [](int index) {
    return _childElements[index];
  }

  void operator []=(int index, _ElementImpl value) {
    _element.$dom_replaceChild(value, _childElements[index]);
  }

   void set length(int newLength) {
     // TODO(jacobr): remove children when length is reduced.
     throw const UnsupportedOperationException('');
   }

  Element add(_ElementImpl value) {
    _element.$dom_appendChild(value);
    return value;
  }

  Element addLast(_ElementImpl value) => add(value);

  Iterator<Element> iterator() => _toList().iterator();

  void addAll(Collection<Element> collection) {
    for (_ElementImpl element in collection) {
      _element.$dom_appendChild(element);
    }
  }

  void sort(int compare(Element a, Element b)) {
    throw const UnsupportedOperationException('TODO(jacobr): should we impl?');
  }

  void copyFrom(List<Object> src, int srcStart, int dstStart, int count) {
    throw 'Not impl yet. todo(jacobr)';
  }

  void setRange(int start, int rangeLength, List from, [int startFrom = 0]) {
    throw const NotImplementedException();
  }

  void removeRange(int start, int rangeLength) {
    throw const NotImplementedException();
  }

  void insertRange(int start, int rangeLength, [initialValue = null]) {
    throw const NotImplementedException();
  }

  List getRange(int start, int rangeLength) =>
    new _FrozenElementList._wrap(_Lists.getRange(this, start, rangeLength,
        <Element>[]));

  int indexOf(Element element, [int start = 0]) {
    return _Lists.indexOf(this, element, start, this.length);
  }

  int lastIndexOf(Element element, [int start = null]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  void clear() {
    // It is unclear if we want to keep non element nodes?
    _element.text = '';
  }

  Element removeLast() {
    final result = this.last();
    if (result != null) {
      _element.$dom_removeChild(result);
    }
    return result;
  }

  Element last() {
    return _element.$dom_lastElementChild;
  }
}

// TODO(jacobr): this is an inefficient implementation but it is hard to see
// a better option given that we cannot quite force NodeList to be an
// ElementList as there are valid cases where a NodeList JavaScript object
// contains Node objects that are not Elements.
class _FrozenElementList implements ElementList {
  final List<Node> _nodeList;

  _FrozenElementList._wrap(this._nodeList);

  Element get first() {
    return _nodeList[0];
  }

  void forEach(void f(Element element)) {
    for (Element el in this) {
      f(el);
    }
  }

  Collection map(f(Element element)) {
    final out = [];
    for (Element el in this) {
      out.add(f(el));
    }
    return out;
  }

  ElementList filter(bool f(Element element)) {
    final out = new _ElementList([]);
    for (Element el in this) {
      if (f(el)) out.add(el);
    }
    return out;
  }

  bool every(bool f(Element element)) {
    for(Element element in this) {
      if (!f(element)) {
        return false;
      }
    };
    return true;
  }

  bool some(bool f(Element element)) {
    for(Element element in this) {
      if (f(element)) {
        return true;
      }
    };
    return false;
  }

  bool isEmpty() => _nodeList.isEmpty();

  int get length() => _nodeList.length;

  Element operator [](int index) => _nodeList[index];

  void operator []=(int index, Element value) {
    throw const UnsupportedOperationException('');
  }

  void set length(int newLength) {
    _nodeList.length = newLength;
  }

  void add(Element value) {
    throw const UnsupportedOperationException('');
  }

  void addLast(Element value) {
    throw const UnsupportedOperationException('');
  }

  Iterator<Element> iterator() => new _FrozenElementListIterator(this);

  void addAll(Collection<Element> collection) {
    throw const UnsupportedOperationException('');
  }

  void sort(int compare(Element a, Element b)) {
    throw const UnsupportedOperationException('');
  }

  void setRange(int start, int rangeLength, List from, [int startFrom = 0]) {
    throw const UnsupportedOperationException('');
  }

  void removeRange(int start, int rangeLength) {
    throw const UnsupportedOperationException('');
  }

  void insertRange(int start, int rangeLength, [initialValue = null]) {
    throw const UnsupportedOperationException('');
  }

  ElementList getRange(int start, int rangeLength) =>
    new _FrozenElementList._wrap(_nodeList.getRange(start, rangeLength));

  int indexOf(Element element, [int start = 0]) =>
    _nodeList.indexOf(element, start);

  int lastIndexOf(Element element, [int start = null]) =>
    _nodeList.lastIndexOf(element, start);

  void clear() {
    throw const UnsupportedOperationException('');
  }

  Element removeLast() {
    throw const UnsupportedOperationException('');
  }

  Element last() => _nodeList.last();
}

class _FrozenElementListIterator implements Iterator<Element> {
  final _FrozenElementList _list;
  int _index = 0;

  _FrozenElementListIterator(this._list);

  /**
   * Gets the next element in the iteration. Throws a
   * [NoMoreElementsException] if no element is left.
   */
  Element next() {
    if (!hasNext()) {
      throw const NoMoreElementsException();
    }

    return _list[_index++];
  }

  /**
   * Returns whether the [Iterator] has elements left.
   */
  bool hasNext() => _index < _list.length;
}

class _ElementList extends _ListWrapper<Element> implements ElementList {
  _ElementList(List<Element> list) : super(list);

  ElementList filter(bool f(Element element)) =>
    new _ElementList(super.filter(f));

  ElementList getRange(int start, int rangeLength) =>
    new _ElementList(super.getRange(start, rangeLength));
}

class _ElementAttributeMap implements AttributeMap {

  final _ElementImpl _element;

  _ElementAttributeMap(this._element);

  bool containsValue(String value) {
    final attributes = _element.$dom_attributes;
    for (int i = 0, len = attributes.length; i < len; i++) {
      if(value == attributes[i].value) {
        return true;
      }
    }
    return false;
  }

  bool containsKey(String key) {
    return _element.$dom_hasAttribute(key);
  }

  String operator [](String key) {
    return _element.$dom_getAttribute(key);
  }

  void operator []=(String key, value) {
    _element.$dom_setAttribute(key, '$value');
  }

  String putIfAbsent(String key, String ifAbsent()) {
    if (!containsKey(key)) {
      this[key] = ifAbsent();
    }
    return this[key];
  }

  String remove(String key) {
    String value = _element.$dom_getAttribute(key);
    _element.$dom_removeAttribute(key);
    return value;
  }

  void clear() {
    final attributes = _element.$dom_attributes;
    for (int i = attributes.length - 1; i >= 0; i--) {
      remove(attributes[i].name);
    }
  }

  void forEach(void f(String key, String value)) {
    final attributes = _element.$dom_attributes;
    for (int i = 0, len = attributes.length; i < len; i++) {
      final item = attributes[i];
      f(item.name, item.value);
    }
  }

  Collection<String> getKeys() {
    // TODO(jacobr): generate a lazy collection instead.
    final attributes = _element.$dom_attributes;
    final keys = new List<String>(attributes.length);
    for (int i = 0, len = attributes.length; i < len; i++) {
      keys[i] = attributes[i].name;
    }
    return keys;
  }

  Collection<String> getValues() {
    // TODO(jacobr): generate a lazy collection instead.
    final attributes = _element.$dom_attributes;
    final values = new List<String>(attributes.length);
    for (int i = 0, len = attributes.length; i < len; i++) {
      values[i] = attributes[i].value;
    }
    return values;
  }

  /**
   * The number of {key, value} pairs in the map.
   */
  int get length() {
    return _element.$dom_attributes.length;
  }

  /**
   * Returns true if there is no {key, value} pair in the map.
   */
  bool isEmpty() {
    return length == 0;
  }
}

/**
 * Provides a Map abstraction on top of data-* attributes, similar to the
 * dataSet in the old DOM.
 */
class _DataAttributeMap implements AttributeMap {

  final Map<String, String> $dom_attributes;

  _DataAttributeMap(this.$dom_attributes);

  // interface Map

  // TODO: Use lazy iterator when it is available on Map.
  bool containsValue(String value) => getValues().some((v) => v == value);

  bool containsKey(String key) => $dom_attributes.containsKey(_attr(key));

  String operator [](String key) => $dom_attributes[_attr(key)];

  void operator []=(String key, value) {
    $dom_attributes[_attr(key)] = '$value';
  }

  String putIfAbsent(String key, String ifAbsent()) =>
    $dom_attributes.putIfAbsent(_attr(key), ifAbsent);

  String remove(String key) => $dom_attributes.remove(_attr(key));

  void clear() {
    // Needs to operate on a snapshot since we are mutating the collection.
    for (String key in getKeys()) {
      remove(key);
    }
  }

  void forEach(void f(String key, String value)) {
    $dom_attributes.forEach((String key, String value) {
      if (_matches(key)) {
        f(_strip(key), value);
      }
    });
  }

  Collection<String> getKeys() {
    final keys = new List<String>();
    $dom_attributes.forEach((String key, String value) {
      if (_matches(key)) {
        keys.add(_strip(key));
      }
    });
    return keys;
  }

  Collection<String> getValues() {
    final values = new List<String>();
    $dom_attributes.forEach((String key, String value) {
      if (_matches(key)) {
        values.add(value);
      }
    });
    return values;
  }

  int get length() => getKeys().length;

  // TODO: Use lazy iterator when it is available on Map.
  bool isEmpty() => length == 0;

  // Helpers.
  String _attr(String key) => 'data-$key';
  bool _matches(String key) => key.startsWith('data-');
  String _strip(String key) => key.substring(5);
}

class _CssClassSet implements Set<String> {

  final _ElementImpl _element;

  _CssClassSet(this._element);

  String toString() => _formatSet(_read());

  // interface Iterable - BEGIN
  Iterator<String> iterator() => _read().iterator();
  // interface Iterable - END

  // interface Collection - BEGIN
  void forEach(void f(String element)) {
    _read().forEach(f);
  }

  Collection map(f(String element)) => _read().map(f);

  Collection<String> filter(bool f(String element)) => _read().filter(f);

  bool every(bool f(String element)) => _read().every(f);

  bool some(bool f(String element)) => _read().some(f);

  bool isEmpty() => _read().isEmpty();

  int get length() =>_read().length;

  // interface Collection - END

  // interface Set - BEGIN
  bool contains(String value) => _read().contains(value);

  void add(String value) {
    // TODO - figure out if we need to do any validation here
    // or if the browser natively does enough
    _modify((s) => s.add(value));
  }

  bool remove(String value) {
    Set<String> s = _read();
    bool result = s.remove(value);
    _write(s);
    return result;
  }

  void addAll(Collection<String> collection) {
    // TODO - see comment above about validation
    _modify((s) => s.addAll(collection));
  }

  void removeAll(Collection<String> collection) {
    _modify((s) => s.removeAll(collection));
  }

  bool isSubsetOf(Collection<String> collection) =>
    _read().isSubsetOf(collection);

  bool containsAll(Collection<String> collection) =>
    _read().containsAll(collection);

  Set<String> intersection(Collection<String> other) =>
    _read().intersection(other);

  void clear() {
    _modify((s) => s.clear());
  }
  // interface Set - END

  /**
   * Helper method used to modify the set of css classes on this element.
   *
   *   f - callback with:
   *      s - a Set of all the css class name currently on this element.
   *
   *   After f returns, the modified set is written to the
   *       className property of this element.
   */
  void _modify( f(Set<String> s)) {
    Set<String> s = _read();
    f(s);
    _write(s);
  }

  /**
   * Read the class names from the Element class property,
   * and put them into a set (duplicates are discarded).
   */
  Set<String> _read() {
    // TODO(mattsh) simplify this once split can take regex.
    Set<String> s = new Set<String>();
    for (String name in _classname().split(' ')) {
      String trimmed = name.trim();
      if (!trimmed.isEmpty()) {
        s.add(trimmed);
      }
    }
    return s;
  }

  /**
   * Read the class names as a space-separated string. This is meant to be
   * overridden by subclasses.
   */
  String _classname() => _element.$dom_className;

  /**
   * Join all the elements of a set into one string and write
   * back to the element.
   */
  void _write(Set s) {
    _element.$dom_className = _formatSet(s);
  }

  String _formatSet(Set<String> s) {
    // TODO(mattsh) should be able to pass Set to String.joins http:/b/5398605
    List list = new List.from(s);
    return Strings.join(list, ' ');
  }
}

class _SimpleClientRect implements ClientRect {
  final num left;
  final num top;
  final num width;
  final num height;
  num get right() => left + width;
  num get bottom() => top + height;

  const _SimpleClientRect(this.left, this.top, this.width, this.height);

  bool operator ==(ClientRect other) {
    return other !== null && left == other.left && top == other.top
        && width == other.width && height == other.height;
  }

  String toString() => "($left, $top, $width, $height)";
}

// TODO(jacobr): we cannot currently be lazy about calculating the client
// rects as we must perform all measurement queries at a safe point to avoid
// triggering unneeded layouts.
/**
 * All your element measurement needs in one place
 * @domName none
 */
class _ElementRectImpl implements ElementRect {
  final ClientRect client;
  final ClientRect offset;
  final ClientRect scroll;

  // TODO(jacobr): should we move these outside of ElementRect to avoid the
  // overhead of computing them every time even though they are rarely used.
  final _ClientRectImpl _boundingClientRect; 
  final _ClientRectListImpl _clientRects;

  _ElementRectImpl(_ElementImpl element) :
    client = new _SimpleClientRect(element.$dom_clientLeft,
                                  element.$dom_clientTop,
                                  element.$dom_clientWidth, 
                                  element.$dom_clientHeight), 
    offset = new _SimpleClientRect(element.$dom_offsetLeft,
                                  element.$dom_offsetTop,
                                  element.$dom_offsetWidth,
                                  element.$dom_offsetHeight),
    scroll = new _SimpleClientRect(element.$dom_scrollLeft,
                                  element.$dom_scrollTop,
                                  element.$dom_scrollWidth,
                                  element.$dom_scrollHeight),
    _boundingClientRect = element.$dom_getBoundingClientRect(),
    _clientRects = element.$dom_getClientRects();

  _ClientRectImpl get bounding() => _boundingClientRect;

  // TODO(jacobr): cleanup.
  List<ClientRect> get clientRects() {
    final out = new List(_clientRects.length);
    for (num i = 0; i < _clientRects.length; i++) {
      out[i] = _clientRects.item(i);
    }
    return out;
  }
}

class _ElementImpl extends _NodeImpl implements Element {

  /**
   * @domName Element.hasAttribute, Element.getAttribute, Element.setAttribute,
   *   Element.removeAttribute
   */
  _ElementAttributeMap get attributes() => new _ElementAttributeMap(this);

  void set attributes(Map<String, String> value) {
    Map<String, String> attributes = this.attributes;
    attributes.clear();
    for (String key in value.getKeys()) {
      attributes[key] = value[key];
    }
  }

  void set elements(Collection<Element> value) {
    final elements = this.elements;
    elements.clear();
    elements.addAll(value);
  }

  ElementList get elements() => new _ChildrenElementList._wrap(this);

  ElementList queryAll(String selectors) =>
    new _FrozenElementList._wrap($dom_querySelectorAll(selectors));

  _CssClassSet get classes() => new _CssClassSet(this);

  void set classes(Collection<String> value) {
    _CssClassSet classSet = classes;
    classSet.clear();
    classSet.addAll(value);
  }

  Map<String, String> get dataAttributes() =>
    new _DataAttributeMap(attributes);

  void set dataAttributes(Map<String, String> value) {
    final dataAttributes = this.dataAttributes;
    dataAttributes.clear();
    for (String key in value.getKeys()) {
      dataAttributes[key] = value[key];
    }
  }

  Future<ElementRect> get rect() {
    return _createMeasurementFuture(
        () => new _ElementRectImpl(this),
        new Completer<ElementRect>());
  }

  Future<CSSStyleDeclaration> get computedStyle() {
     // TODO(jacobr): last param should be null, see b/5045788
     return getComputedStyle('');
  }

  Future<CSSStyleDeclaration> getComputedStyle(String pseudoElement) {
    return _createMeasurementFuture(
        () => _window.$dom_getComputedStyle(this, pseudoElement),
        new Completer<CSSStyleDeclaration>());
  }
  _ElementImpl._wrap(ptr) : super._wrap(ptr);

  _ElementEventsImpl get on() {
    if (_on == null) _on = new _ElementEventsImpl(this);
    return _on;
  }

  int get $dom_childElementCount() => _wrap(_ptr.childElementCount);

  HTMLCollection get $dom_children() => _wrap(_ptr.children);

  String get $dom_className() => _wrap(_ptr.className);

  void set $dom_className(String value) { _ptr.className = _unwrap(value); }

  int get $dom_clientHeight() => _wrap(_ptr.clientHeight);

  int get $dom_clientLeft() => _wrap(_ptr.clientLeft);

  int get $dom_clientTop() => _wrap(_ptr.clientTop);

  int get $dom_clientWidth() => _wrap(_ptr.clientWidth);

  String get contentEditable() => _wrap(_ptr.contentEditable);

  void set contentEditable(String value) { _ptr.contentEditable = _unwrap(value); }

  Map<String, String> get dataset() => _wrap(_ptr.dataset);

  String get dir() => _wrap(_ptr.dir);

  void set dir(String value) { _ptr.dir = _unwrap(value); }

  bool get draggable() => _wrap(_ptr.draggable);

  void set draggable(bool value) { _ptr.draggable = _unwrap(value); }

  Element get $dom_firstElementChild() => _wrap(_ptr.firstElementChild);

  bool get hidden() => _wrap(_ptr.hidden);

  void set hidden(bool value) { _ptr.hidden = _unwrap(value); }

  String get id() => _wrap(_ptr.id);

  void set id(String value) { _ptr.id = _unwrap(value); }

  String get innerHTML() => _wrap(_ptr.innerHTML);

  void set innerHTML(String value) { _ptr.innerHTML = _unwrap(value); }

  bool get isContentEditable() => _wrap(_ptr.isContentEditable);

  String get lang() => _wrap(_ptr.lang);

  void set lang(String value) { _ptr.lang = _unwrap(value); }

  Element get $dom_lastElementChild() => _wrap(_ptr.lastElementChild);

  Element get nextElementSibling() => _wrap(_ptr.nextElementSibling);

  int get $dom_offsetHeight() => _wrap(_ptr.offsetHeight);

  int get $dom_offsetLeft() => _wrap(_ptr.offsetLeft);

  Element get offsetParent() => _wrap(_ptr.offsetParent);

  int get $dom_offsetTop() => _wrap(_ptr.offsetTop);

  int get $dom_offsetWidth() => _wrap(_ptr.offsetWidth);

  String get outerHTML() => _wrap(_ptr.outerHTML);

  Element get previousElementSibling() => _wrap(_ptr.previousElementSibling);

  int get $dom_scrollHeight() => _wrap(_ptr.scrollHeight);

  int get $dom_scrollLeft() => _wrap(_ptr.scrollLeft);

  void set $dom_scrollLeft(int value) { _ptr.scrollLeft = _unwrap(value); }

  int get $dom_scrollTop() => _wrap(_ptr.scrollTop);

  void set $dom_scrollTop(int value) { _ptr.scrollTop = _unwrap(value); }

  int get $dom_scrollWidth() => _wrap(_ptr.scrollWidth);

  bool get spellcheck() => _wrap(_ptr.spellcheck);

  void set spellcheck(bool value) { _ptr.spellcheck = _unwrap(value); }

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  int get tabIndex() => _wrap(_ptr.tabIndex);

  void set tabIndex(int value) { _ptr.tabIndex = _unwrap(value); }

  String get tagName() => _wrap(_ptr.tagName);

  String get title() => _wrap(_ptr.title);

  void set title(String value) { _ptr.title = _unwrap(value); }

  bool get translate() => _wrap(_ptr.translate);

  void set translate(bool value) { _ptr.translate = _unwrap(value); }

  String get webkitRegionOverflow() => _wrap(_ptr.webkitRegionOverflow);

  String get webkitdropzone() => _wrap(_ptr.webkitdropzone);

  void set webkitdropzone(String value) { _ptr.webkitdropzone = _unwrap(value); }

  void blur() {
    _ptr.blur();
    return;
  }

  void click() {
    _ptr.click();
    return;
  }

  void focus() {
    _ptr.focus();
    return;
  }

  String $dom_getAttribute(String name) {
    return _wrap(_ptr.getAttribute(_unwrap(name)));
  }

  ClientRect $dom_getBoundingClientRect() {
    return _wrap(_ptr.getBoundingClientRect());
  }

  ClientRectList $dom_getClientRects() {
    return _wrap(_ptr.getClientRects());
  }

  NodeList $dom_getElementsByClassName(String name) {
    return _wrap(_ptr.getElementsByClassName(_unwrap(name)));
  }

  NodeList $dom_getElementsByTagName(String name) {
    return _wrap(_ptr.getElementsByTagName(_unwrap(name)));
  }

  bool $dom_hasAttribute(String name) {
    return _wrap(_ptr.hasAttribute(_unwrap(name)));
  }

  Element insertAdjacentElement(String where, Element element) {
    return _wrap(_ptr.insertAdjacentElement(_unwrap(where), _unwrap(element)));
  }

  void insertAdjacentHTML(String where, String html) {
    _ptr.insertAdjacentHTML(_unwrap(where), _unwrap(html));
    return;
  }

  void insertAdjacentText(String where, String text) {
    _ptr.insertAdjacentText(_unwrap(where), _unwrap(text));
    return;
  }

  Element query(String selectors) {
    return _wrap(_ptr.querySelector(_unwrap(selectors)));
  }

  NodeList $dom_querySelectorAll(String selectors) {
    return _wrap(_ptr.querySelectorAll(_unwrap(selectors)));
  }

  void $dom_removeAttribute(String name) {
    _ptr.removeAttribute(_unwrap(name));
    return;
  }

  void scrollByLines(int lines) {
    _ptr.scrollByLines(_unwrap(lines));
    return;
  }

  void scrollByPages(int pages) {
    _ptr.scrollByPages(_unwrap(pages));
    return;
  }

  void scrollIntoView([bool centerIfNeeded = null]) {
    if (centerIfNeeded === null) {
      _ptr.scrollIntoViewIfNeeded();
      return;
    } else {
      _ptr.scrollIntoViewIfNeeded(_unwrap(centerIfNeeded));
      return;
    }
  }

  void $dom_setAttribute(String name, String value) {
    _ptr.setAttribute(_unwrap(name), _unwrap(value));
    return;
  }

  bool matchesSelector(String selectors) {
    return _wrap(_ptr.webkitMatchesSelector(_unwrap(selectors)));
  }

  void webkitRequestFullScreen(int flags) {
    _ptr.webkitRequestFullScreen(_unwrap(flags));
    return;
  }

  void webkitRequestFullscreen() {
    _ptr.webkitRequestFullscreen();
    return;
  }

}

final _START_TAG_REGEXP = const RegExp('<(\\w+)');
class _ElementFactoryProvider {
  static final _CUSTOM_PARENT_TAG_MAP = const {
    'body' : 'html',
    'head' : 'html',
    'caption' : 'table',
    'td': 'tr',
    'colgroup': 'table',
    'col' : 'colgroup',
    'tr' : 'tbody',
    'tbody' : 'table',
    'tfoot' : 'table',
    'thead' : 'table',
    'track' : 'audio',
  };

  /** @domName Document.createElement */
  factory Element.html(String html) {
    // TODO(jacobr): this method can be made more robust and performant.
    // 1) Cache the dummy parent elements required to use innerHTML rather than
    //    creating them every call.
    // 2) Verify that the html does not contain leading or trailing text nodes.
    // 3) Verify that the html does not contain both <head> and <body> tags.
    // 4) Detatch the created element from its dummy parent.
    String parentTag = 'div';
    String tag;
    final match = _START_TAG_REGEXP.firstMatch(html);
    if (match !== null) {
      tag = match.group(1).toLowerCase();
      if (_CUSTOM_PARENT_TAG_MAP.containsKey(tag)) {
        parentTag = _CUSTOM_PARENT_TAG_MAP[tag];
      }
    }
    final _ElementImpl temp = new Element.tag(parentTag);
    temp.innerHTML = html;

    Element element;
    if (temp.elements.length == 1) {
      element = temp.elements.first;
    } else if (parentTag == 'html' && temp.elements.length == 2) {
      // Work around for edge case in WebKit and possibly other browsers where
      // both body and head elements are created even though the inner html
      // only contains a head or body element.
      element = temp.elements[tag == 'head' ? 0 : 1];
    } else {
      throw new IllegalArgumentException('HTML had ${temp.elements.length} ' +
          'top level elements but 1 expected');
    }
    element.remove();
    return element;
  }

  /** @domName Document.createElement */
  factory Element.tag(String tag) => _document.$dom_createElement(tag);
}

class _ElementEventsImpl extends _EventsImpl implements ElementEvents {
  _ElementEventsImpl(_ptr) : super(_ptr);

  EventListenerList get abort() => _get('abort');

  EventListenerList get beforeCopy() => _get('beforecopy');

  EventListenerList get beforeCut() => _get('beforecut');

  EventListenerList get beforePaste() => _get('beforepaste');

  EventListenerList get blur() => _get('blur');

  EventListenerList get change() => _get('change');

  EventListenerList get click() => _get('click');

  EventListenerList get contextMenu() => _get('contextmenu');

  EventListenerList get copy() => _get('copy');

  EventListenerList get cut() => _get('cut');

  EventListenerList get doubleClick() => _get('dblclick');

  EventListenerList get drag() => _get('drag');

  EventListenerList get dragEnd() => _get('dragend');

  EventListenerList get dragEnter() => _get('dragenter');

  EventListenerList get dragLeave() => _get('dragleave');

  EventListenerList get dragOver() => _get('dragover');

  EventListenerList get dragStart() => _get('dragstart');

  EventListenerList get drop() => _get('drop');

  EventListenerList get error() => _get('error');

  EventListenerList get focus() => _get('focus');

  EventListenerList get fullscreenChange() => _get('webkitfullscreenchange');

  EventListenerList get fullscreenError() => _get('webkitfullscreenerror');

  EventListenerList get input() => _get('input');

  EventListenerList get invalid() => _get('invalid');

  EventListenerList get keyDown() => _get('keydown');

  EventListenerList get keyPress() => _get('keypress');

  EventListenerList get keyUp() => _get('keyup');

  EventListenerList get load() => _get('load');

  EventListenerList get mouseDown() => _get('mousedown');

  EventListenerList get mouseMove() => _get('mousemove');

  EventListenerList get mouseOut() => _get('mouseout');

  EventListenerList get mouseOver() => _get('mouseover');

  EventListenerList get mouseUp() => _get('mouseup');

  EventListenerList get mouseWheel() => _get('mousewheel');

  EventListenerList get paste() => _get('paste');

  EventListenerList get reset() => _get('reset');

  EventListenerList get scroll() => _get('scroll');

  EventListenerList get search() => _get('search');

  EventListenerList get select() => _get('select');

  EventListenerList get selectStart() => _get('selectstart');

  EventListenerList get submit() => _get('submit');

  EventListenerList get touchCancel() => _get('touchcancel');

  EventListenerList get touchEnd() => _get('touchend');

  EventListenerList get touchEnter() => _get('touchenter');

  EventListenerList get touchLeave() => _get('touchleave');

  EventListenerList get touchMove() => _get('touchmove');

  EventListenerList get touchStart() => _get('touchstart');

  EventListenerList get transitionEnd() => _get('webkitTransitionEnd');
}

class _ElementTimeControlImpl extends _DOMTypeBase implements ElementTimeControl {
  _ElementTimeControlImpl._wrap(ptr) : super._wrap(ptr);

  void beginElement() {
    _ptr.beginElement();
    return;
  }

  void beginElementAt(num offset) {
    _ptr.beginElementAt(_unwrap(offset));
    return;
  }

  void endElement() {
    _ptr.endElement();
    return;
  }

  void endElementAt(num offset) {
    _ptr.endElementAt(_unwrap(offset));
    return;
  }
}

class _ElementTraversalImpl extends _DOMTypeBase implements ElementTraversal {
  _ElementTraversalImpl._wrap(ptr) : super._wrap(ptr);

  int get childElementCount() => _wrap(_ptr.childElementCount);

  Element get firstElementChild() => _wrap(_ptr.firstElementChild);

  Element get lastElementChild() => _wrap(_ptr.lastElementChild);

  Element get nextElementSibling() => _wrap(_ptr.nextElementSibling);

  Element get previousElementSibling() => _wrap(_ptr.previousElementSibling);
}

class _EmbedElementImpl extends _ElementImpl implements EmbedElement {
  _EmbedElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get height() => _wrap(_ptr.height);

  void set height(String value) { _ptr.height = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }
}

class _EntityImpl extends _NodeImpl implements Entity {
  _EntityImpl._wrap(ptr) : super._wrap(ptr);

  String get notationName() => _wrap(_ptr.notationName);

  String get publicId() => _wrap(_ptr.publicId);

  String get systemId() => _wrap(_ptr.systemId);
}

class _EntityReferenceImpl extends _NodeImpl implements EntityReference {
  _EntityReferenceImpl._wrap(ptr) : super._wrap(ptr);
}

class _EntryImpl extends _DOMTypeBase implements Entry {
  _EntryImpl._wrap(ptr) : super._wrap(ptr);

  DOMFileSystem get filesystem() => _wrap(_ptr.filesystem);

  String get fullPath() => _wrap(_ptr.fullPath);

  bool get isDirectory() => _wrap(_ptr.isDirectory);

  bool get isFile() => _wrap(_ptr.isFile);

  String get name() => _wrap(_ptr.name);

  void copyTo(DirectoryEntry parent, [String name = null, EntryCallback successCallback = null, ErrorCallback errorCallback = null]) {
    if (name === null) {
      if (successCallback === null) {
        if (errorCallback === null) {
          _ptr.copyTo(_unwrap(parent));
          return;
        }
      }
    } else {
      if (successCallback === null) {
        if (errorCallback === null) {
          _ptr.copyTo(_unwrap(parent), _unwrap(name));
          return;
        }
      } else {
        if (errorCallback === null) {
          _ptr.copyTo(_unwrap(parent), _unwrap(name), _unwrap(successCallback));
          return;
        } else {
          _ptr.copyTo(_unwrap(parent), _unwrap(name), _unwrap(successCallback), _unwrap(errorCallback));
          return;
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void getMetadata(MetadataCallback successCallback, [ErrorCallback errorCallback = null]) {
    if (errorCallback === null) {
      _ptr.getMetadata(_unwrap(successCallback));
      return;
    } else {
      _ptr.getMetadata(_unwrap(successCallback), _unwrap(errorCallback));
      return;
    }
  }

  void getParent([EntryCallback successCallback = null, ErrorCallback errorCallback = null]) {
    if (successCallback === null) {
      if (errorCallback === null) {
        _ptr.getParent();
        return;
      }
    } else {
      if (errorCallback === null) {
        _ptr.getParent(_unwrap(successCallback));
        return;
      } else {
        _ptr.getParent(_unwrap(successCallback), _unwrap(errorCallback));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void moveTo(DirectoryEntry parent, [String name = null, EntryCallback successCallback = null, ErrorCallback errorCallback = null]) {
    if (name === null) {
      if (successCallback === null) {
        if (errorCallback === null) {
          _ptr.moveTo(_unwrap(parent));
          return;
        }
      }
    } else {
      if (successCallback === null) {
        if (errorCallback === null) {
          _ptr.moveTo(_unwrap(parent), _unwrap(name));
          return;
        }
      } else {
        if (errorCallback === null) {
          _ptr.moveTo(_unwrap(parent), _unwrap(name), _unwrap(successCallback));
          return;
        } else {
          _ptr.moveTo(_unwrap(parent), _unwrap(name), _unwrap(successCallback), _unwrap(errorCallback));
          return;
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void remove(VoidCallback successCallback, [ErrorCallback errorCallback = null]) {
    if (errorCallback === null) {
      _ptr.remove(_unwrap(successCallback));
      return;
    } else {
      _ptr.remove(_unwrap(successCallback), _unwrap(errorCallback));
      return;
    }
  }

  String toURL() {
    return _wrap(_ptr.toURL());
  }
}

class _EntryArrayImpl extends _DOMTypeBase implements EntryArray {
  _EntryArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Entry item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _EntryArraySyncImpl extends _DOMTypeBase implements EntryArraySync {
  _EntryArraySyncImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  EntrySync item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _EntrySyncImpl extends _DOMTypeBase implements EntrySync {
  _EntrySyncImpl._wrap(ptr) : super._wrap(ptr);

  DOMFileSystemSync get filesystem() => _wrap(_ptr.filesystem);

  String get fullPath() => _wrap(_ptr.fullPath);

  bool get isDirectory() => _wrap(_ptr.isDirectory);

  bool get isFile() => _wrap(_ptr.isFile);

  String get name() => _wrap(_ptr.name);

  EntrySync copyTo(DirectoryEntrySync parent, String name) {
    return _wrap(_ptr.copyTo(_unwrap(parent), _unwrap(name)));
  }

  Metadata getMetadata() {
    return _wrap(_ptr.getMetadata());
  }

  EntrySync getParent() {
    return _wrap(_ptr.getParent());
  }

  EntrySync moveTo(DirectoryEntrySync parent, String name) {
    return _wrap(_ptr.moveTo(_unwrap(parent), _unwrap(name)));
  }

  void remove() {
    _ptr.remove();
    return;
  }

  String toURL() {
    return _wrap(_ptr.toURL());
  }
}

class _ErrorEventImpl extends _EventImpl implements ErrorEvent {
  _ErrorEventImpl._wrap(ptr) : super._wrap(ptr);

  String get filename() => _wrap(_ptr.filename);

  int get lineno() => _wrap(_ptr.lineno);

  String get message() => _wrap(_ptr.message);
}

class _EventImpl extends _DOMTypeBase implements Event {
  _EventImpl._wrap(ptr) : super._wrap(ptr);

  bool get bubbles() => _wrap(_ptr.bubbles);

  bool get cancelBubble() => _wrap(_ptr.cancelBubble);

  void set cancelBubble(bool value) { _ptr.cancelBubble = _unwrap(value); }

  bool get cancelable() => _wrap(_ptr.cancelable);

  Clipboard get clipboardData() => _wrap(_ptr.clipboardData);

  EventTarget get currentTarget() => _wrap(_ptr.currentTarget);

  bool get defaultPrevented() => _wrap(_ptr.defaultPrevented);

  int get eventPhase() => _wrap(_ptr.eventPhase);

  bool get returnValue() => _wrap(_ptr.returnValue);

  void set returnValue(bool value) { _ptr.returnValue = _unwrap(value); }

  EventTarget get srcElement() => _wrap(_ptr.srcElement);

  EventTarget get target() => _wrap(_ptr.target);

  int get timeStamp() => _wrap(_ptr.timeStamp);

  String get type() => _wrap(_ptr.type);

  void $dom_initEvent(String eventTypeArg, bool canBubbleArg, bool cancelableArg) {
    _ptr.initEvent(_unwrap(eventTypeArg), _unwrap(canBubbleArg), _unwrap(cancelableArg));
    return;
  }

  void preventDefault() {
    _ptr.preventDefault();
    return;
  }

  void stopImmediatePropagation() {
    _ptr.stopImmediatePropagation();
    return;
  }

  void stopPropagation() {
    _ptr.stopPropagation();
    return;
  }
}

class _EventExceptionImpl extends _DOMTypeBase implements EventException {
  _EventExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _EventSourceImpl extends _EventTargetImpl implements EventSource {
  _EventSourceImpl._wrap(ptr) : super._wrap(ptr);

  _EventSourceEventsImpl get on() {
    if (_on == null) _on = new _EventSourceEventsImpl(this);
    return _on;
  }

  String get URL() => _wrap(_ptr.URL);

  int get readyState() => _wrap(_ptr.readyState);

  String get url() => _wrap(_ptr.url);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void close() {
    _ptr.close();
    return;
  }

  bool $dom_dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _EventSourceEventsImpl extends _EventsImpl implements EventSourceEvents {
  _EventSourceEventsImpl(_ptr) : super(_ptr);

  EventListenerList get error() => _get('error');

  EventListenerList get message() => _get('message');

  EventListenerList get open() => _get('open');
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _EventsImpl implements Events {

  final _EventTargetImpl _ptr;

  final Map<String, EventListenerList> _listenerMap;

  _EventsImpl(this._ptr) : _listenerMap = <EventListenerList>{};

  EventListenerList operator [](String type) {
    return _get(type.toLowerCase());
  }
  
  EventListenerList _get(String type) {
    return _listenerMap.putIfAbsent(type,
      () => new _EventListenerListImpl(_ptr, type));
  }
}

class _EventListenerWrapper {
  final EventListener raw;
  final Function wrapped;
  final bool useCapture;
  _EventListenerWrapper(this.raw, this.wrapped, this.useCapture);
}

class _EventListenerListImpl implements EventListenerList {
  final _EventTargetImpl _ptr;
  final String _type;
  List<_EventListenerWrapper> _wrappers;

  _EventListenerListImpl(this._ptr, this._type) :
    // TODO(jacobr): switch to <_EventListenerWrapper>[] when the VM allow it.
    _wrappers = new List<_EventListenerWrapper>();

  EventListenerList add(EventListener listener, [bool useCapture = false]) {
    _add(listener, useCapture);
    return this;
  }

  EventListenerList remove(EventListener listener, [bool useCapture = false]) {
    _remove(listener, useCapture);
    return this;
  }

  bool dispatch(Event evt) {
    // TODO(jacobr): what is the correct behavior here. We could alternately
    // force the event to have the expected type.
    assert(evt.type == _type);
    return _ptr.$dom_dispatchEvent(evt);
  }

  void _add(EventListener listener, bool useCapture) {
    _ptr.$dom_addEventListener(_type,
                          _findOrAddWrapper(listener, useCapture),
                          useCapture);
  }

  void _remove(EventListener listener, bool useCapture) {
    Function wrapper = _removeWrapper(listener, useCapture);
    if (wrapper !== null) {
      _ptr.$dom_removeEventListener(_type, wrapper, useCapture);
    }
  }

  Function _removeWrapper(EventListener listener, bool useCapture) {
    if (_wrappers === null) {
      return null;
    }
    for (int i = 0; i < _wrappers.length; i++) {
      _EventListenerWrapper wrapper = _wrappers[i];
      if (wrapper.raw === listener && wrapper.useCapture == useCapture) {
        // Order doesn't matter so we swap with the last element instead of
        // performing a more expensive remove from the middle of the list.
        if (i + 1 != _wrappers.length) {
          _wrappers[i] = _wrappers.removeLast();
        } else {
          _wrappers.removeLast();
        }
        return wrapper.wrapped;
      }
    }
    return null;
  }

  Function _findOrAddWrapper(EventListener listener, bool useCapture) {
    if (_wrappers === null) {
      _wrappers = <_EventListenerWrapper>[];
    } else {
      for (_EventListenerWrapper wrapper in _wrappers) {
        if (wrapper.raw === listener && wrapper.useCapture == useCapture) {
          return wrapper.wrapped;
        }
      }
    }
    final wrapped = (e) { listener(_wrap(e)); };
    _wrappers.add(new _EventListenerWrapper(listener, wrapped, useCapture));
    return wrapped;
  }
}

class _EventTargetImpl extends _DOMTypeBase implements EventTarget {

  Events _on;

  Events get on() {
    if (_on == null) _on = new _EventsImpl(this);
    return _on;
  }

  _EventTargetImpl._wrap(ptr) : super._wrap(ptr);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool $dom_dispatchEvent(Event event) {
    return _wrap(_ptr.dispatchEvent(_unwrap(event)));
  }

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

}

class _FieldSetElementImpl extends _ElementImpl implements FieldSetElement {
  _FieldSetElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  FormElement get form() => _wrap(_ptr.form);

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  String get validationMessage() => _wrap(_ptr.validationMessage);

  ValidityState get validity() => _wrap(_ptr.validity);

  bool get willValidate() => _wrap(_ptr.willValidate);

  bool checkValidity() {
    return _wrap(_ptr.checkValidity());
  }

  void setCustomValidity(String error) {
    _ptr.setCustomValidity(_unwrap(error));
    return;
  }
}

class _FileImpl extends _BlobImpl implements File {
  _FileImpl._wrap(ptr) : super._wrap(ptr);

  Date get lastModifiedDate() => _wrap(_ptr.lastModifiedDate);

  String get name() => _wrap(_ptr.name);

  String get webkitRelativePath() => _wrap(_ptr.webkitRelativePath);
}

class _FileEntryImpl extends _EntryImpl implements FileEntry {
  _FileEntryImpl._wrap(ptr) : super._wrap(ptr);

  void createWriter(FileWriterCallback successCallback, [ErrorCallback errorCallback = null]) {
    if (errorCallback === null) {
      _ptr.createWriter(_unwrap(successCallback));
      return;
    } else {
      _ptr.createWriter(_unwrap(successCallback), _unwrap(errorCallback));
      return;
    }
  }

  void file(FileCallback successCallback, [ErrorCallback errorCallback = null]) {
    if (errorCallback === null) {
      _ptr.file(_unwrap(successCallback));
      return;
    } else {
      _ptr.file(_unwrap(successCallback), _unwrap(errorCallback));
      return;
    }
  }
}

class _FileEntrySyncImpl extends _EntrySyncImpl implements FileEntrySync {
  _FileEntrySyncImpl._wrap(ptr) : super._wrap(ptr);

  FileWriterSync createWriter() {
    return _wrap(_ptr.createWriter());
  }

  File file() {
    return _wrap(_ptr.file());
  }
}

class _FileErrorImpl extends _DOMTypeBase implements FileError {
  _FileErrorImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);
}

class _FileExceptionImpl extends _DOMTypeBase implements FileException {
  _FileExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _FileListImpl extends _DOMTypeBase implements FileList {
  _FileListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  File operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, File value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }
  // -- start List<File> mixins.
  // File is the element type.

  // From Iterable<File>:

  Iterator<File> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<File>(this);
  }

  // From Collection<File>:

  void add(File value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(File value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<File> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(File element)) => _Collections.forEach(this, f);

  Collection map(f(File element)) => _Collections.map(this, [], f);

  Collection<File> filter(bool f(File element)) =>
     _Collections.filter(this, <File>[], f);

  bool every(bool f(File element)) => _Collections.every(this, f);

  bool some(bool f(File element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<File>:

  void sort(int compare(File a, File b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(File element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(File element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  File last() => this[length - 1];

  File removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<File> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [File initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<File> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <File>[]);

  // -- end List<File> mixins.

  File item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _FileReaderImpl extends _EventTargetImpl implements FileReader {
  _FileReaderImpl._wrap(ptr) : super._wrap(ptr);

  _FileReaderEventsImpl get on() {
    if (_on == null) _on = new _FileReaderEventsImpl(this);
    return _on;
  }

  FileError get error() => _wrap(_ptr.error);

  int get readyState() => _wrap(_ptr.readyState);

  Object get result() => _wrap(_ptr.result);

  void abort() {
    _ptr.abort();
    return;
  }

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool $dom_dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void readAsArrayBuffer(Blob blob) {
    _ptr.readAsArrayBuffer(_unwrap(blob));
    return;
  }

  void readAsBinaryString(Blob blob) {
    _ptr.readAsBinaryString(_unwrap(blob));
    return;
  }

  void readAsDataURL(Blob blob) {
    _ptr.readAsDataURL(_unwrap(blob));
    return;
  }

  void readAsText(Blob blob, [String encoding = null]) {
    if (encoding === null) {
      _ptr.readAsText(_unwrap(blob));
      return;
    } else {
      _ptr.readAsText(_unwrap(blob), _unwrap(encoding));
      return;
    }
  }

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _FileReaderEventsImpl extends _EventsImpl implements FileReaderEvents {
  _FileReaderEventsImpl(_ptr) : super(_ptr);

  EventListenerList get abort() => _get('abort');

  EventListenerList get error() => _get('error');

  EventListenerList get load() => _get('load');

  EventListenerList get loadEnd() => _get('loadend');

  EventListenerList get loadStart() => _get('loadstart');

  EventListenerList get progress() => _get('progress');
}

class _FileReaderSyncImpl extends _DOMTypeBase implements FileReaderSync {
  _FileReaderSyncImpl._wrap(ptr) : super._wrap(ptr);

  ArrayBuffer readAsArrayBuffer(Blob blob) {
    return _wrap(_ptr.readAsArrayBuffer(_unwrap(blob)));
  }

  String readAsBinaryString(Blob blob) {
    return _wrap(_ptr.readAsBinaryString(_unwrap(blob)));
  }

  String readAsDataURL(Blob blob) {
    return _wrap(_ptr.readAsDataURL(_unwrap(blob)));
  }

  String readAsText(Blob blob, [String encoding = null]) {
    if (encoding === null) {
      return _wrap(_ptr.readAsText(_unwrap(blob)));
    } else {
      return _wrap(_ptr.readAsText(_unwrap(blob), _unwrap(encoding)));
    }
  }
}

class _FileWriterImpl extends _EventTargetImpl implements FileWriter {
  _FileWriterImpl._wrap(ptr) : super._wrap(ptr);

  _FileWriterEventsImpl get on() {
    if (_on == null) _on = new _FileWriterEventsImpl(this);
    return _on;
  }

  FileError get error() => _wrap(_ptr.error);

  int get length() => _wrap(_ptr.length);

  int get position() => _wrap(_ptr.position);

  int get readyState() => _wrap(_ptr.readyState);

  void abort() {
    _ptr.abort();
    return;
  }

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool $dom_dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void seek(int position) {
    _ptr.seek(_unwrap(position));
    return;
  }

  void truncate(int size) {
    _ptr.truncate(_unwrap(size));
    return;
  }

  void write(Blob data) {
    _ptr.write(_unwrap(data));
    return;
  }
}

class _FileWriterEventsImpl extends _EventsImpl implements FileWriterEvents {
  _FileWriterEventsImpl(_ptr) : super(_ptr);

  EventListenerList get abort() => _get('abort');

  EventListenerList get error() => _get('error');

  EventListenerList get progress() => _get('progress');

  EventListenerList get write() => _get('write');

  EventListenerList get writeEnd() => _get('writeend');

  EventListenerList get writeStart() => _get('writestart');
}

class _FileWriterSyncImpl extends _DOMTypeBase implements FileWriterSync {
  _FileWriterSyncImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  int get position() => _wrap(_ptr.position);

  void seek(int position) {
    _ptr.seek(_unwrap(position));
    return;
  }

  void truncate(int size) {
    _ptr.truncate(_unwrap(size));
    return;
  }

  void write(Blob data) {
    _ptr.write(_unwrap(data));
    return;
  }
}

class _Float32ArrayImpl extends _ArrayBufferViewImpl implements Float32Array, List<num> {
  _Float32ArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  num operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, num value) {
    return _ptr[index] = _unwrap(value);
  }
  // -- start List<num> mixins.
  // num is the element type.

  // From Iterable<num>:

  Iterator<num> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<num>(this);
  }

  // From Collection<num>:

  void add(num value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(num value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<num> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(num element)) => _Collections.forEach(this, f);

  Collection map(f(num element)) => _Collections.map(this, [], f);

  Collection<num> filter(bool f(num element)) =>
     _Collections.filter(this, <num>[], f);

  bool every(bool f(num element)) => _Collections.every(this, f);

  bool some(bool f(num element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<num>:

  void sort(int compare(num a, num b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(num element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(num element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  num last() => this[length - 1];

  num removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<num> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [num initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<num> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <num>[]);

  // -- end List<num> mixins.

  void setElements(Object array, [int offset = null]) {
    if (offset === null) {
      _ptr.setElements(_unwrap(array));
      return;
    } else {
      _ptr.setElements(_unwrap(array), _unwrap(offset));
      return;
    }
  }

  Float32Array subarray(int start, [int end = null]) {
    if (end === null) {
      return _wrap(_ptr.subarray(_unwrap(start)));
    } else {
      return _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
    }
  }
}

class _Float64ArrayImpl extends _ArrayBufferViewImpl implements Float64Array, List<num> {
  _Float64ArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  num operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, num value) {
    return _ptr[index] = _unwrap(value);
  }
  // -- start List<num> mixins.
  // num is the element type.

  // From Iterable<num>:

  Iterator<num> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<num>(this);
  }

  // From Collection<num>:

  void add(num value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(num value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<num> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(num element)) => _Collections.forEach(this, f);

  Collection map(f(num element)) => _Collections.map(this, [], f);

  Collection<num> filter(bool f(num element)) =>
     _Collections.filter(this, <num>[], f);

  bool every(bool f(num element)) => _Collections.every(this, f);

  bool some(bool f(num element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<num>:

  void sort(int compare(num a, num b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(num element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(num element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  num last() => this[length - 1];

  num removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<num> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [num initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<num> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <num>[]);

  // -- end List<num> mixins.

  void setElements(Object array, [int offset = null]) {
    if (offset === null) {
      _ptr.setElements(_unwrap(array));
      return;
    } else {
      _ptr.setElements(_unwrap(array), _unwrap(offset));
      return;
    }
  }

  Float64Array subarray(int start, [int end = null]) {
    if (end === null) {
      return _wrap(_ptr.subarray(_unwrap(start)));
    } else {
      return _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
    }
  }
}

class _FontElementImpl extends _ElementImpl implements FontElement {
  _FontElementImpl._wrap(ptr) : super._wrap(ptr);

  String get color() => _wrap(_ptr.color);

  void set color(String value) { _ptr.color = _unwrap(value); }

  String get face() => _wrap(_ptr.face);

  void set face(String value) { _ptr.face = _unwrap(value); }

  String get size() => _wrap(_ptr.size);

  void set size(String value) { _ptr.size = _unwrap(value); }
}

class _FormElementImpl extends _ElementImpl implements FormElement {
  _FormElementImpl._wrap(ptr) : super._wrap(ptr);

  String get acceptCharset() => _wrap(_ptr.acceptCharset);

  void set acceptCharset(String value) { _ptr.acceptCharset = _unwrap(value); }

  String get action() => _wrap(_ptr.action);

  void set action(String value) { _ptr.action = _unwrap(value); }

  String get autocomplete() => _wrap(_ptr.autocomplete);

  void set autocomplete(String value) { _ptr.autocomplete = _unwrap(value); }

  String get encoding() => _wrap(_ptr.encoding);

  void set encoding(String value) { _ptr.encoding = _unwrap(value); }

  String get enctype() => _wrap(_ptr.enctype);

  void set enctype(String value) { _ptr.enctype = _unwrap(value); }

  int get length() => _wrap(_ptr.length);

  String get method() => _wrap(_ptr.method);

  void set method(String value) { _ptr.method = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  bool get noValidate() => _wrap(_ptr.noValidate);

  void set noValidate(bool value) { _ptr.noValidate = _unwrap(value); }

  String get target() => _wrap(_ptr.target);

  void set target(String value) { _ptr.target = _unwrap(value); }

  bool checkValidity() {
    return _wrap(_ptr.checkValidity());
  }

  void reset() {
    _ptr.reset();
    return;
  }

  void submit() {
    _ptr.submit();
    return;
  }
}

class _FrameElementImpl extends _ElementImpl implements FrameElement {
  _FrameElementImpl._wrap(ptr) : super._wrap(ptr);

  Document get contentDocument() => _wrap(_ptr.contentDocument);

  Window get contentWindow() => _wrap(_ptr.contentWindow);

  String get frameBorder() => _wrap(_ptr.frameBorder);

  void set frameBorder(String value) { _ptr.frameBorder = _unwrap(value); }

  int get height() => _wrap(_ptr.height);

  String get location() => _wrap(_ptr.location);

  void set location(String value) { _ptr.location = _unwrap(value); }

  String get longDesc() => _wrap(_ptr.longDesc);

  void set longDesc(String value) { _ptr.longDesc = _unwrap(value); }

  String get marginHeight() => _wrap(_ptr.marginHeight);

  void set marginHeight(String value) { _ptr.marginHeight = _unwrap(value); }

  String get marginWidth() => _wrap(_ptr.marginWidth);

  void set marginWidth(String value) { _ptr.marginWidth = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  bool get noResize() => _wrap(_ptr.noResize);

  void set noResize(bool value) { _ptr.noResize = _unwrap(value); }

  String get scrolling() => _wrap(_ptr.scrolling);

  void set scrolling(String value) { _ptr.scrolling = _unwrap(value); }

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  int get width() => _wrap(_ptr.width);

  SVGDocument getSVGDocument() {
    return _wrap(_ptr.getSVGDocument());
  }
}

class _FrameSetElementImpl extends _ElementImpl implements FrameSetElement {
  _FrameSetElementImpl._wrap(ptr) : super._wrap(ptr);

  _FrameSetElementEventsImpl get on() {
    if (_on == null) _on = new _FrameSetElementEventsImpl(this);
    return _on;
  }

  String get cols() => _wrap(_ptr.cols);

  void set cols(String value) { _ptr.cols = _unwrap(value); }

  String get rows() => _wrap(_ptr.rows);

  void set rows(String value) { _ptr.rows = _unwrap(value); }
}

class _FrameSetElementEventsImpl extends _ElementEventsImpl implements FrameSetElementEvents {
  _FrameSetElementEventsImpl(_ptr) : super(_ptr);

  EventListenerList get beforeUnload() => _get('beforeunload');

  EventListenerList get blur() => _get('blur');

  EventListenerList get error() => _get('error');

  EventListenerList get focus() => _get('focus');

  EventListenerList get hashChange() => _get('hashchange');

  EventListenerList get load() => _get('load');

  EventListenerList get message() => _get('message');

  EventListenerList get offline() => _get('offline');

  EventListenerList get online() => _get('online');

  EventListenerList get popState() => _get('popstate');

  EventListenerList get resize() => _get('resize');

  EventListenerList get storage() => _get('storage');

  EventListenerList get unload() => _get('unload');
}

class _GeolocationImpl extends _DOMTypeBase implements Geolocation {
  _GeolocationImpl._wrap(ptr) : super._wrap(ptr);

  void clearWatch(int watchId) {
    _ptr.clearWatch(_unwrap(watchId));
    return;
  }

  void getCurrentPosition(PositionCallback successCallback, [PositionErrorCallback errorCallback = null]) {
    if (errorCallback === null) {
      _ptr.getCurrentPosition(_unwrap(successCallback));
      return;
    } else {
      _ptr.getCurrentPosition(_unwrap(successCallback), _unwrap(errorCallback));
      return;
    }
  }

  int watchPosition(PositionCallback successCallback, [PositionErrorCallback errorCallback = null]) {
    if (errorCallback === null) {
      return _wrap(_ptr.watchPosition(_unwrap(successCallback)));
    } else {
      return _wrap(_ptr.watchPosition(_unwrap(successCallback), _unwrap(errorCallback)));
    }
  }
}

class _GeopositionImpl extends _DOMTypeBase implements Geoposition {
  _GeopositionImpl._wrap(ptr) : super._wrap(ptr);

  Coordinates get coords() => _wrap(_ptr.coords);

  int get timestamp() => _wrap(_ptr.timestamp);
}

class _HRElementImpl extends _ElementImpl implements HRElement {
  _HRElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  bool get noShade() => _wrap(_ptr.noShade);

  void set noShade(bool value) { _ptr.noShade = _unwrap(value); }

  String get size() => _wrap(_ptr.size);

  void set size(String value) { _ptr.size = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }
}

class _HTMLAllCollectionImpl extends _DOMTypeBase implements HTMLAllCollection {
  _HTMLAllCollectionImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Node item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }

  Node namedItem(String name) {
    return _wrap(_ptr.namedItem(_unwrap(name)));
  }

  NodeList tags(String name) {
    return _wrap(_ptr.tags(_unwrap(name)));
  }
}

class _HTMLCollectionImpl extends _DOMTypeBase implements HTMLCollection {
  _HTMLCollectionImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Node operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, Node value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }
  // -- start List<Node> mixins.
  // Node is the element type.

  // From Iterable<Node>:

  Iterator<Node> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<Node>(this);
  }

  // From Collection<Node>:

  void add(Node value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(Node value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<Node> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(Node element)) => _Collections.forEach(this, f);

  Collection map(f(Node element)) => _Collections.map(this, [], f);

  Collection<Node> filter(bool f(Node element)) =>
     _Collections.filter(this, <Node>[], f);

  bool every(bool f(Node element)) => _Collections.every(this, f);

  bool some(bool f(Node element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<Node>:

  void sort(int compare(Node a, Node b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(Node element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Node element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  Node last() => this[length - 1];

  Node removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<Node> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [Node initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<Node> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <Node>[]);

  // -- end List<Node> mixins.

  Node item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }

  Node namedItem(String name) {
    return _wrap(_ptr.namedItem(_unwrap(name)));
  }
}

class _HTMLOptionsCollectionImpl extends _HTMLCollectionImpl implements HTMLOptionsCollection {
  _HTMLOptionsCollectionImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  void set length(int value) { _ptr.length = _unwrap(value); }

  int get selectedIndex() => _wrap(_ptr.selectedIndex);

  void set selectedIndex(int value) { _ptr.selectedIndex = _unwrap(value); }

  void remove(int index) {
    _ptr.remove(_unwrap(index));
    return;
  }
}

class _HashChangeEventImpl extends _EventImpl implements HashChangeEvent {
  _HashChangeEventImpl._wrap(ptr) : super._wrap(ptr);

  String get newURL() => _wrap(_ptr.newURL);

  String get oldURL() => _wrap(_ptr.oldURL);

  void initHashChangeEvent(String type, bool canBubble, bool cancelable, String oldURL, String newURL) {
    _ptr.initHashChangeEvent(_unwrap(type), _unwrap(canBubble), _unwrap(cancelable), _unwrap(oldURL), _unwrap(newURL));
    return;
  }
}

class _HeadElementImpl extends _ElementImpl implements HeadElement {
  _HeadElementImpl._wrap(ptr) : super._wrap(ptr);

  String get profile() => _wrap(_ptr.profile);

  void set profile(String value) { _ptr.profile = _unwrap(value); }
}

class _HeadingElementImpl extends _ElementImpl implements HeadingElement {
  _HeadingElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }
}

class _HistoryImpl extends _DOMTypeBase implements History {
  _HistoryImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Dynamic get state() => _wrap(_ptr.state);

  void back() {
    _ptr.back();
    return;
  }

  void forward() {
    _ptr.forward();
    return;
  }

  void go(int distance) {
    _ptr.go(_unwrap(distance));
    return;
  }

  void pushState(Object data, String title, [String url = null]) {
    if (url === null) {
      _ptr.pushState(_unwrap(data), _unwrap(title));
      return;
    } else {
      _ptr.pushState(_unwrap(data), _unwrap(title), _unwrap(url));
      return;
    }
  }

  void replaceState(Object data, String title, [String url = null]) {
    if (url === null) {
      _ptr.replaceState(_unwrap(data), _unwrap(title));
      return;
    } else {
      _ptr.replaceState(_unwrap(data), _unwrap(title), _unwrap(url));
      return;
    }
  }
}

class _HtmlElementImpl extends _ElementImpl implements HtmlElement {
  _HtmlElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _IDBAnyImpl extends _DOMTypeBase implements IDBAny {
  _IDBAnyImpl._wrap(ptr) : super._wrap(ptr);
}

class _IDBCursorImpl extends _DOMTypeBase implements IDBCursor {
  _IDBCursorImpl._wrap(ptr) : super._wrap(ptr);

  int get direction() => _wrap(_ptr.direction);

  Dynamic get key() => _wrap(_ptr.key);

  Dynamic get primaryKey() => _wrap(_ptr.primaryKey);

  Dynamic get source() => _wrap(_ptr.source);

  void advance(int count) {
    _ptr.advance(_unwrap(count));
    return;
  }

  void continueFunction([/*IDBKey*/ key = null]) {
    if (key === null) {
      _ptr.continueFunction();
      return;
    } else {
      _ptr.continueFunction(_unwrap(key));
      return;
    }
  }

  IDBRequest delete() {
    return _wrap(_ptr.delete());
  }

  IDBRequest update(/*SerializedScriptValue*/ value) {
    return _wrap(_ptr.update(_unwrap(value)));
  }
}

class _IDBCursorWithValueImpl extends _IDBCursorImpl implements IDBCursorWithValue {
  _IDBCursorWithValueImpl._wrap(ptr) : super._wrap(ptr);

  Dynamic get value() => _wrap(_ptr.value);
}

class _IDBDatabaseImpl extends _EventTargetImpl implements IDBDatabase {
  _IDBDatabaseImpl._wrap(ptr) : super._wrap(ptr);

  _IDBDatabaseEventsImpl get on() {
    if (_on == null) _on = new _IDBDatabaseEventsImpl(this);
    return _on;
  }

  String get name() => _wrap(_ptr.name);

  List<String> get objectStoreNames() => _wrap(_ptr.objectStoreNames);

  String get version() => _wrap(_ptr.version);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void close() {
    _ptr.close();
    return;
  }

  IDBObjectStore createObjectStore(String name, [Map options = null]) {
    if (options === null) {
      return _wrap(_ptr.createObjectStore(_unwrap(name)));
    } else {
      return _wrap(_ptr.createObjectStore(_unwrap(name), _unwrap(options)));
    }
  }

  void deleteObjectStore(String name) {
    _ptr.deleteObjectStore(_unwrap(name));
    return;
  }

  bool $dom_dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  IDBVersionChangeRequest setVersion(String version) {
    return _wrap(_ptr.setVersion(_unwrap(version)));
  }

  IDBTransaction transaction(storeName_OR_storeNames, [int mode = null]) {
    if (storeName_OR_storeNames is List<String>) {
      if (mode === null) {
        return _wrap(_ptr.transaction(_unwrap(storeName_OR_storeNames)));
      } else {
        return _wrap(_ptr.transaction(_unwrap(storeName_OR_storeNames), _unwrap(mode)));
      }
    } else {
      if (storeName_OR_storeNames is String) {
        if (mode === null) {
          return _wrap(_ptr.transaction(_unwrap(storeName_OR_storeNames)));
        } else {
          return _wrap(_ptr.transaction(_unwrap(storeName_OR_storeNames), _unwrap(mode)));
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }
}

class _IDBDatabaseEventsImpl extends _EventsImpl implements IDBDatabaseEvents {
  _IDBDatabaseEventsImpl(_ptr) : super(_ptr);

  EventListenerList get abort() => _get('abort');

  EventListenerList get error() => _get('error');

  EventListenerList get versionChange() => _get('versionchange');
}

class _IDBDatabaseExceptionImpl extends _DOMTypeBase implements IDBDatabaseException {
  _IDBDatabaseExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _IDBFactoryImpl extends _DOMTypeBase implements IDBFactory {
  _IDBFactoryImpl._wrap(ptr) : super._wrap(ptr);

  int cmp(/*IDBKey*/ first, /*IDBKey*/ second) {
    return _wrap(_ptr.cmp(_unwrap(first), _unwrap(second)));
  }

  IDBVersionChangeRequest deleteDatabase(String name) {
    return _wrap(_ptr.deleteDatabase(_unwrap(name)));
  }

  IDBRequest getDatabaseNames() {
    return _wrap(_ptr.getDatabaseNames());
  }

  IDBRequest open(String name) {
    return _wrap(_ptr.open(_unwrap(name)));
  }
}

class _IDBIndexImpl extends _DOMTypeBase implements IDBIndex {
  _IDBIndexImpl._wrap(ptr) : super._wrap(ptr);

  String get keyPath() => _wrap(_ptr.keyPath);

  bool get multiEntry() => _wrap(_ptr.multiEntry);

  String get name() => _wrap(_ptr.name);

  IDBObjectStore get objectStore() => _wrap(_ptr.objectStore);

  bool get unique() => _wrap(_ptr.unique);

  IDBRequest count([key_OR_range = null]) {
    if (key_OR_range === null) {
      return _wrap(_ptr.count());
    } else {
      if (key_OR_range is IDBKeyRange) {
        return _wrap(_ptr.count(_unwrap(key_OR_range)));
      } else {
        return _wrap(_ptr.count(_unwrap(key_OR_range)));
      }
    }
  }

  IDBRequest get(key) {
    if (key is IDBKeyRange) {
      return _wrap(_ptr.get(_unwrap(key)));
    } else {
      return _wrap(_ptr.get(_unwrap(key)));
    }
  }

  IDBRequest getKey(key) {
    if (key is IDBKeyRange) {
      return _wrap(_ptr.getKey(_unwrap(key)));
    } else {
      return _wrap(_ptr.getKey(_unwrap(key)));
    }
  }

  IDBRequest openCursor([key_OR_range = null, int direction = null]) {
    if (key_OR_range === null) {
      if (direction === null) {
        return _wrap(_ptr.openCursor());
      }
    } else {
      if (key_OR_range is IDBKeyRange) {
        if (direction === null) {
          return _wrap(_ptr.openCursor(_unwrap(key_OR_range)));
        } else {
          return _wrap(_ptr.openCursor(_unwrap(key_OR_range), _unwrap(direction)));
        }
      } else {
        if (direction === null) {
          return _wrap(_ptr.openCursor(_unwrap(key_OR_range)));
        } else {
          return _wrap(_ptr.openCursor(_unwrap(key_OR_range), _unwrap(direction)));
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  IDBRequest openKeyCursor([key_OR_range = null, int direction = null]) {
    if (key_OR_range === null) {
      if (direction === null) {
        return _wrap(_ptr.openKeyCursor());
      }
    } else {
      if (key_OR_range is IDBKeyRange) {
        if (direction === null) {
          return _wrap(_ptr.openKeyCursor(_unwrap(key_OR_range)));
        } else {
          return _wrap(_ptr.openKeyCursor(_unwrap(key_OR_range), _unwrap(direction)));
        }
      } else {
        if (direction === null) {
          return _wrap(_ptr.openKeyCursor(_unwrap(key_OR_range)));
        } else {
          return _wrap(_ptr.openKeyCursor(_unwrap(key_OR_range), _unwrap(direction)));
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }
}

class _IDBKeyImpl extends _DOMTypeBase implements IDBKey {
  _IDBKeyImpl._wrap(ptr) : super._wrap(ptr);
}

class _IDBKeyRangeImpl extends _DOMTypeBase implements IDBKeyRange {
  _IDBKeyRangeImpl._wrap(ptr) : super._wrap(ptr);

  Dynamic get lower() => _wrap(_ptr.lower);

  bool get lowerOpen() => _wrap(_ptr.lowerOpen);

  Dynamic get upper() => _wrap(_ptr.upper);

  bool get upperOpen() => _wrap(_ptr.upperOpen);
}

class _IDBObjectStoreImpl extends _DOMTypeBase implements IDBObjectStore {
  _IDBObjectStoreImpl._wrap(ptr) : super._wrap(ptr);

  List<String> get indexNames() => _wrap(_ptr.indexNames);

  String get keyPath() => _wrap(_ptr.keyPath);

  String get name() => _wrap(_ptr.name);

  IDBTransaction get transaction() => _wrap(_ptr.transaction);

  IDBRequest add(/*SerializedScriptValue*/ value, [/*IDBKey*/ key = null]) {
    if (key === null) {
      return _wrap(_ptr.add(_unwrap(value)));
    } else {
      return _wrap(_ptr.add(_unwrap(value), _unwrap(key)));
    }
  }

  IDBRequest clear() {
    return _wrap(_ptr.clear());
  }

  IDBRequest count([key_OR_range = null]) {
    if (key_OR_range === null) {
      return _wrap(_ptr.count());
    } else {
      if (key_OR_range is IDBKeyRange) {
        return _wrap(_ptr.count(_unwrap(key_OR_range)));
      } else {
        return _wrap(_ptr.count(_unwrap(key_OR_range)));
      }
    }
  }

  IDBIndex createIndex(String name, String keyPath, [Map options = null]) {
    if (options === null) {
      return _wrap(_ptr.createIndex(_unwrap(name), _unwrap(keyPath)));
    } else {
      return _wrap(_ptr.createIndex(_unwrap(name), _unwrap(keyPath), _unwrap(options)));
    }
  }

  IDBRequest delete(key_OR_keyRange) {
    if (key_OR_keyRange is IDBKeyRange) {
      return _wrap(_ptr.delete(_unwrap(key_OR_keyRange)));
    } else {
      return _wrap(_ptr.delete(_unwrap(key_OR_keyRange)));
    }
  }

  void deleteIndex(String name) {
    _ptr.deleteIndex(_unwrap(name));
    return;
  }

  IDBRequest getObject(key) {
    if (key is IDBKeyRange) {
      return _wrap(_ptr.getObject(_unwrap(key)));
    } else {
      return _wrap(_ptr.getObject(_unwrap(key)));
    }
  }

  IDBIndex index(String name) {
    return _wrap(_ptr.index(_unwrap(name)));
  }

  IDBRequest openCursor([key_OR_range = null, int direction = null]) {
    if (key_OR_range is IDBKeyRange) {
      if (direction === null) {
        return _wrap(_ptr.openCursor(_unwrap(key_OR_range)));
      } else {
        return _wrap(_ptr.openCursor(_unwrap(key_OR_range), _unwrap(direction)));
      }
    } else {
      if (direction === null) {
        return _wrap(_ptr.openCursor(_unwrap(key_OR_range)));
      } else {
        return _wrap(_ptr.openCursor(_unwrap(key_OR_range), _unwrap(direction)));
      }
    }
  }

  IDBRequest put(/*SerializedScriptValue*/ value, [/*IDBKey*/ key = null]) {
    if (key === null) {
      return _wrap(_ptr.put(_unwrap(value)));
    } else {
      return _wrap(_ptr.put(_unwrap(value), _unwrap(key)));
    }
  }
}

class _IDBRequestImpl extends _EventTargetImpl implements IDBRequest {
  _IDBRequestImpl._wrap(ptr) : super._wrap(ptr);

  _IDBRequestEventsImpl get on() {
    if (_on == null) _on = new _IDBRequestEventsImpl(this);
    return _on;
  }

  int get errorCode() => _wrap(_ptr.errorCode);

  int get readyState() => _wrap(_ptr.readyState);

  Dynamic get result() => _wrap(_ptr.result);

  Dynamic get source() => _wrap(_ptr.source);

  IDBTransaction get transaction() => _wrap(_ptr.transaction);

  String get webkitErrorMessage() => _wrap(_ptr.webkitErrorMessage);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool $dom_dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _IDBRequestEventsImpl extends _EventsImpl implements IDBRequestEvents {
  _IDBRequestEventsImpl(_ptr) : super(_ptr);

  EventListenerList get error() => _get('error');

  EventListenerList get success() => _get('success');
}

class _IDBTransactionImpl extends _EventTargetImpl implements IDBTransaction {
  _IDBTransactionImpl._wrap(ptr) : super._wrap(ptr);

  _IDBTransactionEventsImpl get on() {
    if (_on == null) _on = new _IDBTransactionEventsImpl(this);
    return _on;
  }

  IDBDatabase get db() => _wrap(_ptr.db);

  int get mode() => _wrap(_ptr.mode);

  void abort() {
    _ptr.abort();
    return;
  }

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool $dom_dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  IDBObjectStore objectStore(String name) {
    return _wrap(_ptr.objectStore(_unwrap(name)));
  }

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _IDBTransactionEventsImpl extends _EventsImpl implements IDBTransactionEvents {
  _IDBTransactionEventsImpl(_ptr) : super(_ptr);

  EventListenerList get abort() => _get('abort');

  EventListenerList get complete() => _get('complete');

  EventListenerList get error() => _get('error');
}

class _IDBVersionChangeEventImpl extends _EventImpl implements IDBVersionChangeEvent {
  _IDBVersionChangeEventImpl._wrap(ptr) : super._wrap(ptr);

  String get version() => _wrap(_ptr.version);
}

class _IDBVersionChangeRequestImpl extends _IDBRequestImpl implements IDBVersionChangeRequest {
  _IDBVersionChangeRequestImpl._wrap(ptr) : super._wrap(ptr);

  _IDBVersionChangeRequestEventsImpl get on() {
    if (_on == null) _on = new _IDBVersionChangeRequestEventsImpl(this);
    return _on;
  }

  // From EventTarget

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool $dom_dispatchEvent(Event event) {
    return _wrap(_ptr.dispatchEvent(_unwrap(event)));
  }

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _IDBVersionChangeRequestEventsImpl extends _IDBRequestEventsImpl implements IDBVersionChangeRequestEvents {
  _IDBVersionChangeRequestEventsImpl(_ptr) : super(_ptr);

  EventListenerList get blocked() => _get('blocked');
}

class _IFrameElementImpl extends _ElementImpl implements IFrameElement {
  _IFrameElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get frameBorder() => _wrap(_ptr.frameBorder);

  void set frameBorder(String value) { _ptr.frameBorder = _unwrap(value); }

  String get height() => _wrap(_ptr.height);

  void set height(String value) { _ptr.height = _unwrap(value); }

  String get longDesc() => _wrap(_ptr.longDesc);

  void set longDesc(String value) { _ptr.longDesc = _unwrap(value); }

  String get marginHeight() => _wrap(_ptr.marginHeight);

  void set marginHeight(String value) { _ptr.marginHeight = _unwrap(value); }

  String get marginWidth() => _wrap(_ptr.marginWidth);

  void set marginWidth(String value) { _ptr.marginWidth = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get sandbox() => _wrap(_ptr.sandbox);

  void set sandbox(String value) { _ptr.sandbox = _unwrap(value); }

  String get scrolling() => _wrap(_ptr.scrolling);

  void set scrolling(String value) { _ptr.scrolling = _unwrap(value); }

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  String get srcdoc() => _wrap(_ptr.srcdoc);

  void set srcdoc(String value) { _ptr.srcdoc = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }

  SVGDocument getSVGDocument() {
    return _wrap(_ptr.getSVGDocument());
  }
}

class _IceCandidateImpl extends _DOMTypeBase implements IceCandidate {
  _IceCandidateImpl._wrap(ptr) : super._wrap(ptr);

  String get label() => _wrap(_ptr.label);

  String toSdp() {
    return _wrap(_ptr.toSdp());
  }
}

class _ImageDataImpl extends _DOMTypeBase implements ImageData {
  _ImageDataImpl._wrap(ptr) : super._wrap(ptr);

  Uint8ClampedArray get data() => _wrap(_ptr.data);

  int get height() => _wrap(_ptr.height);

  int get width() => _wrap(_ptr.width);
}

class _ImageElementImpl extends _ElementImpl implements ImageElement {
  _ImageElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get alt() => _wrap(_ptr.alt);

  void set alt(String value) { _ptr.alt = _unwrap(value); }

  String get border() => _wrap(_ptr.border);

  void set border(String value) { _ptr.border = _unwrap(value); }

  bool get complete() => _wrap(_ptr.complete);

  String get crossOrigin() => _wrap(_ptr.crossOrigin);

  void set crossOrigin(String value) { _ptr.crossOrigin = _unwrap(value); }

  int get height() => _wrap(_ptr.height);

  void set height(int value) { _ptr.height = _unwrap(value); }

  int get hspace() => _wrap(_ptr.hspace);

  void set hspace(int value) { _ptr.hspace = _unwrap(value); }

  bool get isMap() => _wrap(_ptr.isMap);

  void set isMap(bool value) { _ptr.isMap = _unwrap(value); }

  String get longDesc() => _wrap(_ptr.longDesc);

  void set longDesc(String value) { _ptr.longDesc = _unwrap(value); }

  String get lowsrc() => _wrap(_ptr.lowsrc);

  void set lowsrc(String value) { _ptr.lowsrc = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  int get naturalHeight() => _wrap(_ptr.naturalHeight);

  int get naturalWidth() => _wrap(_ptr.naturalWidth);

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  String get useMap() => _wrap(_ptr.useMap);

  void set useMap(String value) { _ptr.useMap = _unwrap(value); }

  int get vspace() => _wrap(_ptr.vspace);

  void set vspace(int value) { _ptr.vspace = _unwrap(value); }

  int get width() => _wrap(_ptr.width);

  void set width(int value) { _ptr.width = _unwrap(value); }

  int get x() => _wrap(_ptr.x);

  int get y() => _wrap(_ptr.y);
}

class _InputElementImpl extends _ElementImpl implements InputElement {
  _InputElementImpl._wrap(ptr) : super._wrap(ptr);

  _InputElementEventsImpl get on() {
    if (_on == null) _on = new _InputElementEventsImpl(this);
    return _on;
  }

  String get accept() => _wrap(_ptr.accept);

  void set accept(String value) { _ptr.accept = _unwrap(value); }

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get alt() => _wrap(_ptr.alt);

  void set alt(String value) { _ptr.alt = _unwrap(value); }

  String get autocomplete() => _wrap(_ptr.autocomplete);

  void set autocomplete(String value) { _ptr.autocomplete = _unwrap(value); }

  bool get autofocus() => _wrap(_ptr.autofocus);

  void set autofocus(bool value) { _ptr.autofocus = _unwrap(value); }

  bool get checked() => _wrap(_ptr.checked);

  void set checked(bool value) { _ptr.checked = _unwrap(value); }

  bool get defaultChecked() => _wrap(_ptr.defaultChecked);

  void set defaultChecked(bool value) { _ptr.defaultChecked = _unwrap(value); }

  String get defaultValue() => _wrap(_ptr.defaultValue);

  void set defaultValue(String value) { _ptr.defaultValue = _unwrap(value); }

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  FileList get files() => _wrap(_ptr.files);

  FormElement get form() => _wrap(_ptr.form);

  String get formAction() => _wrap(_ptr.formAction);

  void set formAction(String value) { _ptr.formAction = _unwrap(value); }

  String get formEnctype() => _wrap(_ptr.formEnctype);

  void set formEnctype(String value) { _ptr.formEnctype = _unwrap(value); }

  String get formMethod() => _wrap(_ptr.formMethod);

  void set formMethod(String value) { _ptr.formMethod = _unwrap(value); }

  bool get formNoValidate() => _wrap(_ptr.formNoValidate);

  void set formNoValidate(bool value) { _ptr.formNoValidate = _unwrap(value); }

  String get formTarget() => _wrap(_ptr.formTarget);

  void set formTarget(String value) { _ptr.formTarget = _unwrap(value); }

  bool get incremental() => _wrap(_ptr.incremental);

  void set incremental(bool value) { _ptr.incremental = _unwrap(value); }

  bool get indeterminate() => _wrap(_ptr.indeterminate);

  void set indeterminate(bool value) { _ptr.indeterminate = _unwrap(value); }

  NodeList get labels() => _wrap(_ptr.labels);

  String get max() => _wrap(_ptr.max);

  void set max(String value) { _ptr.max = _unwrap(value); }

  int get maxLength() => _wrap(_ptr.maxLength);

  void set maxLength(int value) { _ptr.maxLength = _unwrap(value); }

  String get min() => _wrap(_ptr.min);

  void set min(String value) { _ptr.min = _unwrap(value); }

  bool get multiple() => _wrap(_ptr.multiple);

  void set multiple(bool value) { _ptr.multiple = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get pattern() => _wrap(_ptr.pattern);

  void set pattern(String value) { _ptr.pattern = _unwrap(value); }

  String get placeholder() => _wrap(_ptr.placeholder);

  void set placeholder(String value) { _ptr.placeholder = _unwrap(value); }

  bool get readOnly() => _wrap(_ptr.readOnly);

  void set readOnly(bool value) { _ptr.readOnly = _unwrap(value); }

  bool get required() => _wrap(_ptr.required);

  void set required(bool value) { _ptr.required = _unwrap(value); }

  String get selectionDirection() => _wrap(_ptr.selectionDirection);

  void set selectionDirection(String value) { _ptr.selectionDirection = _unwrap(value); }

  int get selectionEnd() => _wrap(_ptr.selectionEnd);

  void set selectionEnd(int value) { _ptr.selectionEnd = _unwrap(value); }

  int get selectionStart() => _wrap(_ptr.selectionStart);

  void set selectionStart(int value) { _ptr.selectionStart = _unwrap(value); }

  int get size() => _wrap(_ptr.size);

  void set size(int value) { _ptr.size = _unwrap(value); }

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  String get step() => _wrap(_ptr.step);

  void set step(String value) { _ptr.step = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }

  String get useMap() => _wrap(_ptr.useMap);

  void set useMap(String value) { _ptr.useMap = _unwrap(value); }

  String get validationMessage() => _wrap(_ptr.validationMessage);

  ValidityState get validity() => _wrap(_ptr.validity);

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }

  Date get valueAsDate() => _wrap(_ptr.valueAsDate);

  void set valueAsDate(Date value) { _ptr.valueAsDate = _unwrap(value); }

  num get valueAsNumber() => _wrap(_ptr.valueAsNumber);

  void set valueAsNumber(num value) { _ptr.valueAsNumber = _unwrap(value); }

  bool get webkitGrammar() => _wrap(_ptr.webkitGrammar);

  void set webkitGrammar(bool value) { _ptr.webkitGrammar = _unwrap(value); }

  bool get webkitSpeech() => _wrap(_ptr.webkitSpeech);

  void set webkitSpeech(bool value) { _ptr.webkitSpeech = _unwrap(value); }

  bool get webkitdirectory() => _wrap(_ptr.webkitdirectory);

  void set webkitdirectory(bool value) { _ptr.webkitdirectory = _unwrap(value); }

  bool get willValidate() => _wrap(_ptr.willValidate);

  bool checkValidity() {
    return _wrap(_ptr.checkValidity());
  }

  void select() {
    _ptr.select();
    return;
  }

  void setCustomValidity(String error) {
    _ptr.setCustomValidity(_unwrap(error));
    return;
  }

  void setSelectionRange(int start, int end, [String direction = null]) {
    if (direction === null) {
      _ptr.setSelectionRange(_unwrap(start), _unwrap(end));
      return;
    } else {
      _ptr.setSelectionRange(_unwrap(start), _unwrap(end), _unwrap(direction));
      return;
    }
  }

  void stepDown([int n = null]) {
    if (n === null) {
      _ptr.stepDown();
      return;
    } else {
      _ptr.stepDown(_unwrap(n));
      return;
    }
  }

  void stepUp([int n = null]) {
    if (n === null) {
      _ptr.stepUp();
      return;
    } else {
      _ptr.stepUp(_unwrap(n));
      return;
    }
  }
}

class _InputElementEventsImpl extends _ElementEventsImpl implements InputElementEvents {
  _InputElementEventsImpl(_ptr) : super(_ptr);

  EventListenerList get speechChange() => _get('webkitSpeechChange');
}

class _Int16ArrayImpl extends _ArrayBufferViewImpl implements Int16Array, List<int> {
  _Int16ArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  int operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, int value) {
    return _ptr[index] = _unwrap(value);
  }
  // -- start List<int> mixins.
  // int is the element type.

  // From Iterable<int>:

  Iterator<int> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<int>(this);
  }

  // From Collection<int>:

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(int element)) => _Collections.forEach(this, f);

  Collection map(f(int element)) => _Collections.map(this, [], f);

  Collection<int> filter(bool f(int element)) =>
     _Collections.filter(this, <int>[], f);

  bool every(bool f(int element)) => _Collections.every(this, f);

  bool some(bool f(int element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<int>:

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(int element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(int element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int last() => this[length - 1];

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <int>[]);

  // -- end List<int> mixins.

  void setElements(Object array, [int offset = null]) {
    if (offset === null) {
      _ptr.setElements(_unwrap(array));
      return;
    } else {
      _ptr.setElements(_unwrap(array), _unwrap(offset));
      return;
    }
  }

  Int16Array subarray(int start, [int end = null]) {
    if (end === null) {
      return _wrap(_ptr.subarray(_unwrap(start)));
    } else {
      return _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
    }
  }
}

class _Int32ArrayImpl extends _ArrayBufferViewImpl implements Int32Array, List<int> {
  _Int32ArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  int operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, int value) {
    return _ptr[index] = _unwrap(value);
  }
  // -- start List<int> mixins.
  // int is the element type.

  // From Iterable<int>:

  Iterator<int> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<int>(this);
  }

  // From Collection<int>:

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(int element)) => _Collections.forEach(this, f);

  Collection map(f(int element)) => _Collections.map(this, [], f);

  Collection<int> filter(bool f(int element)) =>
     _Collections.filter(this, <int>[], f);

  bool every(bool f(int element)) => _Collections.every(this, f);

  bool some(bool f(int element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<int>:

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(int element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(int element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int last() => this[length - 1];

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <int>[]);

  // -- end List<int> mixins.

  void setElements(Object array, [int offset = null]) {
    if (offset === null) {
      _ptr.setElements(_unwrap(array));
      return;
    } else {
      _ptr.setElements(_unwrap(array), _unwrap(offset));
      return;
    }
  }

  Int32Array subarray(int start, [int end = null]) {
    if (end === null) {
      return _wrap(_ptr.subarray(_unwrap(start)));
    } else {
      return _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
    }
  }
}

class _Int8ArrayImpl extends _ArrayBufferViewImpl implements Int8Array, List<int> {
  _Int8ArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  int operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, int value) {
    return _ptr[index] = _unwrap(value);
  }
  // -- start List<int> mixins.
  // int is the element type.

  // From Iterable<int>:

  Iterator<int> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<int>(this);
  }

  // From Collection<int>:

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(int element)) => _Collections.forEach(this, f);

  Collection map(f(int element)) => _Collections.map(this, [], f);

  Collection<int> filter(bool f(int element)) =>
     _Collections.filter(this, <int>[], f);

  bool every(bool f(int element)) => _Collections.every(this, f);

  bool some(bool f(int element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<int>:

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(int element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(int element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int last() => this[length - 1];

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <int>[]);

  // -- end List<int> mixins.

  void setElements(Object array, [int offset = null]) {
    if (offset === null) {
      _ptr.setElements(_unwrap(array));
      return;
    } else {
      _ptr.setElements(_unwrap(array), _unwrap(offset));
      return;
    }
  }

  Int8Array subarray(int start, [int end = null]) {
    if (end === null) {
      return _wrap(_ptr.subarray(_unwrap(start)));
    } else {
      return _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
    }
  }
}

class _JavaScriptAudioNodeImpl extends _AudioNodeImpl implements JavaScriptAudioNode {
  _JavaScriptAudioNodeImpl._wrap(ptr) : super._wrap(ptr);

  _JavaScriptAudioNodeEventsImpl get on() {
    if (_on == null) _on = new _JavaScriptAudioNodeEventsImpl(this);
    return _on;
  }

  int get bufferSize() => _wrap(_ptr.bufferSize);

  // From EventTarget

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool $dom_dispatchEvent(Event event) {
    return _wrap(_ptr.dispatchEvent(_unwrap(event)));
  }

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _JavaScriptAudioNodeEventsImpl extends _EventsImpl implements JavaScriptAudioNodeEvents {
  _JavaScriptAudioNodeEventsImpl(_ptr) : super(_ptr);

  EventListenerList get audioProcess() => _get('audioprocess');
}

class _JavaScriptCallFrameImpl extends _DOMTypeBase implements JavaScriptCallFrame {
  _JavaScriptCallFrameImpl._wrap(ptr) : super._wrap(ptr);

  JavaScriptCallFrame get caller() => _wrap(_ptr.caller);

  int get column() => _wrap(_ptr.column);

  String get functionName() => _wrap(_ptr.functionName);

  int get line() => _wrap(_ptr.line);

  List get scopeChain() => _wrap(_ptr.scopeChain);

  int get sourceID() => _wrap(_ptr.sourceID);

  Object get thisObject() => _wrap(_ptr.thisObject);

  String get type() => _wrap(_ptr.type);

  void evaluate(String script) {
    _ptr.evaluate(_unwrap(script));
    return;
  }

  int scopeType(int scopeIndex) {
    return _wrap(_ptr.scopeType(_unwrap(scopeIndex)));
  }
}

class _KeyboardEventImpl extends _UIEventImpl implements KeyboardEvent {
  _KeyboardEventImpl._wrap(ptr) : super._wrap(ptr);

  bool get altGraphKey() => _wrap(_ptr.altGraphKey);

  bool get altKey() => _wrap(_ptr.altKey);

  bool get ctrlKey() => _wrap(_ptr.ctrlKey);

  String get keyIdentifier() => _wrap(_ptr.keyIdentifier);

  int get keyLocation() => _wrap(_ptr.keyLocation);

  bool get metaKey() => _wrap(_ptr.metaKey);

  bool get shiftKey() => _wrap(_ptr.shiftKey);

  void initKeyboardEvent(String type, bool canBubble, bool cancelable, Window view, String keyIdentifier, int keyLocation, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, bool altGraphKey) {
    _ptr.initKeyboardEvent(_unwrap(type), _unwrap(canBubble), _unwrap(cancelable), _unwrap(view), _unwrap(keyIdentifier), _unwrap(keyLocation), _unwrap(ctrlKey), _unwrap(altKey), _unwrap(shiftKey), _unwrap(metaKey), _unwrap(altGraphKey));
    return;
  }
}

class _KeygenElementImpl extends _ElementImpl implements KeygenElement {
  _KeygenElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get autofocus() => _wrap(_ptr.autofocus);

  void set autofocus(bool value) { _ptr.autofocus = _unwrap(value); }

  String get challenge() => _wrap(_ptr.challenge);

  void set challenge(String value) { _ptr.challenge = _unwrap(value); }

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  FormElement get form() => _wrap(_ptr.form);

  String get keytype() => _wrap(_ptr.keytype);

  void set keytype(String value) { _ptr.keytype = _unwrap(value); }

  NodeList get labels() => _wrap(_ptr.labels);

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  String get validationMessage() => _wrap(_ptr.validationMessage);

  ValidityState get validity() => _wrap(_ptr.validity);

  bool get willValidate() => _wrap(_ptr.willValidate);

  bool checkValidity() {
    return _wrap(_ptr.checkValidity());
  }

  void setCustomValidity(String error) {
    _ptr.setCustomValidity(_unwrap(error));
    return;
  }
}

class _LIElementImpl extends _ElementImpl implements LIElement {
  _LIElementImpl._wrap(ptr) : super._wrap(ptr);

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }

  int get value() => _wrap(_ptr.value);

  void set value(int value) { _ptr.value = _unwrap(value); }
}

class _LabelElementImpl extends _ElementImpl implements LabelElement {
  _LabelElementImpl._wrap(ptr) : super._wrap(ptr);

  Element get control() => _wrap(_ptr.control);

  FormElement get form() => _wrap(_ptr.form);

  String get htmlFor() => _wrap(_ptr.htmlFor);

  void set htmlFor(String value) { _ptr.htmlFor = _unwrap(value); }
}

class _LegendElementImpl extends _ElementImpl implements LegendElement {
  _LegendElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  FormElement get form() => _wrap(_ptr.form);
}

class _LinkElementImpl extends _ElementImpl implements LinkElement {
  _LinkElementImpl._wrap(ptr) : super._wrap(ptr);

  String get charset() => _wrap(_ptr.charset);

  void set charset(String value) { _ptr.charset = _unwrap(value); }

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  String get href() => _wrap(_ptr.href);

  void set href(String value) { _ptr.href = _unwrap(value); }

  String get hreflang() => _wrap(_ptr.hreflang);

  void set hreflang(String value) { _ptr.hreflang = _unwrap(value); }

  String get media() => _wrap(_ptr.media);

  void set media(String value) { _ptr.media = _unwrap(value); }

  String get rel() => _wrap(_ptr.rel);

  void set rel(String value) { _ptr.rel = _unwrap(value); }

  String get rev() => _wrap(_ptr.rev);

  void set rev(String value) { _ptr.rev = _unwrap(value); }

  StyleSheet get sheet() => _wrap(_ptr.sheet);

  DOMSettableTokenList get sizes() => _wrap(_ptr.sizes);

  void set sizes(DOMSettableTokenList value) { _ptr.sizes = _unwrap(value); }

  String get target() => _wrap(_ptr.target);

  void set target(String value) { _ptr.target = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }
}

class _LocalMediaStreamImpl extends _MediaStreamImpl implements LocalMediaStream {
  _LocalMediaStreamImpl._wrap(ptr) : super._wrap(ptr);

  void stop() {
    _ptr.stop();
    return;
  }
}

class _LocationImpl extends _DOMTypeBase implements Location {
  _LocationImpl._wrap(ptr) : super._wrap(ptr);

  List<String> get ancestorOrigins() => _wrap(_ptr.ancestorOrigins);

  String get hash() => _wrap(_ptr.hash);

  void set hash(String value) { _ptr.hash = _unwrap(value); }

  String get host() => _wrap(_ptr.host);

  void set host(String value) { _ptr.host = _unwrap(value); }

  String get hostname() => _wrap(_ptr.hostname);

  void set hostname(String value) { _ptr.hostname = _unwrap(value); }

  String get href() => _wrap(_ptr.href);

  void set href(String value) { _ptr.href = _unwrap(value); }

  String get origin() => _wrap(_ptr.origin);

  String get pathname() => _wrap(_ptr.pathname);

  void set pathname(String value) { _ptr.pathname = _unwrap(value); }

  String get port() => _wrap(_ptr.port);

  void set port(String value) { _ptr.port = _unwrap(value); }

  String get protocol() => _wrap(_ptr.protocol);

  void set protocol(String value) { _ptr.protocol = _unwrap(value); }

  String get search() => _wrap(_ptr.search);

  void set search(String value) { _ptr.search = _unwrap(value); }

  void assign(String url) {
    _ptr.assign(_unwrap(url));
    return;
  }

  void reload() {
    _ptr.reload();
    return;
  }

  void replace(String url) {
    _ptr.replace(_unwrap(url));
    return;
  }

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _MapElementImpl extends _ElementImpl implements MapElement {
  _MapElementImpl._wrap(ptr) : super._wrap(ptr);

  HTMLCollection get areas() => _wrap(_ptr.areas);

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }
}

class _MarqueeElementImpl extends _ElementImpl implements MarqueeElement {
  _MarqueeElementImpl._wrap(ptr) : super._wrap(ptr);

  String get behavior() => _wrap(_ptr.behavior);

  void set behavior(String value) { _ptr.behavior = _unwrap(value); }

  String get bgColor() => _wrap(_ptr.bgColor);

  void set bgColor(String value) { _ptr.bgColor = _unwrap(value); }

  String get direction() => _wrap(_ptr.direction);

  void set direction(String value) { _ptr.direction = _unwrap(value); }

  String get height() => _wrap(_ptr.height);

  void set height(String value) { _ptr.height = _unwrap(value); }

  int get hspace() => _wrap(_ptr.hspace);

  void set hspace(int value) { _ptr.hspace = _unwrap(value); }

  int get loop() => _wrap(_ptr.loop);

  void set loop(int value) { _ptr.loop = _unwrap(value); }

  int get scrollAmount() => _wrap(_ptr.scrollAmount);

  void set scrollAmount(int value) { _ptr.scrollAmount = _unwrap(value); }

  int get scrollDelay() => _wrap(_ptr.scrollDelay);

  void set scrollDelay(int value) { _ptr.scrollDelay = _unwrap(value); }

  bool get trueSpeed() => _wrap(_ptr.trueSpeed);

  void set trueSpeed(bool value) { _ptr.trueSpeed = _unwrap(value); }

  int get vspace() => _wrap(_ptr.vspace);

  void set vspace(int value) { _ptr.vspace = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }

  void start() {
    _ptr.start();
    return;
  }

  void stop() {
    _ptr.stop();
    return;
  }
}

class _MediaControllerImpl extends _EventTargetImpl implements MediaController {
  _MediaControllerImpl._wrap(ptr) : super._wrap(ptr);

  TimeRanges get buffered() => _wrap(_ptr.buffered);

  num get currentTime() => _wrap(_ptr.currentTime);

  void set currentTime(num value) { _ptr.currentTime = _unwrap(value); }

  num get defaultPlaybackRate() => _wrap(_ptr.defaultPlaybackRate);

  void set defaultPlaybackRate(num value) { _ptr.defaultPlaybackRate = _unwrap(value); }

  num get duration() => _wrap(_ptr.duration);

  bool get muted() => _wrap(_ptr.muted);

  void set muted(bool value) { _ptr.muted = _unwrap(value); }

  bool get paused() => _wrap(_ptr.paused);

  num get playbackRate() => _wrap(_ptr.playbackRate);

  void set playbackRate(num value) { _ptr.playbackRate = _unwrap(value); }

  TimeRanges get played() => _wrap(_ptr.played);

  TimeRanges get seekable() => _wrap(_ptr.seekable);

  num get volume() => _wrap(_ptr.volume);

  void set volume(num value) { _ptr.volume = _unwrap(value); }

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool $dom_dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void pause() {
    _ptr.pause();
    return;
  }

  void play() {
    _ptr.play();
    return;
  }

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _MediaElementImpl extends _ElementImpl implements MediaElement {
  _MediaElementImpl._wrap(ptr) : super._wrap(ptr);

  _MediaElementEventsImpl get on() {
    if (_on == null) _on = new _MediaElementEventsImpl(this);
    return _on;
  }

  bool get autoplay() => _wrap(_ptr.autoplay);

  void set autoplay(bool value) { _ptr.autoplay = _unwrap(value); }

  TimeRanges get buffered() => _wrap(_ptr.buffered);

  MediaController get controller() => _wrap(_ptr.controller);

  void set controller(MediaController value) { _ptr.controller = _unwrap(value); }

  bool get controls() => _wrap(_ptr.controls);

  void set controls(bool value) { _ptr.controls = _unwrap(value); }

  String get currentSrc() => _wrap(_ptr.currentSrc);

  num get currentTime() => _wrap(_ptr.currentTime);

  void set currentTime(num value) { _ptr.currentTime = _unwrap(value); }

  bool get defaultMuted() => _wrap(_ptr.defaultMuted);

  void set defaultMuted(bool value) { _ptr.defaultMuted = _unwrap(value); }

  num get defaultPlaybackRate() => _wrap(_ptr.defaultPlaybackRate);

  void set defaultPlaybackRate(num value) { _ptr.defaultPlaybackRate = _unwrap(value); }

  num get duration() => _wrap(_ptr.duration);

  bool get ended() => _wrap(_ptr.ended);

  MediaError get error() => _wrap(_ptr.error);

  num get initialTime() => _wrap(_ptr.initialTime);

  bool get loop() => _wrap(_ptr.loop);

  void set loop(bool value) { _ptr.loop = _unwrap(value); }

  String get mediaGroup() => _wrap(_ptr.mediaGroup);

  void set mediaGroup(String value) { _ptr.mediaGroup = _unwrap(value); }

  bool get muted() => _wrap(_ptr.muted);

  void set muted(bool value) { _ptr.muted = _unwrap(value); }

  int get networkState() => _wrap(_ptr.networkState);

  bool get paused() => _wrap(_ptr.paused);

  num get playbackRate() => _wrap(_ptr.playbackRate);

  void set playbackRate(num value) { _ptr.playbackRate = _unwrap(value); }

  TimeRanges get played() => _wrap(_ptr.played);

  String get preload() => _wrap(_ptr.preload);

  void set preload(String value) { _ptr.preload = _unwrap(value); }

  int get readyState() => _wrap(_ptr.readyState);

  TimeRanges get seekable() => _wrap(_ptr.seekable);

  bool get seeking() => _wrap(_ptr.seeking);

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  num get startTime() => _wrap(_ptr.startTime);

  TextTrackList get textTracks() => _wrap(_ptr.textTracks);

  num get volume() => _wrap(_ptr.volume);

  void set volume(num value) { _ptr.volume = _unwrap(value); }

  int get webkitAudioDecodedByteCount() => _wrap(_ptr.webkitAudioDecodedByteCount);

  bool get webkitClosedCaptionsVisible() => _wrap(_ptr.webkitClosedCaptionsVisible);

  void set webkitClosedCaptionsVisible(bool value) { _ptr.webkitClosedCaptionsVisible = _unwrap(value); }

  bool get webkitHasClosedCaptions() => _wrap(_ptr.webkitHasClosedCaptions);

  String get webkitMediaSourceURL() => _wrap(_ptr.webkitMediaSourceURL);

  bool get webkitPreservesPitch() => _wrap(_ptr.webkitPreservesPitch);

  void set webkitPreservesPitch(bool value) { _ptr.webkitPreservesPitch = _unwrap(value); }

  int get webkitSourceState() => _wrap(_ptr.webkitSourceState);

  int get webkitVideoDecodedByteCount() => _wrap(_ptr.webkitVideoDecodedByteCount);

  TextTrack addTextTrack(String kind, [String label = null, String language = null]) {
    if (label === null) {
      if (language === null) {
        return _wrap(_ptr.addTextTrack(_unwrap(kind)));
      }
    } else {
      if (language === null) {
        return _wrap(_ptr.addTextTrack(_unwrap(kind), _unwrap(label)));
      } else {
        return _wrap(_ptr.addTextTrack(_unwrap(kind), _unwrap(label), _unwrap(language)));
      }
    }
    throw "Incorrect number or type of arguments";
  }

  String canPlayType(String type, String keySystem) {
    return _wrap(_ptr.canPlayType(_unwrap(type), _unwrap(keySystem)));
  }

  void load() {
    _ptr.load();
    return;
  }

  void pause() {
    _ptr.pause();
    return;
  }

  void play() {
    _ptr.play();
    return;
  }

  void webkitAddKey(String keySystem, Uint8Array key, [Uint8Array initData = null, String sessionId = null]) {
    if (initData === null) {
      if (sessionId === null) {
        _ptr.webkitAddKey(_unwrap(keySystem), _unwrap(key));
        return;
      }
    } else {
      _ptr.webkitAddKey(_unwrap(keySystem), _unwrap(key), _unwrap(initData), _unwrap(sessionId));
      return;
    }
    throw "Incorrect number or type of arguments";
  }

  void webkitCancelKeyRequest(String keySystem, String sessionId) {
    _ptr.webkitCancelKeyRequest(_unwrap(keySystem), _unwrap(sessionId));
    return;
  }

  void webkitGenerateKeyRequest(String keySystem, [Uint8Array initData = null]) {
    if (initData === null) {
      _ptr.webkitGenerateKeyRequest(_unwrap(keySystem));
      return;
    } else {
      _ptr.webkitGenerateKeyRequest(_unwrap(keySystem), _unwrap(initData));
      return;
    }
  }

  void webkitSourceAppend(Uint8Array data) {
    _ptr.webkitSourceAppend(_unwrap(data));
    return;
  }

  void webkitSourceEndOfStream(int status) {
    _ptr.webkitSourceEndOfStream(_unwrap(status));
    return;
  }
}

class _MediaElementEventsImpl extends _ElementEventsImpl implements MediaElementEvents {
  _MediaElementEventsImpl(_ptr) : super(_ptr);

  EventListenerList get keyAdded() => _get('webkitkeyadded');

  EventListenerList get keyError() => _get('webkitkeyerror');

  EventListenerList get keyMessage() => _get('webkitkeymessage');

  EventListenerList get needKey() => _get('webkitneedkey');
}

class _MediaElementAudioSourceNodeImpl extends _AudioSourceNodeImpl implements MediaElementAudioSourceNode {
  _MediaElementAudioSourceNodeImpl._wrap(ptr) : super._wrap(ptr);

  MediaElement get mediaElement() => _wrap(_ptr.mediaElement);
}

class _MediaErrorImpl extends _DOMTypeBase implements MediaError {
  _MediaErrorImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);
}

class _MediaKeyErrorImpl extends _DOMTypeBase implements MediaKeyError {
  _MediaKeyErrorImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);
}

class _MediaKeyEventImpl extends _EventImpl implements MediaKeyEvent {
  _MediaKeyEventImpl._wrap(ptr) : super._wrap(ptr);

  String get defaultURL() => _wrap(_ptr.defaultURL);

  MediaKeyError get errorCode() => _wrap(_ptr.errorCode);

  Uint8Array get initData() => _wrap(_ptr.initData);

  String get keySystem() => _wrap(_ptr.keySystem);

  Uint8Array get message() => _wrap(_ptr.message);

  String get sessionId() => _wrap(_ptr.sessionId);

  int get systemCode() => _wrap(_ptr.systemCode);
}

class _MediaListImpl extends _DOMTypeBase implements MediaList {
  _MediaListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  String get mediaText() => _wrap(_ptr.mediaText);

  void set mediaText(String value) { _ptr.mediaText = _unwrap(value); }

  String operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, String value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }
  // -- start List<String> mixins.
  // String is the element type.

  // From Iterable<String>:

  Iterator<String> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<String>(this);
  }

  // From Collection<String>:

  void add(String value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(String value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<String> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(String element)) => _Collections.forEach(this, f);

  Collection map(f(String element)) => _Collections.map(this, [], f);

  Collection<String> filter(bool f(String element)) =>
     _Collections.filter(this, <String>[], f);

  bool every(bool f(String element)) => _Collections.every(this, f);

  bool some(bool f(String element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<String>:

  void sort(int compare(String a, String b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(String element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(String element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  String last() => this[length - 1];

  String removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<String> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [String initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<String> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <String>[]);

  // -- end List<String> mixins.

  void appendMedium(String newMedium) {
    _ptr.appendMedium(_unwrap(newMedium));
    return;
  }

  void deleteMedium(String oldMedium) {
    _ptr.deleteMedium(_unwrap(oldMedium));
    return;
  }

  String item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _MediaQueryListImpl extends _DOMTypeBase implements MediaQueryList {
  _MediaQueryListImpl._wrap(ptr) : super._wrap(ptr);

  bool get matches() => _wrap(_ptr.matches);

  String get media() => _wrap(_ptr.media);

  void addListener(MediaQueryListListener listener) {
    _ptr.addListener(_unwrap(listener));
    return;
  }

  void removeListener(MediaQueryListListener listener) {
    _ptr.removeListener(_unwrap(listener));
    return;
  }
}

class _MediaQueryListListenerImpl extends _DOMTypeBase implements MediaQueryListListener {
  _MediaQueryListListenerImpl._wrap(ptr) : super._wrap(ptr);

  void queryChanged(MediaQueryList list) {
    _ptr.queryChanged(_unwrap(list));
    return;
  }
}

class _MediaStreamImpl extends _EventTargetImpl implements MediaStream {
  _MediaStreamImpl._wrap(ptr) : super._wrap(ptr);

  _MediaStreamEventsImpl get on() {
    if (_on == null) _on = new _MediaStreamEventsImpl(this);
    return _on;
  }

  MediaStreamTrackList get audioTracks() => _wrap(_ptr.audioTracks);

  String get label() => _wrap(_ptr.label);

  int get readyState() => _wrap(_ptr.readyState);

  MediaStreamTrackList get videoTracks() => _wrap(_ptr.videoTracks);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool $dom_dispatchEvent(Event event) {
    return _wrap(_ptr.dispatchEvent(_unwrap(event)));
  }

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _MediaStreamEventsImpl extends _EventsImpl implements MediaStreamEvents {
  _MediaStreamEventsImpl(_ptr) : super(_ptr);

  EventListenerList get ended() => _get('ended');
}

class _MediaStreamEventImpl extends _EventImpl implements MediaStreamEvent {
  _MediaStreamEventImpl._wrap(ptr) : super._wrap(ptr);

  MediaStream get stream() => _wrap(_ptr.stream);
}

class _MediaStreamListImpl extends _DOMTypeBase implements MediaStreamList {
  _MediaStreamListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  MediaStream item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _MediaStreamTrackImpl extends _DOMTypeBase implements MediaStreamTrack {
  _MediaStreamTrackImpl._wrap(ptr) : super._wrap(ptr);

  bool get enabled() => _wrap(_ptr.enabled);

  void set enabled(bool value) { _ptr.enabled = _unwrap(value); }

  String get kind() => _wrap(_ptr.kind);

  String get label() => _wrap(_ptr.label);
}

class _MediaStreamTrackListImpl extends _DOMTypeBase implements MediaStreamTrackList {
  _MediaStreamTrackListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  MediaStreamTrack item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _MemoryInfoImpl extends _DOMTypeBase implements MemoryInfo {
  _MemoryInfoImpl._wrap(ptr) : super._wrap(ptr);

  int get jsHeapSizeLimit() => _wrap(_ptr.jsHeapSizeLimit);

  int get totalJSHeapSize() => _wrap(_ptr.totalJSHeapSize);

  int get usedJSHeapSize() => _wrap(_ptr.usedJSHeapSize);
}

class _MenuElementImpl extends _ElementImpl implements MenuElement {
  _MenuElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get compact() => _wrap(_ptr.compact);

  void set compact(bool value) { _ptr.compact = _unwrap(value); }
}

class _MessageChannelImpl extends _DOMTypeBase implements MessageChannel {
  _MessageChannelImpl._wrap(ptr) : super._wrap(ptr);

  MessagePort get port1() => _wrap(_ptr.port1);

  MessagePort get port2() => _wrap(_ptr.port2);
}

class _MessageEventImpl extends _EventImpl implements MessageEvent {
  _MessageEventImpl._wrap(ptr) : super._wrap(ptr);

  Object get data() => _wrap(_ptr.data);

  String get lastEventId() => _wrap(_ptr.lastEventId);

  String get origin() => _wrap(_ptr.origin);

  List get ports() => _wrap(_ptr.ports);

  Window get source() => _wrap(_ptr.source);

  void initMessageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object dataArg, String originArg, String lastEventIdArg, Window sourceArg, List messagePorts) {
    _ptr.initMessageEvent(_unwrap(typeArg), _unwrap(canBubbleArg), _unwrap(cancelableArg), _unwrap(dataArg), _unwrap(originArg), _unwrap(lastEventIdArg), _unwrap(sourceArg), _unwrap(messagePorts));
    return;
  }

  void webkitInitMessageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object dataArg, String originArg, String lastEventIdArg, Window sourceArg, List transferables) {
    _ptr.webkitInitMessageEvent(_unwrap(typeArg), _unwrap(canBubbleArg), _unwrap(cancelableArg), _unwrap(dataArg), _unwrap(originArg), _unwrap(lastEventIdArg), _unwrap(sourceArg), _unwrap(transferables));
    return;
  }
}

class _MessagePortImpl extends _EventTargetImpl implements MessagePort {
  _MessagePortImpl._wrap(ptr) : super._wrap(ptr);

  _MessagePortEventsImpl get on() {
    if (_on == null) _on = new _MessagePortEventsImpl(this);
    return _on;
  }

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void close() {
    _ptr.close();
    return;
  }

  bool $dom_dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void postMessage(String message, [List messagePorts = null]) {
    if (messagePorts === null) {
      _ptr.postMessage(_unwrap(message));
      return;
    } else {
      _ptr.postMessage(_unwrap(message), _unwrap(messagePorts));
      return;
    }
  }

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void start() {
    _ptr.start();
    return;
  }

  void webkitPostMessage(String message, [List transfer = null]) {
    if (transfer === null) {
      _ptr.webkitPostMessage(_unwrap(message));
      return;
    } else {
      _ptr.webkitPostMessage(_unwrap(message), _unwrap(transfer));
      return;
    }
  }
}

class _MessagePortEventsImpl extends _EventsImpl implements MessagePortEvents {
  _MessagePortEventsImpl(_ptr) : super(_ptr);

  EventListenerList get message() => _get('message');
}

class _MetaElementImpl extends _ElementImpl implements MetaElement {
  _MetaElementImpl._wrap(ptr) : super._wrap(ptr);

  String get content() => _wrap(_ptr.content);

  void set content(String value) { _ptr.content = _unwrap(value); }

  String get httpEquiv() => _wrap(_ptr.httpEquiv);

  void set httpEquiv(String value) { _ptr.httpEquiv = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get scheme() => _wrap(_ptr.scheme);

  void set scheme(String value) { _ptr.scheme = _unwrap(value); }
}

class _MetadataImpl extends _DOMTypeBase implements Metadata {
  _MetadataImpl._wrap(ptr) : super._wrap(ptr);

  Date get modificationTime() => _wrap(_ptr.modificationTime);

  int get size() => _wrap(_ptr.size);
}

class _MeterElementImpl extends _ElementImpl implements MeterElement {
  _MeterElementImpl._wrap(ptr) : super._wrap(ptr);

  num get high() => _wrap(_ptr.high);

  void set high(num value) { _ptr.high = _unwrap(value); }

  NodeList get labels() => _wrap(_ptr.labels);

  num get low() => _wrap(_ptr.low);

  void set low(num value) { _ptr.low = _unwrap(value); }

  num get max() => _wrap(_ptr.max);

  void set max(num value) { _ptr.max = _unwrap(value); }

  num get min() => _wrap(_ptr.min);

  void set min(num value) { _ptr.min = _unwrap(value); }

  num get optimum() => _wrap(_ptr.optimum);

  void set optimum(num value) { _ptr.optimum = _unwrap(value); }

  num get value() => _wrap(_ptr.value);

  void set value(num value) { _ptr.value = _unwrap(value); }
}

class _ModElementImpl extends _ElementImpl implements ModElement {
  _ModElementImpl._wrap(ptr) : super._wrap(ptr);

  String get cite() => _wrap(_ptr.cite);

  void set cite(String value) { _ptr.cite = _unwrap(value); }

  String get dateTime() => _wrap(_ptr.dateTime);

  void set dateTime(String value) { _ptr.dateTime = _unwrap(value); }
}

class _MouseEventImpl extends _UIEventImpl implements MouseEvent {
  _MouseEventImpl._wrap(ptr) : super._wrap(ptr);

  bool get altKey() => _wrap(_ptr.altKey);

  int get button() => _wrap(_ptr.button);

  int get clientX() => _wrap(_ptr.clientX);

  int get clientY() => _wrap(_ptr.clientY);

  bool get ctrlKey() => _wrap(_ptr.ctrlKey);

  Clipboard get dataTransfer() => _wrap(_ptr.dataTransfer);

  Node get fromElement() => _wrap(_ptr.fromElement);

  bool get metaKey() => _wrap(_ptr.metaKey);

  int get offsetX() => _wrap(_ptr.offsetX);

  int get offsetY() => _wrap(_ptr.offsetY);

  EventTarget get relatedTarget() => _wrap(_ptr.relatedTarget);

  int get screenX() => _wrap(_ptr.screenX);

  int get screenY() => _wrap(_ptr.screenY);

  bool get shiftKey() => _wrap(_ptr.shiftKey);

  Node get toElement() => _wrap(_ptr.toElement);

  int get webkitMovementX() => _wrap(_ptr.webkitMovementX);

  int get webkitMovementY() => _wrap(_ptr.webkitMovementY);

  int get x() => _wrap(_ptr.x);

  int get y() => _wrap(_ptr.y);

  void $dom_initMouseEvent(String type, bool canBubble, bool cancelable, Window view, int detail, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, int button, EventTarget relatedTarget) {
    _ptr.initMouseEvent(_unwrap(type), _unwrap(canBubble), _unwrap(cancelable), _unwrap(view), _unwrap(detail), _unwrap(screenX), _unwrap(screenY), _unwrap(clientX), _unwrap(clientY), _unwrap(ctrlKey), _unwrap(altKey), _unwrap(shiftKey), _unwrap(metaKey), _unwrap(button), _unwrap(relatedTarget));
    return;
  }
}

class _MutationCallbackImpl extends _DOMTypeBase implements MutationCallback {
  _MutationCallbackImpl._wrap(ptr) : super._wrap(ptr);
}

class _MutationEventImpl extends _EventImpl implements MutationEvent {
  _MutationEventImpl._wrap(ptr) : super._wrap(ptr);

  int get attrChange() => _wrap(_ptr.attrChange);

  String get attrName() => _wrap(_ptr.attrName);

  String get newValue() => _wrap(_ptr.newValue);

  String get prevValue() => _wrap(_ptr.prevValue);

  Node get relatedNode() => _wrap(_ptr.relatedNode);

  void initMutationEvent(String type, bool canBubble, bool cancelable, Node relatedNode, String prevValue, String newValue, String attrName, int attrChange) {
    _ptr.initMutationEvent(_unwrap(type), _unwrap(canBubble), _unwrap(cancelable), _unwrap(relatedNode), _unwrap(prevValue), _unwrap(newValue), _unwrap(attrName), _unwrap(attrChange));
    return;
  }
}

class _MutationRecordImpl extends _DOMTypeBase implements MutationRecord {
  _MutationRecordImpl._wrap(ptr) : super._wrap(ptr);

  NodeList get addedNodes() => _wrap(_ptr.addedNodes);

  String get attributeName() => _wrap(_ptr.attributeName);

  String get attributeNamespace() => _wrap(_ptr.attributeNamespace);

  Node get nextSibling() => _wrap(_ptr.nextSibling);

  String get oldValue() => _wrap(_ptr.oldValue);

  Node get previousSibling() => _wrap(_ptr.previousSibling);

  NodeList get removedNodes() => _wrap(_ptr.removedNodes);

  Node get target() => _wrap(_ptr.target);

  String get type() => _wrap(_ptr.type);
}

class _NamedNodeMapImpl extends _DOMTypeBase implements NamedNodeMap {
  _NamedNodeMapImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Node operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, Node value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }
  // -- start List<Node> mixins.
  // Node is the element type.

  // From Iterable<Node>:

  Iterator<Node> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<Node>(this);
  }

  // From Collection<Node>:

  void add(Node value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(Node value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<Node> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(Node element)) => _Collections.forEach(this, f);

  Collection map(f(Node element)) => _Collections.map(this, [], f);

  Collection<Node> filter(bool f(Node element)) =>
     _Collections.filter(this, <Node>[], f);

  bool every(bool f(Node element)) => _Collections.every(this, f);

  bool some(bool f(Node element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<Node>:

  void sort(int compare(Node a, Node b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(Node element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Node element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  Node last() => this[length - 1];

  Node removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<Node> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [Node initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<Node> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <Node>[]);

  // -- end List<Node> mixins.

  Node getNamedItem(String name) {
    return _wrap(_ptr.getNamedItem(_unwrap(name)));
  }

  Node getNamedItemNS(String namespaceURI, String localName) {
    return _wrap(_ptr.getNamedItemNS(_unwrap(namespaceURI), _unwrap(localName)));
  }

  Node item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }

  Node removeNamedItem(String name) {
    return _wrap(_ptr.removeNamedItem(_unwrap(name)));
  }

  Node removeNamedItemNS(String namespaceURI, String localName) {
    return _wrap(_ptr.removeNamedItemNS(_unwrap(namespaceURI), _unwrap(localName)));
  }

  Node setNamedItem(Node node) {
    return _wrap(_ptr.setNamedItem(_unwrap(node)));
  }

  Node setNamedItemNS(Node node) {
    return _wrap(_ptr.setNamedItemNS(_unwrap(node)));
  }
}

class _NavigatorImpl extends _DOMTypeBase implements Navigator {
  _NavigatorImpl._wrap(ptr) : super._wrap(ptr);

  String get appCodeName() => _wrap(_ptr.appCodeName);

  String get appName() => _wrap(_ptr.appName);

  String get appVersion() => _wrap(_ptr.appVersion);

  bool get cookieEnabled() => _wrap(_ptr.cookieEnabled);

  Geolocation get geolocation() => _wrap(_ptr.geolocation);

  String get language() => _wrap(_ptr.language);

  DOMMimeTypeArray get mimeTypes() => _wrap(_ptr.mimeTypes);

  bool get onLine() => _wrap(_ptr.onLine);

  String get platform() => _wrap(_ptr.platform);

  DOMPluginArray get plugins() => _wrap(_ptr.plugins);

  String get product() => _wrap(_ptr.product);

  String get productSub() => _wrap(_ptr.productSub);

  String get userAgent() => _wrap(_ptr.userAgent);

  String get vendor() => _wrap(_ptr.vendor);

  String get vendorSub() => _wrap(_ptr.vendorSub);

  BatteryManager get webkitBattery() => _wrap(_ptr.webkitBattery);

  PointerLock get webkitPointer() => _wrap(_ptr.webkitPointer);

  void getStorageUpdates() {
    _ptr.getStorageUpdates();
    return;
  }

  bool javaEnabled() {
    return _wrap(_ptr.javaEnabled());
  }

  void registerProtocolHandler(String scheme, String url, String title) {
    _ptr.registerProtocolHandler(_unwrap(scheme), _unwrap(url), _unwrap(title));
    return;
  }

  void webkitGetUserMedia(Map options, NavigatorUserMediaSuccessCallback successCallback, [NavigatorUserMediaErrorCallback errorCallback = null]) {
    if (errorCallback === null) {
      _ptr.webkitGetUserMedia(_unwrap(options), _unwrap(successCallback));
      return;
    } else {
      _ptr.webkitGetUserMedia(_unwrap(options), _unwrap(successCallback), _unwrap(errorCallback));
      return;
    }
  }
}

class _NavigatorUserMediaErrorImpl extends _DOMTypeBase implements NavigatorUserMediaError {
  _NavigatorUserMediaErrorImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Lazy implementation of the child nodes of an element that does not request
 * the actual child nodes of an element until strictly necessary greatly
 * improving performance for the typical cases where it is not required.
 */
class _ChildNodeListLazy implements NodeList {
  final _NodeImpl _this;

  _ChildNodeListLazy(this._this);


  _NodeImpl get first() => _this.$dom_firstChild;
  _NodeImpl last() => _this.$dom_lastChild;

  void add(_NodeImpl value) {
    _this.$dom_appendChild(value);
  }

  void addLast(_NodeImpl value) {
    _this.$dom_appendChild(value);
  }


  void addAll(Collection<_NodeImpl> collection) {
    for (_NodeImpl node in collection) {
      _this.$dom_appendChild(node);
    }
  }

  _NodeImpl removeLast() {
    final result = last();
    if (result != null) {
      _this.$dom_removeChild(result);
    }
    return result;
  }

  void clear() {
    _this.text = '';
  }

  void operator []=(int index, _NodeImpl value) {
    _this.$dom_replaceChild(value, this[index]);
  }

  Iterator<Node> iterator() => _this.$dom_childNodes.iterator();

  // TODO(jacobr): We can implement these methods much more efficiently by
  // looking up the nodeList only once instead of once per iteration.
  void forEach(void f(Node element)) => _Collections.forEach(this, f);

  Collection map(f(Node element)) => _Collections.map(this, [], f);

  Collection<Node> filter(bool f(Node element)) =>
     new _NodeListWrapper(_Collections.filter(this, <Node>[], f));

  bool every(bool f(Node element)) => _Collections.every(this, f);

  bool some(bool f(Node element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<Node>:

  // TODO(jacobr): this could be implemented for child node lists.
  // The exception we throw here is misleading.
  void sort(int compare(Node a, Node b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(Node element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Node element, [int start = 0]) =>
      _Lists.lastIndexOf(this, element, start);

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<Node> from, [int startFrom]) {
    throw new UnsupportedOperationException(
        "Cannot setRange on immutable List.");
  }
  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException(
        "Cannot removeRange on immutable List.");
  }
  void insertRange(int start, int rangeLength, [Node initialValue]) {
    throw new UnsupportedOperationException(
        "Cannot insertRange on immutable List.");
  }
  NodeList getRange(int start, int rangeLength) =>
    new _NodeListWrapper(_Lists.getRange(this, start, rangeLength, <Node>[]));

  // -- end List<Node> mixins.

  // TODO(jacobr): benchmark whether this is more efficient or whether caching
  // a local copy of $dom_childNodes is more efficient.
  int get length() => _this.$dom_childNodes.length;

  _NodeImpl operator[](int index) => _this.$dom_childNodes[index];
}

class _NodeImpl extends _EventTargetImpl implements Node {
  _ChildNodeListLazy get nodes() {
    return new _ChildNodeListLazy(this);
  }

  void set nodes(Collection<Node> value) {
    // Copy list first since we don't want liveness during iteration.
    // TODO(jacobr): there is a better way to do this.
    List copy = new List.from(value);
    text = '';
    for (Node node in copy) {
      $dom_appendChild(node);
    }
  }

  // TODO(jacobr): should we throw an exception if parent is already null?
  _NodeImpl remove() {
    if (this.parent != null) {
      final _NodeImpl parent = this.parent;
      parent.$dom_removeChild(this);
    }
    return this;
  }

  _NodeImpl replaceWith(Node otherNode) {
    try {
      final _NodeImpl parent = this.parent;
      parent.$dom_replaceChild(otherNode, this);
    } catch(var e) {
      
    };
    return this;
  }

  _NodeImpl._wrap(ptr) : super._wrap(ptr);

  NamedNodeMap get $dom_attributes() => _wrap(_ptr.attributes);

  NodeList get $dom_childNodes() => _wrap(_ptr.childNodes);

  Node get $dom_firstChild() => _wrap(_ptr.firstChild);

  Node get $dom_lastChild() => _wrap(_ptr.lastChild);

  Node get nextNode() => _wrap(_ptr.nextSibling);

  int get $dom_nodeType() => _wrap(_ptr.nodeType);

  Document get document() => _wrap(_ptr.ownerDocument);

  Node get parent() => _wrap(_ptr.parentNode);

  Node get previousNode() => _wrap(_ptr.previousSibling);

  String get text() => _wrap(_ptr.textContent);

  void set text(String value) { _ptr.textContent = _unwrap(value); }

  Node $dom_appendChild(Node newChild) {
    return _wrap(_ptr.appendChild(_unwrap(newChild)));
  }

  Node clone(bool deep) {
    return _wrap(_ptr.cloneNode(_unwrap(deep)));
  }

  bool contains(Node other) {
    return _wrap(_ptr.contains(_unwrap(other)));
  }

  bool hasChildNodes() {
    return _wrap(_ptr.hasChildNodes());
  }

  Node insertBefore(Node newChild, Node refChild) {
    return _wrap(_ptr.insertBefore(_unwrap(newChild), _unwrap(refChild)));
  }

  Node $dom_removeChild(Node oldChild) {
    return _wrap(_ptr.removeChild(_unwrap(oldChild)));
  }

  Node $dom_replaceChild(Node newChild, Node oldChild) {
    return _wrap(_ptr.replaceChild(_unwrap(newChild), _unwrap(oldChild)));
  }

}

class _NodeFilterImpl extends _DOMTypeBase implements NodeFilter {
  _NodeFilterImpl._wrap(ptr) : super._wrap(ptr);

  int acceptNode(Node n) {
    return _wrap(_ptr.acceptNode(_unwrap(n)));
  }
}

class _NodeIteratorImpl extends _DOMTypeBase implements NodeIterator {
  _NodeIteratorImpl._wrap(ptr) : super._wrap(ptr);

  bool get expandEntityReferences() => _wrap(_ptr.expandEntityReferences);

  NodeFilter get filter() => _wrap(_ptr.filter);

  bool get pointerBeforeReferenceNode() => _wrap(_ptr.pointerBeforeReferenceNode);

  Node get referenceNode() => _wrap(_ptr.referenceNode);

  Node get root() => _wrap(_ptr.root);

  int get whatToShow() => _wrap(_ptr.whatToShow);

  void detach() {
    _ptr.detach();
    return;
  }

  Node nextNode() {
    return _wrap(_ptr.nextNode());
  }

  Node previousNode() {
    return _wrap(_ptr.previousNode());
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// TODO(nweiz): when all implementations we target have the same name for the
// coreimpl implementation of List<E>, extend that rather than wrapping.
class _ListWrapper<E> implements List<E> {
  List _list;

  _ListWrapper(List this._list);

  Iterator<E> iterator() => _list.iterator();

  void forEach(void f(E element)) => _list.forEach(f);

  Collection map(f(E element)) => _list.map(f);

  List<E> filter(bool f(E element)) => _list.filter(f);

  bool every(bool f(E element)) => _list.every(f);

  bool some(bool f(E element)) => _list.some(f);

  bool isEmpty() => _list.isEmpty();

  int get length() => _list.length;

  E operator [](int index) => _list[index];

  void operator []=(int index, E value) { _list[index] = value; }

  void set length(int newLength) { _list.length = newLength; }

  void add(E value) => _list.add(value);

  void addLast(E value) => _list.addLast(value);

  void addAll(Collection<E> collection) => _list.addAll(collection);

  void sort(int compare(E a, E b)) => _list.sort(compare);

  int indexOf(E element, [int start = 0]) => _list.indexOf(element, start);

  int lastIndexOf(E element, [int start = 0]) =>
    _list.lastIndexOf(element, start);

  void clear() => _list.clear();

  E removeLast() => _list.removeLast();

  E last() => _list.last();

  List<E> getRange(int start, int rangeLength) =>
    _list.getRange(start, rangeLength);

  void setRange(int start, int rangeLength, List<E> from, [int startFrom = 0])
      => _list.setRange(start, rangeLength, from, startFrom);

  void removeRange(int start, int rangeLength) =>
    _list.removeRange(start, rangeLength);

  void insertRange(int start, int rangeLength, [E initialValue = null]) =>
    _list.insertRange(start, rangeLength, initialValue);

  E get first() => _list[0];
}

/**
 * This class is used to insure the results of list operations are NodeLists
 * instead of lists.
 */
class _NodeListWrapper extends _ListWrapper<Node> implements NodeList {
  _NodeListWrapper(List list) : super(list);

  NodeList filter(bool f(Node element)) =>
    new _NodeListWrapper(_list.filter(f));

  NodeList getRange(int start, int rangeLength) =>
    new _NodeListWrapper(_list.getRange(start, rangeLength));
}

class _NodeListImpl extends _DOMTypeBase implements NodeList {
  _NodeImpl _parent;

  // -- start List<Node> mixins.
  // Node is the element type.

  // From Iterable<Node>:

  Iterator<Node> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<Node>(this);
  }

  // From Collection<Node>:

  void add(_NodeImpl value) {
    _parent.$dom_appendChild(value);
  }

  void addLast(_NodeImpl value) {
    _parent.$dom_appendChild(value);
  }

  void addAll(Collection<_NodeImpl> collection) {
    for (_NodeImpl node in collection) {
      _parent.$dom_appendChild(node);      
    }
  }

  _NodeImpl removeLast() {
    final result = this.last();
    if (result != null) {
      _parent.$dom_removeChild(result);
    }
    return result;
  }

  void clear() {
    _parent.text = '';
  }

  void operator []=(int index, _NodeImpl value) {
    _parent.$dom_replaceChild(value, this[index]);
  }

  void forEach(void f(Node element)) => _Collections.forEach(this, f);

  Collection map(f(Node element)) => _Collections.map(this, [], f);

  Collection<Node> filter(bool f(Node element)) =>
     new _NodeListWrapper(_Collections.filter(this, <Node>[], f));

  bool every(bool f(Node element)) => _Collections.every(this, f);

  bool some(bool f(Node element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<Node>:

  void sort(int compare(Node a, Node b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(Node element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Node element, [int start = 0]) =>
      _Lists.lastIndexOf(this, element, start);

  Node last() => this[length - 1];
  Node get first() => this[0];

  // FIXME: implement thesee.
  void setRange(int start, int rangeLength, List<Node> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }
  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }
  void insertRange(int start, int rangeLength, [Node initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }
  NodeList getRange(int start, int rangeLength) =>
    new _NodeListWrapper(_Lists.getRange(this, start, rangeLength, <Node>[]));

  // -- end List<Node> mixins.

  _NodeListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Node operator[](int index) => _wrap(_ptr[index]);

}

class _NodeSelectorImpl extends _DOMTypeBase implements NodeSelector {
  _NodeSelectorImpl._wrap(ptr) : super._wrap(ptr);

  Element query(String selectors) {
    return _wrap(_ptr.querySelector(_unwrap(selectors)));
  }

  NodeList $dom_querySelectorAll(String selectors) {
    return _wrap(_ptr.querySelectorAll(_unwrap(selectors)));
  }
}

class _NotationImpl extends _NodeImpl implements Notation {
  _NotationImpl._wrap(ptr) : super._wrap(ptr);

  String get publicId() => _wrap(_ptr.publicId);

  String get systemId() => _wrap(_ptr.systemId);
}

class _NotificationImpl extends _EventTargetImpl implements Notification {
  _NotificationImpl._wrap(ptr) : super._wrap(ptr);

  _NotificationEventsImpl get on() {
    if (_on == null) _on = new _NotificationEventsImpl(this);
    return _on;
  }

  String get dir() => _wrap(_ptr.dir);

  void set dir(String value) { _ptr.dir = _unwrap(value); }

  String get replaceId() => _wrap(_ptr.replaceId);

  void set replaceId(String value) { _ptr.replaceId = _unwrap(value); }

  String get tag() => _wrap(_ptr.tag);

  void set tag(String value) { _ptr.tag = _unwrap(value); }

  void cancel() {
    _ptr.cancel();
    return;
  }

  void close() {
    _ptr.close();
    return;
  }

  void show() {
    _ptr.show();
    return;
  }
}

class _NotificationEventsImpl extends _EventsImpl implements NotificationEvents {
  _NotificationEventsImpl(_ptr) : super(_ptr);

  EventListenerList get click() => _get('click');

  EventListenerList get close() => _get('close');

  EventListenerList get display() => _get('display');

  EventListenerList get error() => _get('error');

  EventListenerList get show() => _get('show');
}

class _NotificationCenterImpl extends _DOMTypeBase implements NotificationCenter {
  _NotificationCenterImpl._wrap(ptr) : super._wrap(ptr);

  int checkPermission() {
    return _wrap(_ptr.checkPermission());
  }

  Notification createHTMLNotification(String url) {
    return _wrap(_ptr.createHTMLNotification(_unwrap(url)));
  }

  Notification createNotification(String iconUrl, String title, String body) {
    return _wrap(_ptr.createNotification(_unwrap(iconUrl), _unwrap(title), _unwrap(body)));
  }

  void requestPermission(VoidCallback callback) {
    _ptr.requestPermission(_unwrap(callback));
    return;
  }
}

class _OESStandardDerivativesImpl extends _DOMTypeBase implements OESStandardDerivatives {
  _OESStandardDerivativesImpl._wrap(ptr) : super._wrap(ptr);
}

class _OESTextureFloatImpl extends _DOMTypeBase implements OESTextureFloat {
  _OESTextureFloatImpl._wrap(ptr) : super._wrap(ptr);
}

class _OESVertexArrayObjectImpl extends _DOMTypeBase implements OESVertexArrayObject {
  _OESVertexArrayObjectImpl._wrap(ptr) : super._wrap(ptr);

  void bindVertexArrayOES(WebGLVertexArrayObjectOES arrayObject) {
    _ptr.bindVertexArrayOES(_unwrap(arrayObject));
    return;
  }

  WebGLVertexArrayObjectOES createVertexArrayOES() {
    return _wrap(_ptr.createVertexArrayOES());
  }

  void deleteVertexArrayOES(WebGLVertexArrayObjectOES arrayObject) {
    _ptr.deleteVertexArrayOES(_unwrap(arrayObject));
    return;
  }

  bool isVertexArrayOES(WebGLVertexArrayObjectOES arrayObject) {
    return _wrap(_ptr.isVertexArrayOES(_unwrap(arrayObject)));
  }
}

class _OListElementImpl extends _ElementImpl implements OListElement {
  _OListElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get compact() => _wrap(_ptr.compact);

  void set compact(bool value) { _ptr.compact = _unwrap(value); }

  bool get reversed() => _wrap(_ptr.reversed);

  void set reversed(bool value) { _ptr.reversed = _unwrap(value); }

  int get start() => _wrap(_ptr.start);

  void set start(int value) { _ptr.start = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }
}

class _ObjectElementImpl extends _ElementImpl implements ObjectElement {
  _ObjectElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get archive() => _wrap(_ptr.archive);

  void set archive(String value) { _ptr.archive = _unwrap(value); }

  String get border() => _wrap(_ptr.border);

  void set border(String value) { _ptr.border = _unwrap(value); }

  String get code() => _wrap(_ptr.code);

  void set code(String value) { _ptr.code = _unwrap(value); }

  String get codeBase() => _wrap(_ptr.codeBase);

  void set codeBase(String value) { _ptr.codeBase = _unwrap(value); }

  String get codeType() => _wrap(_ptr.codeType);

  void set codeType(String value) { _ptr.codeType = _unwrap(value); }

  Document get contentDocument() => _wrap(_ptr.contentDocument);

  String get data() => _wrap(_ptr.data);

  void set data(String value) { _ptr.data = _unwrap(value); }

  bool get declare() => _wrap(_ptr.declare);

  void set declare(bool value) { _ptr.declare = _unwrap(value); }

  FormElement get form() => _wrap(_ptr.form);

  String get height() => _wrap(_ptr.height);

  void set height(String value) { _ptr.height = _unwrap(value); }

  int get hspace() => _wrap(_ptr.hspace);

  void set hspace(int value) { _ptr.hspace = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get standby() => _wrap(_ptr.standby);

  void set standby(String value) { _ptr.standby = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }

  String get useMap() => _wrap(_ptr.useMap);

  void set useMap(String value) { _ptr.useMap = _unwrap(value); }

  String get validationMessage() => _wrap(_ptr.validationMessage);

  ValidityState get validity() => _wrap(_ptr.validity);

  int get vspace() => _wrap(_ptr.vspace);

  void set vspace(int value) { _ptr.vspace = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }

  bool get willValidate() => _wrap(_ptr.willValidate);

  bool checkValidity() {
    return _wrap(_ptr.checkValidity());
  }

  void setCustomValidity(String error) {
    _ptr.setCustomValidity(_unwrap(error));
    return;
  }
}

class _OfflineAudioCompletionEventImpl extends _EventImpl implements OfflineAudioCompletionEvent {
  _OfflineAudioCompletionEventImpl._wrap(ptr) : super._wrap(ptr);

  AudioBuffer get renderedBuffer() => _wrap(_ptr.renderedBuffer);
}

class _OperationNotAllowedExceptionImpl extends _DOMTypeBase implements OperationNotAllowedException {
  _OperationNotAllowedExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _OptGroupElementImpl extends _ElementImpl implements OptGroupElement {
  _OptGroupElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  String get label() => _wrap(_ptr.label);

  void set label(String value) { _ptr.label = _unwrap(value); }
}

class _OptionElementImpl extends _ElementImpl implements OptionElement {
  _OptionElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get defaultSelected() => _wrap(_ptr.defaultSelected);

  void set defaultSelected(bool value) { _ptr.defaultSelected = _unwrap(value); }

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  FormElement get form() => _wrap(_ptr.form);

  int get index() => _wrap(_ptr.index);

  String get label() => _wrap(_ptr.label);

  void set label(String value) { _ptr.label = _unwrap(value); }

  bool get selected() => _wrap(_ptr.selected);

  void set selected(bool value) { _ptr.selected = _unwrap(value); }

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }
}

class _OscillatorImpl extends _AudioSourceNodeImpl implements Oscillator {
  _OscillatorImpl._wrap(ptr) : super._wrap(ptr);

  AudioParam get detune() => _wrap(_ptr.detune);

  AudioParam get frequency() => _wrap(_ptr.frequency);

  int get type() => _wrap(_ptr.type);

  void set type(int value) { _ptr.type = _unwrap(value); }

  void setWaveTable(WaveTable waveTable) {
    _ptr.setWaveTable(_unwrap(waveTable));
    return;
  }
}

class _OutputElementImpl extends _ElementImpl implements OutputElement {
  _OutputElementImpl._wrap(ptr) : super._wrap(ptr);

  String get defaultValue() => _wrap(_ptr.defaultValue);

  void set defaultValue(String value) { _ptr.defaultValue = _unwrap(value); }

  FormElement get form() => _wrap(_ptr.form);

  DOMSettableTokenList get htmlFor() => _wrap(_ptr.htmlFor);

  void set htmlFor(DOMSettableTokenList value) { _ptr.htmlFor = _unwrap(value); }

  NodeList get labels() => _wrap(_ptr.labels);

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  String get validationMessage() => _wrap(_ptr.validationMessage);

  ValidityState get validity() => _wrap(_ptr.validity);

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }

  bool get willValidate() => _wrap(_ptr.willValidate);

  bool checkValidity() {
    return _wrap(_ptr.checkValidity());
  }

  void setCustomValidity(String error) {
    _ptr.setCustomValidity(_unwrap(error));
    return;
  }
}

class _OverflowEventImpl extends _EventImpl implements OverflowEvent {
  _OverflowEventImpl._wrap(ptr) : super._wrap(ptr);

  bool get horizontalOverflow() => _wrap(_ptr.horizontalOverflow);

  int get orient() => _wrap(_ptr.orient);

  bool get verticalOverflow() => _wrap(_ptr.verticalOverflow);
}

class _PageTransitionEventImpl extends _EventImpl implements PageTransitionEvent {
  _PageTransitionEventImpl._wrap(ptr) : super._wrap(ptr);

  bool get persisted() => _wrap(_ptr.persisted);
}

class _ParagraphElementImpl extends _ElementImpl implements ParagraphElement {
  _ParagraphElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }
}

class _ParamElementImpl extends _ElementImpl implements ParamElement {
  _ParamElementImpl._wrap(ptr) : super._wrap(ptr);

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }

  String get valueType() => _wrap(_ptr.valueType);

  void set valueType(String value) { _ptr.valueType = _unwrap(value); }
}

class _PeerConnection00Impl extends _EventTargetImpl implements PeerConnection00 {
  _PeerConnection00Impl._wrap(ptr) : super._wrap(ptr);

  _PeerConnection00EventsImpl get on() {
    if (_on == null) _on = new _PeerConnection00EventsImpl(this);
    return _on;
  }

  int get iceState() => _wrap(_ptr.iceState);

  SessionDescription get localDescription() => _wrap(_ptr.localDescription);

  MediaStreamList get localStreams() => _wrap(_ptr.localStreams);

  int get readyState() => _wrap(_ptr.readyState);

  SessionDescription get remoteDescription() => _wrap(_ptr.remoteDescription);

  MediaStreamList get remoteStreams() => _wrap(_ptr.remoteStreams);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void addStream(MediaStream stream, [String mediaStreamHints = null]) {
    if (mediaStreamHints === null) {
      _ptr.addStream(_unwrap(stream));
      return;
    } else {
      _ptr.addStream(_unwrap(stream), _unwrap(mediaStreamHints));
      return;
    }
  }

  void close() {
    _ptr.close();
    return;
  }

  SessionDescription createAnswer(String offer, [String mediaHints = null]) {
    if (mediaHints === null) {
      return _wrap(_ptr.createAnswer(_unwrap(offer)));
    } else {
      return _wrap(_ptr.createAnswer(_unwrap(offer), _unwrap(mediaHints)));
    }
  }

  SessionDescription createOffer([String mediaHints = null]) {
    if (mediaHints === null) {
      return _wrap(_ptr.createOffer());
    } else {
      return _wrap(_ptr.createOffer(_unwrap(mediaHints)));
    }
  }

  bool $dom_dispatchEvent(Event event) {
    return _wrap(_ptr.dispatchEvent(_unwrap(event)));
  }

  void processIceMessage(IceCandidate candidate) {
    _ptr.processIceMessage(_unwrap(candidate));
    return;
  }

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void removeStream(MediaStream stream) {
    _ptr.removeStream(_unwrap(stream));
    return;
  }

  void setLocalDescription(int action, SessionDescription desc) {
    _ptr.setLocalDescription(_unwrap(action), _unwrap(desc));
    return;
  }

  void setRemoteDescription(int action, SessionDescription desc) {
    _ptr.setRemoteDescription(_unwrap(action), _unwrap(desc));
    return;
  }

  void startIce([String iceOptions = null]) {
    if (iceOptions === null) {
      _ptr.startIce();
      return;
    } else {
      _ptr.startIce(_unwrap(iceOptions));
      return;
    }
  }
}

class _PeerConnection00EventsImpl extends _EventsImpl implements PeerConnection00Events {
  _PeerConnection00EventsImpl(_ptr) : super(_ptr);

  EventListenerList get addStream() => _get('addstream');

  EventListenerList get connecting() => _get('connecting');

  EventListenerList get open() => _get('open');

  EventListenerList get removeStream() => _get('removestream');

  EventListenerList get stateChange() => _get('statechange');
}

class _PerformanceImpl extends _DOMTypeBase implements Performance {
  _PerformanceImpl._wrap(ptr) : super._wrap(ptr);

  MemoryInfo get memory() => _wrap(_ptr.memory);

  PerformanceNavigation get navigation() => _wrap(_ptr.navigation);

  PerformanceTiming get timing() => _wrap(_ptr.timing);

  num webkitNow() {
    return _wrap(_ptr.webkitNow());
  }
}

class _PerformanceNavigationImpl extends _DOMTypeBase implements PerformanceNavigation {
  _PerformanceNavigationImpl._wrap(ptr) : super._wrap(ptr);

  int get redirectCount() => _wrap(_ptr.redirectCount);

  int get type() => _wrap(_ptr.type);
}

class _PerformanceTimingImpl extends _DOMTypeBase implements PerformanceTiming {
  _PerformanceTimingImpl._wrap(ptr) : super._wrap(ptr);

  int get connectEnd() => _wrap(_ptr.connectEnd);

  int get connectStart() => _wrap(_ptr.connectStart);

  int get domComplete() => _wrap(_ptr.domComplete);

  int get domContentLoadedEventEnd() => _wrap(_ptr.domContentLoadedEventEnd);

  int get domContentLoadedEventStart() => _wrap(_ptr.domContentLoadedEventStart);

  int get domInteractive() => _wrap(_ptr.domInteractive);

  int get domLoading() => _wrap(_ptr.domLoading);

  int get domainLookupEnd() => _wrap(_ptr.domainLookupEnd);

  int get domainLookupStart() => _wrap(_ptr.domainLookupStart);

  int get fetchStart() => _wrap(_ptr.fetchStart);

  int get loadEventEnd() => _wrap(_ptr.loadEventEnd);

  int get loadEventStart() => _wrap(_ptr.loadEventStart);

  int get navigationStart() => _wrap(_ptr.navigationStart);

  int get redirectEnd() => _wrap(_ptr.redirectEnd);

  int get redirectStart() => _wrap(_ptr.redirectStart);

  int get requestStart() => _wrap(_ptr.requestStart);

  int get responseEnd() => _wrap(_ptr.responseEnd);

  int get responseStart() => _wrap(_ptr.responseStart);

  int get secureConnectionStart() => _wrap(_ptr.secureConnectionStart);

  int get unloadEventEnd() => _wrap(_ptr.unloadEventEnd);

  int get unloadEventStart() => _wrap(_ptr.unloadEventStart);
}

class _PointImpl extends _DOMTypeBase implements Point {
  _PointImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _PointerLockImpl extends _DOMTypeBase implements PointerLock {
  _PointerLockImpl._wrap(ptr) : super._wrap(ptr);

  bool get isLocked() => _wrap(_ptr.isLocked);

  void lock(Element target, [VoidCallback successCallback = null, VoidCallback failureCallback = null]) {
    if (successCallback === null) {
      if (failureCallback === null) {
        _ptr.lock(_unwrap(target));
        return;
      }
    } else {
      if (failureCallback === null) {
        _ptr.lock(_unwrap(target), _unwrap(successCallback));
        return;
      } else {
        _ptr.lock(_unwrap(target), _unwrap(successCallback), _unwrap(failureCallback));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void unlock() {
    _ptr.unlock();
    return;
  }
}

class _PopStateEventImpl extends _EventImpl implements PopStateEvent {
  _PopStateEventImpl._wrap(ptr) : super._wrap(ptr);

  Object get state() => _wrap(_ptr.state);
}

class _PositionErrorImpl extends _DOMTypeBase implements PositionError {
  _PositionErrorImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);
}

class _PreElementImpl extends _ElementImpl implements PreElement {
  _PreElementImpl._wrap(ptr) : super._wrap(ptr);

  int get width() => _wrap(_ptr.width);

  void set width(int value) { _ptr.width = _unwrap(value); }

  bool get wrap() => _wrap(_ptr.wrap);

  void set wrap(bool value) { _ptr.wrap = _unwrap(value); }
}

class _ProcessingInstructionImpl extends _NodeImpl implements ProcessingInstruction {
  _ProcessingInstructionImpl._wrap(ptr) : super._wrap(ptr);

  String get data() => _wrap(_ptr.data);

  void set data(String value) { _ptr.data = _unwrap(value); }

  StyleSheet get sheet() => _wrap(_ptr.sheet);

  String get target() => _wrap(_ptr.target);
}

class _ProgressElementImpl extends _ElementImpl implements ProgressElement {
  _ProgressElementImpl._wrap(ptr) : super._wrap(ptr);

  NodeList get labels() => _wrap(_ptr.labels);

  num get max() => _wrap(_ptr.max);

  void set max(num value) { _ptr.max = _unwrap(value); }

  num get position() => _wrap(_ptr.position);

  num get value() => _wrap(_ptr.value);

  void set value(num value) { _ptr.value = _unwrap(value); }
}

class _ProgressEventImpl extends _EventImpl implements ProgressEvent {
  _ProgressEventImpl._wrap(ptr) : super._wrap(ptr);

  bool get lengthComputable() => _wrap(_ptr.lengthComputable);

  int get loaded() => _wrap(_ptr.loaded);

  int get total() => _wrap(_ptr.total);
}

class _QuoteElementImpl extends _ElementImpl implements QuoteElement {
  _QuoteElementImpl._wrap(ptr) : super._wrap(ptr);

  String get cite() => _wrap(_ptr.cite);

  void set cite(String value) { _ptr.cite = _unwrap(value); }
}

class _RGBColorImpl extends _DOMTypeBase implements RGBColor {
  _RGBColorImpl._wrap(ptr) : super._wrap(ptr);

  CSSPrimitiveValue get blue() => _wrap(_ptr.blue);

  CSSPrimitiveValue get green() => _wrap(_ptr.green);

  CSSPrimitiveValue get red() => _wrap(_ptr.red);
}

class _RangeImpl extends _DOMTypeBase implements Range {
  _RangeImpl._wrap(ptr) : super._wrap(ptr);

  bool get collapsed() => _wrap(_ptr.collapsed);

  Node get commonAncestorContainer() => _wrap(_ptr.commonAncestorContainer);

  Node get endContainer() => _wrap(_ptr.endContainer);

  int get endOffset() => _wrap(_ptr.endOffset);

  Node get startContainer() => _wrap(_ptr.startContainer);

  int get startOffset() => _wrap(_ptr.startOffset);

  DocumentFragment cloneContents() {
    return _wrap(_ptr.cloneContents());
  }

  Range cloneRange() {
    return _wrap(_ptr.cloneRange());
  }

  void collapse(bool toStart) {
    _ptr.collapse(_unwrap(toStart));
    return;
  }

  int compareNode(Node refNode) {
    return _wrap(_ptr.compareNode(_unwrap(refNode)));
  }

  int comparePoint(Node refNode, int offset) {
    return _wrap(_ptr.comparePoint(_unwrap(refNode), _unwrap(offset)));
  }

  DocumentFragment createContextualFragment(String html) {
    return _wrap(_ptr.createContextualFragment(_unwrap(html)));
  }

  void deleteContents() {
    _ptr.deleteContents();
    return;
  }

  void detach() {
    _ptr.detach();
    return;
  }

  void expand(String unit) {
    _ptr.expand(_unwrap(unit));
    return;
  }

  DocumentFragment extractContents() {
    return _wrap(_ptr.extractContents());
  }

  ClientRect getBoundingClientRect() {
    return _wrap(_ptr.getBoundingClientRect());
  }

  ClientRectList getClientRects() {
    return _wrap(_ptr.getClientRects());
  }

  void insertNode(Node newNode) {
    _ptr.insertNode(_unwrap(newNode));
    return;
  }

  bool intersectsNode(Node refNode) {
    return _wrap(_ptr.intersectsNode(_unwrap(refNode)));
  }

  bool isPointInRange(Node refNode, int offset) {
    return _wrap(_ptr.isPointInRange(_unwrap(refNode), _unwrap(offset)));
  }

  void selectNode(Node refNode) {
    _ptr.selectNode(_unwrap(refNode));
    return;
  }

  void selectNodeContents(Node refNode) {
    _ptr.selectNodeContents(_unwrap(refNode));
    return;
  }

  void setEnd(Node refNode, int offset) {
    _ptr.setEnd(_unwrap(refNode), _unwrap(offset));
    return;
  }

  void setEndAfter(Node refNode) {
    _ptr.setEndAfter(_unwrap(refNode));
    return;
  }

  void setEndBefore(Node refNode) {
    _ptr.setEndBefore(_unwrap(refNode));
    return;
  }

  void setStart(Node refNode, int offset) {
    _ptr.setStart(_unwrap(refNode), _unwrap(offset));
    return;
  }

  void setStartAfter(Node refNode) {
    _ptr.setStartAfter(_unwrap(refNode));
    return;
  }

  void setStartBefore(Node refNode) {
    _ptr.setStartBefore(_unwrap(refNode));
    return;
  }

  void surroundContents(Node newParent) {
    _ptr.surroundContents(_unwrap(newParent));
    return;
  }

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _RangeExceptionImpl extends _DOMTypeBase implements RangeException {
  _RangeExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _RealtimeAnalyserNodeImpl extends _AudioNodeImpl implements RealtimeAnalyserNode {
  _RealtimeAnalyserNodeImpl._wrap(ptr) : super._wrap(ptr);

  int get fftSize() => _wrap(_ptr.fftSize);

  void set fftSize(int value) { _ptr.fftSize = _unwrap(value); }

  int get frequencyBinCount() => _wrap(_ptr.frequencyBinCount);

  num get maxDecibels() => _wrap(_ptr.maxDecibels);

  void set maxDecibels(num value) { _ptr.maxDecibels = _unwrap(value); }

  num get minDecibels() => _wrap(_ptr.minDecibels);

  void set minDecibels(num value) { _ptr.minDecibels = _unwrap(value); }

  num get smoothingTimeConstant() => _wrap(_ptr.smoothingTimeConstant);

  void set smoothingTimeConstant(num value) { _ptr.smoothingTimeConstant = _unwrap(value); }

  void getByteFrequencyData(Uint8Array array) {
    _ptr.getByteFrequencyData(_unwrap(array));
    return;
  }

  void getByteTimeDomainData(Uint8Array array) {
    _ptr.getByteTimeDomainData(_unwrap(array));
    return;
  }

  void getFloatFrequencyData(Float32Array array) {
    _ptr.getFloatFrequencyData(_unwrap(array));
    return;
  }
}

class _RectImpl extends _DOMTypeBase implements Rect {
  _RectImpl._wrap(ptr) : super._wrap(ptr);

  CSSPrimitiveValue get bottom() => _wrap(_ptr.bottom);

  CSSPrimitiveValue get left() => _wrap(_ptr.left);

  CSSPrimitiveValue get right() => _wrap(_ptr.right);

  CSSPrimitiveValue get top() => _wrap(_ptr.top);
}

class _SQLErrorImpl extends _DOMTypeBase implements SQLError {
  _SQLErrorImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);
}

class _SQLExceptionImpl extends _DOMTypeBase implements SQLException {
  _SQLExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);
}

class _SQLResultSetImpl extends _DOMTypeBase implements SQLResultSet {
  _SQLResultSetImpl._wrap(ptr) : super._wrap(ptr);

  int get insertId() => _wrap(_ptr.insertId);

  SQLResultSetRowList get rows() => _wrap(_ptr.rows);

  int get rowsAffected() => _wrap(_ptr.rowsAffected);
}

class _SQLResultSetRowListImpl extends _DOMTypeBase implements SQLResultSetRowList {
  _SQLResultSetRowListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Object item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _SQLTransactionImpl extends _DOMTypeBase implements SQLTransaction {
  _SQLTransactionImpl._wrap(ptr) : super._wrap(ptr);
}

class _SQLTransactionSyncImpl extends _DOMTypeBase implements SQLTransactionSync {
  _SQLTransactionSyncImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGAElementImpl extends _SVGElementImpl implements SVGAElement {
  _SVGAElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get target() => _wrap(_ptr.target);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGAltGlyphDefElementImpl extends _SVGElementImpl implements SVGAltGlyphDefElement {
  _SVGAltGlyphDefElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGAltGlyphElementImpl extends _SVGTextPositioningElementImpl implements SVGAltGlyphElement {
  _SVGAltGlyphElementImpl._wrap(ptr) : super._wrap(ptr);

  String get format() => _wrap(_ptr.format);

  void set format(String value) { _ptr.format = _unwrap(value); }

  String get glyphRef() => _wrap(_ptr.glyphRef);

  void set glyphRef(String value) { _ptr.glyphRef = _unwrap(value); }

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);
}

class _SVGAltGlyphItemElementImpl extends _SVGElementImpl implements SVGAltGlyphItemElement {
  _SVGAltGlyphItemElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGAngleImpl extends _DOMTypeBase implements SVGAngle {
  _SVGAngleImpl._wrap(ptr) : super._wrap(ptr);

  int get unitType() => _wrap(_ptr.unitType);

  num get value() => _wrap(_ptr.value);

  void set value(num value) { _ptr.value = _unwrap(value); }

  String get valueAsString() => _wrap(_ptr.valueAsString);

  void set valueAsString(String value) { _ptr.valueAsString = _unwrap(value); }

  num get valueInSpecifiedUnits() => _wrap(_ptr.valueInSpecifiedUnits);

  void set valueInSpecifiedUnits(num value) { _ptr.valueInSpecifiedUnits = _unwrap(value); }

  void convertToSpecifiedUnits(int unitType) {
    _ptr.convertToSpecifiedUnits(_unwrap(unitType));
    return;
  }

  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits) {
    _ptr.newValueSpecifiedUnits(_unwrap(unitType), _unwrap(valueInSpecifiedUnits));
    return;
  }
}

class _SVGAnimateColorElementImpl extends _SVGAnimationElementImpl implements SVGAnimateColorElement {
  _SVGAnimateColorElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGAnimateElementImpl extends _SVGAnimationElementImpl implements SVGAnimateElement {
  _SVGAnimateElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGAnimateMotionElementImpl extends _SVGAnimationElementImpl implements SVGAnimateMotionElement {
  _SVGAnimateMotionElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGAnimateTransformElementImpl extends _SVGAnimationElementImpl implements SVGAnimateTransformElement {
  _SVGAnimateTransformElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGAnimatedAngleImpl extends _DOMTypeBase implements SVGAnimatedAngle {
  _SVGAnimatedAngleImpl._wrap(ptr) : super._wrap(ptr);

  SVGAngle get animVal() => _wrap(_ptr.animVal);

  SVGAngle get baseVal() => _wrap(_ptr.baseVal);
}

class _SVGAnimatedBooleanImpl extends _DOMTypeBase implements SVGAnimatedBoolean {
  _SVGAnimatedBooleanImpl._wrap(ptr) : super._wrap(ptr);

  bool get animVal() => _wrap(_ptr.animVal);

  bool get baseVal() => _wrap(_ptr.baseVal);

  void set baseVal(bool value) { _ptr.baseVal = _unwrap(value); }
}

class _SVGAnimatedEnumerationImpl extends _DOMTypeBase implements SVGAnimatedEnumeration {
  _SVGAnimatedEnumerationImpl._wrap(ptr) : super._wrap(ptr);

  int get animVal() => _wrap(_ptr.animVal);

  int get baseVal() => _wrap(_ptr.baseVal);

  void set baseVal(int value) { _ptr.baseVal = _unwrap(value); }
}

class _SVGAnimatedIntegerImpl extends _DOMTypeBase implements SVGAnimatedInteger {
  _SVGAnimatedIntegerImpl._wrap(ptr) : super._wrap(ptr);

  int get animVal() => _wrap(_ptr.animVal);

  int get baseVal() => _wrap(_ptr.baseVal);

  void set baseVal(int value) { _ptr.baseVal = _unwrap(value); }
}

class _SVGAnimatedLengthImpl extends _DOMTypeBase implements SVGAnimatedLength {
  _SVGAnimatedLengthImpl._wrap(ptr) : super._wrap(ptr);

  SVGLength get animVal() => _wrap(_ptr.animVal);

  SVGLength get baseVal() => _wrap(_ptr.baseVal);
}

class _SVGAnimatedLengthListImpl extends _DOMTypeBase implements SVGAnimatedLengthList {
  _SVGAnimatedLengthListImpl._wrap(ptr) : super._wrap(ptr);

  SVGLengthList get animVal() => _wrap(_ptr.animVal);

  SVGLengthList get baseVal() => _wrap(_ptr.baseVal);
}

class _SVGAnimatedNumberImpl extends _DOMTypeBase implements SVGAnimatedNumber {
  _SVGAnimatedNumberImpl._wrap(ptr) : super._wrap(ptr);

  num get animVal() => _wrap(_ptr.animVal);

  num get baseVal() => _wrap(_ptr.baseVal);

  void set baseVal(num value) { _ptr.baseVal = _unwrap(value); }
}

class _SVGAnimatedNumberListImpl extends _DOMTypeBase implements SVGAnimatedNumberList {
  _SVGAnimatedNumberListImpl._wrap(ptr) : super._wrap(ptr);

  SVGNumberList get animVal() => _wrap(_ptr.animVal);

  SVGNumberList get baseVal() => _wrap(_ptr.baseVal);
}

class _SVGAnimatedPreserveAspectRatioImpl extends _DOMTypeBase implements SVGAnimatedPreserveAspectRatio {
  _SVGAnimatedPreserveAspectRatioImpl._wrap(ptr) : super._wrap(ptr);

  SVGPreserveAspectRatio get animVal() => _wrap(_ptr.animVal);

  SVGPreserveAspectRatio get baseVal() => _wrap(_ptr.baseVal);
}

class _SVGAnimatedRectImpl extends _DOMTypeBase implements SVGAnimatedRect {
  _SVGAnimatedRectImpl._wrap(ptr) : super._wrap(ptr);

  SVGRect get animVal() => _wrap(_ptr.animVal);

  SVGRect get baseVal() => _wrap(_ptr.baseVal);
}

class _SVGAnimatedStringImpl extends _DOMTypeBase implements SVGAnimatedString {
  _SVGAnimatedStringImpl._wrap(ptr) : super._wrap(ptr);

  String get animVal() => _wrap(_ptr.animVal);

  String get baseVal() => _wrap(_ptr.baseVal);

  void set baseVal(String value) { _ptr.baseVal = _unwrap(value); }
}

class _SVGAnimatedTransformListImpl extends _DOMTypeBase implements SVGAnimatedTransformList {
  _SVGAnimatedTransformListImpl._wrap(ptr) : super._wrap(ptr);

  SVGTransformList get animVal() => _wrap(_ptr.animVal);

  SVGTransformList get baseVal() => _wrap(_ptr.baseVal);
}

class _SVGAnimationElementImpl extends _SVGElementImpl implements SVGAnimationElement {
  _SVGAnimationElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGElement get targetElement() => _wrap(_ptr.targetElement);

  num getCurrentTime() {
    return _wrap(_ptr.getCurrentTime());
  }

  num getSimpleDuration() {
    return _wrap(_ptr.getSimpleDuration());
  }

  num getStartTime() {
    return _wrap(_ptr.getStartTime());
  }

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From ElementTimeControl

  void beginElement() {
    _ptr.beginElement();
    return;
  }

  void beginElementAt(num offset) {
    _ptr.beginElementAt(_unwrap(offset));
    return;
  }

  void endElement() {
    _ptr.endElement();
    return;
  }

  void endElementAt(num offset) {
    _ptr.endElementAt(_unwrap(offset));
    return;
  }
}

class _SVGCircleElementImpl extends _SVGElementImpl implements SVGCircleElement {
  _SVGCircleElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get cx() => _wrap(_ptr.cx);

  SVGAnimatedLength get cy() => _wrap(_ptr.cy);

  SVGAnimatedLength get r() => _wrap(_ptr.r);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGClipPathElementImpl extends _SVGElementImpl implements SVGClipPathElement {
  _SVGClipPathElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedEnumeration get clipPathUnits() => _wrap(_ptr.clipPathUnits);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGColorImpl extends _CSSValueImpl implements SVGColor {
  _SVGColorImpl._wrap(ptr) : super._wrap(ptr);

  int get colorType() => _wrap(_ptr.colorType);

  RGBColor get rgbColor() => _wrap(_ptr.rgbColor);

  void setColor(int colorType, String rgbColor, String iccColor) {
    _ptr.setColor(_unwrap(colorType), _unwrap(rgbColor), _unwrap(iccColor));
    return;
  }

  void setRGBColor(String rgbColor) {
    _ptr.setRGBColor(_unwrap(rgbColor));
    return;
  }

  void setRGBColorICCColor(String rgbColor, String iccColor) {
    _ptr.setRGBColorICCColor(_unwrap(rgbColor), _unwrap(iccColor));
    return;
  }
}

class _SVGComponentTransferFunctionElementImpl extends _SVGElementImpl implements SVGComponentTransferFunctionElement {
  _SVGComponentTransferFunctionElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get amplitude() => _wrap(_ptr.amplitude);

  SVGAnimatedNumber get exponent() => _wrap(_ptr.exponent);

  SVGAnimatedNumber get intercept() => _wrap(_ptr.intercept);

  SVGAnimatedNumber get offset() => _wrap(_ptr.offset);

  SVGAnimatedNumber get slope() => _wrap(_ptr.slope);

  SVGAnimatedNumberList get tableValues() => _wrap(_ptr.tableValues);

  SVGAnimatedEnumeration get type() => _wrap(_ptr.type);
}

class _SVGCursorElementImpl extends _SVGElementImpl implements SVGCursorElement {
  _SVGCursorElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);
}

class _SVGDefsElementImpl extends _SVGElementImpl implements SVGDefsElement {
  _SVGDefsElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGDescElementImpl extends _SVGElementImpl implements SVGDescElement {
  _SVGDescElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGDocumentImpl extends _DocumentImpl implements SVGDocument {
  _SVGDocumentImpl._wrap(ptr) : super._wrap(ptr);

  SVGSVGElement get rootElement() => _wrap(_ptr.rootElement);

  Event $dom_createEvent(String eventType) {
    return _wrap(_ptr.createEvent(_unwrap(eventType)));
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _AttributeClassSet extends _CssClassSet {
  _AttributeClassSet(element) : super(element);

  String $dom_className() => _element.attributes['class'];

  void _write(Set s) {
    _element.attributes['class'] = _formatSet(s);
  }
}

class _SVGElementImpl extends _ElementImpl implements SVGElement {
  Set<String> get classes() {
    if (_cssClassSet === null) {
      _cssClassSet = new _AttributeClassSet(_ptr);
    }
    return _cssClassSet;
  }

  ElementList get elements() => new FilteredElementList(this);

  void set elements(Collection<Element> value) {
    final elements = this.elements;
    elements.clear();
    elements.addAll(value);
  }

  String get outerHTML() {
    final container = new Element.tag("div");
    final SVGElement cloned = this.clone(true);
    container.elements.add(cloned);
    return container.innerHTML;
  }

  String get innerHTML() {
    final container = new Element.tag("div");
    final SVGElement cloned = this.clone(true);
    container.elements.addAll(cloned.elements);
    return container.innerHTML;
  }

  void set innerHTML(String svg) {
    final container = new Element.tag("div");
    // Wrap the SVG string in <svg> so that SVGElements are created, rather than
    // HTMLElements.
    container.innerHTML = '<svg version="1.1">$svg</svg>';
    this.elements = container.elements.first.elements;
  }

  _SVGElementImpl._wrap(ptr) : super._wrap(ptr);

  String get id() => _wrap(_ptr.id);

  void set id(String value) { _ptr.id = _unwrap(value); }

  SVGSVGElement get ownerSVGElement() => _wrap(_ptr.ownerSVGElement);

  SVGElement get viewportElement() => _wrap(_ptr.viewportElement);

  String get xmlbase() => _wrap(_ptr.xmlbase);

  void set xmlbase(String value) { _ptr.xmlbase = _unwrap(value); }

}

class _SVGElementInstanceImpl extends _DOMTypeBase implements SVGElementInstance {
  _SVGElementInstanceImpl._wrap(ptr) : super._wrap(ptr);

  _SVGElementInstanceEventsImpl get on() {
    if (_on == null) _on = new _SVGElementInstanceEventsImpl(this);
    return _on;
  }

  SVGElementInstanceList get childNodes() => _wrap(_ptr.childNodes);

  SVGElement get correspondingElement() => _wrap(_ptr.correspondingElement);

  SVGUseElement get correspondingUseElement() => _wrap(_ptr.correspondingUseElement);

  SVGElementInstance get firstChild() => _wrap(_ptr.firstChild);

  SVGElementInstance get lastChild() => _wrap(_ptr.lastChild);

  SVGElementInstance get nextSibling() => _wrap(_ptr.nextSibling);

  SVGElementInstance get parentNode() => _wrap(_ptr.parentNode);

  SVGElementInstance get previousSibling() => _wrap(_ptr.previousSibling);

  void addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool dispatchEvent(Event event) {
    return _wrap(_ptr.dispatchEvent(_unwrap(event)));
  }

  void removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _SVGElementInstanceEventsImpl extends _EventsImpl implements SVGElementInstanceEvents {
  _SVGElementInstanceEventsImpl(_ptr) : super(_ptr);

  EventListenerList get abort() => _get('abort');

  EventListenerList get beforeCopy() => _get('beforecopy');

  EventListenerList get beforeCut() => _get('beforecut');

  EventListenerList get beforePaste() => _get('beforepaste');

  EventListenerList get blur() => _get('blur');

  EventListenerList get change() => _get('change');

  EventListenerList get click() => _get('click');

  EventListenerList get contextMenu() => _get('contextmenu');

  EventListenerList get copy() => _get('copy');

  EventListenerList get cut() => _get('cut');

  EventListenerList get doubleClick() => _get('dblclick');

  EventListenerList get drag() => _get('drag');

  EventListenerList get dragEnd() => _get('dragend');

  EventListenerList get dragEnter() => _get('dragenter');

  EventListenerList get dragLeave() => _get('dragleave');

  EventListenerList get dragOver() => _get('dragover');

  EventListenerList get dragStart() => _get('dragstart');

  EventListenerList get drop() => _get('drop');

  EventListenerList get error() => _get('error');

  EventListenerList get focus() => _get('focus');

  EventListenerList get input() => _get('input');

  EventListenerList get keyDown() => _get('keydown');

  EventListenerList get keyPress() => _get('keypress');

  EventListenerList get keyUp() => _get('keyup');

  EventListenerList get load() => _get('load');

  EventListenerList get mouseDown() => _get('mousedown');

  EventListenerList get mouseMove() => _get('mousemove');

  EventListenerList get mouseOut() => _get('mouseout');

  EventListenerList get mouseOver() => _get('mouseover');

  EventListenerList get mouseUp() => _get('mouseup');

  EventListenerList get mouseWheel() => _get('mousewheel');

  EventListenerList get paste() => _get('paste');

  EventListenerList get reset() => _get('reset');

  EventListenerList get resize() => _get('resize');

  EventListenerList get scroll() => _get('scroll');

  EventListenerList get search() => _get('search');

  EventListenerList get select() => _get('select');

  EventListenerList get selectStart() => _get('selectstart');

  EventListenerList get submit() => _get('submit');

  EventListenerList get unload() => _get('unload');
}

class _SVGElementInstanceListImpl extends _DOMTypeBase implements SVGElementInstanceList {
  _SVGElementInstanceListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  SVGElementInstance item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _SVGEllipseElementImpl extends _SVGElementImpl implements SVGEllipseElement {
  _SVGEllipseElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get cx() => _wrap(_ptr.cx);

  SVGAnimatedLength get cy() => _wrap(_ptr.cy);

  SVGAnimatedLength get rx() => _wrap(_ptr.rx);

  SVGAnimatedLength get ry() => _wrap(_ptr.ry);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGExceptionImpl extends _DOMTypeBase implements SVGException {
  _SVGExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _SVGExternalResourcesRequiredImpl extends _DOMTypeBase implements SVGExternalResourcesRequired {
  _SVGExternalResourcesRequiredImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);
}

class _SVGFEBlendElementImpl extends _SVGElementImpl implements SVGFEBlendElement {
  _SVGFEBlendElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedString get in2() => _wrap(_ptr.in2);

  SVGAnimatedEnumeration get mode() => _wrap(_ptr.mode);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFEColorMatrixElementImpl extends _SVGElementImpl implements SVGFEColorMatrixElement {
  _SVGFEColorMatrixElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedEnumeration get type() => _wrap(_ptr.type);

  SVGAnimatedNumberList get values() => _wrap(_ptr.values);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFEComponentTransferElementImpl extends _SVGElementImpl implements SVGFEComponentTransferElement {
  _SVGFEComponentTransferElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFECompositeElementImpl extends _SVGElementImpl implements SVGFECompositeElement {
  _SVGFECompositeElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedString get in2() => _wrap(_ptr.in2);

  SVGAnimatedNumber get k1() => _wrap(_ptr.k1);

  SVGAnimatedNumber get k2() => _wrap(_ptr.k2);

  SVGAnimatedNumber get k3() => _wrap(_ptr.k3);

  SVGAnimatedNumber get k4() => _wrap(_ptr.k4);

  SVGAnimatedEnumeration get operator() => _wrap(_ptr.operator);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFEConvolveMatrixElementImpl extends _SVGElementImpl implements SVGFEConvolveMatrixElement {
  _SVGFEConvolveMatrixElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get bias() => _wrap(_ptr.bias);

  SVGAnimatedNumber get divisor() => _wrap(_ptr.divisor);

  SVGAnimatedEnumeration get edgeMode() => _wrap(_ptr.edgeMode);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedNumberList get kernelMatrix() => _wrap(_ptr.kernelMatrix);

  SVGAnimatedNumber get kernelUnitLengthX() => _wrap(_ptr.kernelUnitLengthX);

  SVGAnimatedNumber get kernelUnitLengthY() => _wrap(_ptr.kernelUnitLengthY);

  SVGAnimatedInteger get orderX() => _wrap(_ptr.orderX);

  SVGAnimatedInteger get orderY() => _wrap(_ptr.orderY);

  SVGAnimatedBoolean get preserveAlpha() => _wrap(_ptr.preserveAlpha);

  SVGAnimatedInteger get targetX() => _wrap(_ptr.targetX);

  SVGAnimatedInteger get targetY() => _wrap(_ptr.targetY);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFEDiffuseLightingElementImpl extends _SVGElementImpl implements SVGFEDiffuseLightingElement {
  _SVGFEDiffuseLightingElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get diffuseConstant() => _wrap(_ptr.diffuseConstant);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedNumber get kernelUnitLengthX() => _wrap(_ptr.kernelUnitLengthX);

  SVGAnimatedNumber get kernelUnitLengthY() => _wrap(_ptr.kernelUnitLengthY);

  SVGAnimatedNumber get surfaceScale() => _wrap(_ptr.surfaceScale);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFEDisplacementMapElementImpl extends _SVGElementImpl implements SVGFEDisplacementMapElement {
  _SVGFEDisplacementMapElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedString get in2() => _wrap(_ptr.in2);

  SVGAnimatedNumber get scale() => _wrap(_ptr.scale);

  SVGAnimatedEnumeration get xChannelSelector() => _wrap(_ptr.xChannelSelector);

  SVGAnimatedEnumeration get yChannelSelector() => _wrap(_ptr.yChannelSelector);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFEDistantLightElementImpl extends _SVGElementImpl implements SVGFEDistantLightElement {
  _SVGFEDistantLightElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get azimuth() => _wrap(_ptr.azimuth);

  SVGAnimatedNumber get elevation() => _wrap(_ptr.elevation);
}

class _SVGFEDropShadowElementImpl extends _SVGElementImpl implements SVGFEDropShadowElement {
  _SVGFEDropShadowElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get dx() => _wrap(_ptr.dx);

  SVGAnimatedNumber get dy() => _wrap(_ptr.dy);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedNumber get stdDeviationX() => _wrap(_ptr.stdDeviationX);

  SVGAnimatedNumber get stdDeviationY() => _wrap(_ptr.stdDeviationY);

  void setStdDeviation(num stdDeviationX, num stdDeviationY) {
    _ptr.setStdDeviation(_unwrap(stdDeviationX), _unwrap(stdDeviationY));
    return;
  }

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFEFloodElementImpl extends _SVGElementImpl implements SVGFEFloodElement {
  _SVGFEFloodElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFEFuncAElementImpl extends _SVGComponentTransferFunctionElementImpl implements SVGFEFuncAElement {
  _SVGFEFuncAElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFEFuncBElementImpl extends _SVGComponentTransferFunctionElementImpl implements SVGFEFuncBElement {
  _SVGFEFuncBElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFEFuncGElementImpl extends _SVGComponentTransferFunctionElementImpl implements SVGFEFuncGElement {
  _SVGFEFuncGElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFEFuncRElementImpl extends _SVGComponentTransferFunctionElementImpl implements SVGFEFuncRElement {
  _SVGFEFuncRElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFEGaussianBlurElementImpl extends _SVGElementImpl implements SVGFEGaussianBlurElement {
  _SVGFEGaussianBlurElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedNumber get stdDeviationX() => _wrap(_ptr.stdDeviationX);

  SVGAnimatedNumber get stdDeviationY() => _wrap(_ptr.stdDeviationY);

  void setStdDeviation(num stdDeviationX, num stdDeviationY) {
    _ptr.setStdDeviation(_unwrap(stdDeviationX), _unwrap(stdDeviationY));
    return;
  }

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFEImageElementImpl extends _SVGElementImpl implements SVGFEImageElement {
  _SVGFEImageElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFEMergeElementImpl extends _SVGElementImpl implements SVGFEMergeElement {
  _SVGFEMergeElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFEMergeNodeElementImpl extends _SVGElementImpl implements SVGFEMergeNodeElement {
  _SVGFEMergeNodeElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);
}

class _SVGFEMorphologyElementImpl extends _SVGElementImpl implements SVGFEMorphologyElement {
  _SVGFEMorphologyElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedEnumeration get operator() => _wrap(_ptr.operator);

  SVGAnimatedNumber get radiusX() => _wrap(_ptr.radiusX);

  SVGAnimatedNumber get radiusY() => _wrap(_ptr.radiusY);

  void setRadius(num radiusX, num radiusY) {
    _ptr.setRadius(_unwrap(radiusX), _unwrap(radiusY));
    return;
  }

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFEOffsetElementImpl extends _SVGElementImpl implements SVGFEOffsetElement {
  _SVGFEOffsetElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get dx() => _wrap(_ptr.dx);

  SVGAnimatedNumber get dy() => _wrap(_ptr.dy);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFEPointLightElementImpl extends _SVGElementImpl implements SVGFEPointLightElement {
  _SVGFEPointLightElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get x() => _wrap(_ptr.x);

  SVGAnimatedNumber get y() => _wrap(_ptr.y);

  SVGAnimatedNumber get z() => _wrap(_ptr.z);
}

class _SVGFESpecularLightingElementImpl extends _SVGElementImpl implements SVGFESpecularLightingElement {
  _SVGFESpecularLightingElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  SVGAnimatedNumber get specularConstant() => _wrap(_ptr.specularConstant);

  SVGAnimatedNumber get specularExponent() => _wrap(_ptr.specularExponent);

  SVGAnimatedNumber get surfaceScale() => _wrap(_ptr.surfaceScale);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFESpotLightElementImpl extends _SVGElementImpl implements SVGFESpotLightElement {
  _SVGFESpotLightElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get limitingConeAngle() => _wrap(_ptr.limitingConeAngle);

  SVGAnimatedNumber get pointsAtX() => _wrap(_ptr.pointsAtX);

  SVGAnimatedNumber get pointsAtY() => _wrap(_ptr.pointsAtY);

  SVGAnimatedNumber get pointsAtZ() => _wrap(_ptr.pointsAtZ);

  SVGAnimatedNumber get specularExponent() => _wrap(_ptr.specularExponent);

  SVGAnimatedNumber get x() => _wrap(_ptr.x);

  SVGAnimatedNumber get y() => _wrap(_ptr.y);

  SVGAnimatedNumber get z() => _wrap(_ptr.z);
}

class _SVGFETileElementImpl extends _SVGElementImpl implements SVGFETileElement {
  _SVGFETileElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get in1() => _wrap(_ptr.in1);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFETurbulenceElementImpl extends _SVGElementImpl implements SVGFETurbulenceElement {
  _SVGFETurbulenceElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get baseFrequencyX() => _wrap(_ptr.baseFrequencyX);

  SVGAnimatedNumber get baseFrequencyY() => _wrap(_ptr.baseFrequencyY);

  SVGAnimatedInteger get numOctaves() => _wrap(_ptr.numOctaves);

  SVGAnimatedNumber get seed() => _wrap(_ptr.seed);

  SVGAnimatedEnumeration get stitchTiles() => _wrap(_ptr.stitchTiles);

  SVGAnimatedEnumeration get type() => _wrap(_ptr.type);

  // From SVGFilterPrimitiveStandardAttributes

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFilterElementImpl extends _SVGElementImpl implements SVGFilterElement {
  _SVGFilterElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedInteger get filterResX() => _wrap(_ptr.filterResX);

  SVGAnimatedInteger get filterResY() => _wrap(_ptr.filterResY);

  SVGAnimatedEnumeration get filterUnits() => _wrap(_ptr.filterUnits);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedEnumeration get primitiveUnits() => _wrap(_ptr.primitiveUnits);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  void setFilterRes(int filterResX, int filterResY) {
    _ptr.setFilterRes(_unwrap(filterResX), _unwrap(filterResY));
    return;
  }

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGFilterPrimitiveStandardAttributesImpl extends _SVGStylableImpl implements SVGFilterPrimitiveStandardAttributes {
  _SVGFilterPrimitiveStandardAttributesImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedString get result() => _wrap(_ptr.result);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);
}

class _SVGFitToViewBoxImpl extends _DOMTypeBase implements SVGFitToViewBox {
  _SVGFitToViewBoxImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  SVGAnimatedRect get viewBox() => _wrap(_ptr.viewBox);
}

class _SVGFontElementImpl extends _SVGElementImpl implements SVGFontElement {
  _SVGFontElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFontFaceElementImpl extends _SVGElementImpl implements SVGFontFaceElement {
  _SVGFontFaceElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFontFaceFormatElementImpl extends _SVGElementImpl implements SVGFontFaceFormatElement {
  _SVGFontFaceFormatElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFontFaceNameElementImpl extends _SVGElementImpl implements SVGFontFaceNameElement {
  _SVGFontFaceNameElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFontFaceSrcElementImpl extends _SVGElementImpl implements SVGFontFaceSrcElement {
  _SVGFontFaceSrcElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGFontFaceUriElementImpl extends _SVGElementImpl implements SVGFontFaceUriElement {
  _SVGFontFaceUriElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGForeignObjectElementImpl extends _SVGElementImpl implements SVGForeignObjectElement {
  _SVGForeignObjectElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGGElementImpl extends _SVGElementImpl implements SVGGElement {
  _SVGGElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGGlyphElementImpl extends _SVGElementImpl implements SVGGlyphElement {
  _SVGGlyphElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGGlyphRefElementImpl extends _SVGElementImpl implements SVGGlyphRefElement {
  _SVGGlyphRefElementImpl._wrap(ptr) : super._wrap(ptr);

  num get dx() => _wrap(_ptr.dx);

  void set dx(num value) { _ptr.dx = _unwrap(value); }

  num get dy() => _wrap(_ptr.dy);

  void set dy(num value) { _ptr.dy = _unwrap(value); }

  String get format() => _wrap(_ptr.format);

  void set format(String value) { _ptr.format = _unwrap(value); }

  String get glyphRef() => _wrap(_ptr.glyphRef);

  void set glyphRef(String value) { _ptr.glyphRef = _unwrap(value); }

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGGradientElementImpl extends _SVGElementImpl implements SVGGradientElement {
  _SVGGradientElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedTransformList get gradientTransform() => _wrap(_ptr.gradientTransform);

  SVGAnimatedEnumeration get gradientUnits() => _wrap(_ptr.gradientUnits);

  SVGAnimatedEnumeration get spreadMethod() => _wrap(_ptr.spreadMethod);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGHKernElementImpl extends _SVGElementImpl implements SVGHKernElement {
  _SVGHKernElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGImageElementImpl extends _SVGElementImpl implements SVGImageElement {
  _SVGImageElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGLangSpaceImpl extends _DOMTypeBase implements SVGLangSpace {
  _SVGLangSpaceImpl._wrap(ptr) : super._wrap(ptr);

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }
}

class _SVGLengthImpl extends _DOMTypeBase implements SVGLength {
  _SVGLengthImpl._wrap(ptr) : super._wrap(ptr);

  int get unitType() => _wrap(_ptr.unitType);

  num get value() => _wrap(_ptr.value);

  void set value(num value) { _ptr.value = _unwrap(value); }

  String get valueAsString() => _wrap(_ptr.valueAsString);

  void set valueAsString(String value) { _ptr.valueAsString = _unwrap(value); }

  num get valueInSpecifiedUnits() => _wrap(_ptr.valueInSpecifiedUnits);

  void set valueInSpecifiedUnits(num value) { _ptr.valueInSpecifiedUnits = _unwrap(value); }

  void convertToSpecifiedUnits(int unitType) {
    _ptr.convertToSpecifiedUnits(_unwrap(unitType));
    return;
  }

  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits) {
    _ptr.newValueSpecifiedUnits(_unwrap(unitType), _unwrap(valueInSpecifiedUnits));
    return;
  }
}

class _SVGLengthListImpl extends _DOMTypeBase implements SVGLengthList {
  _SVGLengthListImpl._wrap(ptr) : super._wrap(ptr);

  int get numberOfItems() => _wrap(_ptr.numberOfItems);

  SVGLength appendItem(SVGLength item) {
    return _wrap(_ptr.appendItem(_unwrap(item)));
  }

  void clear() {
    _ptr.clear();
    return;
  }

  SVGLength getItem(int index) {
    return _wrap(_ptr.getItem(_unwrap(index)));
  }

  SVGLength initialize(SVGLength item) {
    return _wrap(_ptr.initialize(_unwrap(item)));
  }

  SVGLength insertItemBefore(SVGLength item, int index) {
    return _wrap(_ptr.insertItemBefore(_unwrap(item), _unwrap(index)));
  }

  SVGLength removeItem(int index) {
    return _wrap(_ptr.removeItem(_unwrap(index)));
  }

  SVGLength replaceItem(SVGLength item, int index) {
    return _wrap(_ptr.replaceItem(_unwrap(item), _unwrap(index)));
  }
}

class _SVGLineElementImpl extends _SVGElementImpl implements SVGLineElement {
  _SVGLineElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get x1() => _wrap(_ptr.x1);

  SVGAnimatedLength get x2() => _wrap(_ptr.x2);

  SVGAnimatedLength get y1() => _wrap(_ptr.y1);

  SVGAnimatedLength get y2() => _wrap(_ptr.y2);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGLinearGradientElementImpl extends _SVGGradientElementImpl implements SVGLinearGradientElement {
  _SVGLinearGradientElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get x1() => _wrap(_ptr.x1);

  SVGAnimatedLength get x2() => _wrap(_ptr.x2);

  SVGAnimatedLength get y1() => _wrap(_ptr.y1);

  SVGAnimatedLength get y2() => _wrap(_ptr.y2);
}

class _SVGLocatableImpl extends _DOMTypeBase implements SVGLocatable {
  _SVGLocatableImpl._wrap(ptr) : super._wrap(ptr);

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGMPathElementImpl extends _SVGElementImpl implements SVGMPathElement {
  _SVGMPathElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);
}

class _SVGMarkerElementImpl extends _SVGElementImpl implements SVGMarkerElement {
  _SVGMarkerElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get markerHeight() => _wrap(_ptr.markerHeight);

  SVGAnimatedEnumeration get markerUnits() => _wrap(_ptr.markerUnits);

  SVGAnimatedLength get markerWidth() => _wrap(_ptr.markerWidth);

  SVGAnimatedAngle get orientAngle() => _wrap(_ptr.orientAngle);

  SVGAnimatedEnumeration get orientType() => _wrap(_ptr.orientType);

  SVGAnimatedLength get refX() => _wrap(_ptr.refX);

  SVGAnimatedLength get refY() => _wrap(_ptr.refY);

  void setOrientToAngle(SVGAngle angle) {
    _ptr.setOrientToAngle(_unwrap(angle));
    return;
  }

  void setOrientToAuto() {
    _ptr.setOrientToAuto();
    return;
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  SVGAnimatedRect get viewBox() => _wrap(_ptr.viewBox);
}

class _SVGMaskElementImpl extends _SVGElementImpl implements SVGMaskElement {
  _SVGMaskElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedEnumeration get maskContentUnits() => _wrap(_ptr.maskContentUnits);

  SVGAnimatedEnumeration get maskUnits() => _wrap(_ptr.maskUnits);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGMatrixImpl extends _DOMTypeBase implements SVGMatrix {
  _SVGMatrixImpl._wrap(ptr) : super._wrap(ptr);

  num get a() => _wrap(_ptr.a);

  void set a(num value) { _ptr.a = _unwrap(value); }

  num get b() => _wrap(_ptr.b);

  void set b(num value) { _ptr.b = _unwrap(value); }

  num get c() => _wrap(_ptr.c);

  void set c(num value) { _ptr.c = _unwrap(value); }

  num get d() => _wrap(_ptr.d);

  void set d(num value) { _ptr.d = _unwrap(value); }

  num get e() => _wrap(_ptr.e);

  void set e(num value) { _ptr.e = _unwrap(value); }

  num get f() => _wrap(_ptr.f);

  void set f(num value) { _ptr.f = _unwrap(value); }

  SVGMatrix flipX() {
    return _wrap(_ptr.flipX());
  }

  SVGMatrix flipY() {
    return _wrap(_ptr.flipY());
  }

  SVGMatrix inverse() {
    return _wrap(_ptr.inverse());
  }

  SVGMatrix multiply(SVGMatrix secondMatrix) {
    return _wrap(_ptr.multiply(_unwrap(secondMatrix)));
  }

  SVGMatrix rotate(num angle) {
    return _wrap(_ptr.rotate(_unwrap(angle)));
  }

  SVGMatrix rotateFromVector(num x, num y) {
    return _wrap(_ptr.rotateFromVector(_unwrap(x), _unwrap(y)));
  }

  SVGMatrix scale(num scaleFactor) {
    return _wrap(_ptr.scale(_unwrap(scaleFactor)));
  }

  SVGMatrix scaleNonUniform(num scaleFactorX, num scaleFactorY) {
    return _wrap(_ptr.scaleNonUniform(_unwrap(scaleFactorX), _unwrap(scaleFactorY)));
  }

  SVGMatrix skewX(num angle) {
    return _wrap(_ptr.skewX(_unwrap(angle)));
  }

  SVGMatrix skewY(num angle) {
    return _wrap(_ptr.skewY(_unwrap(angle)));
  }

  SVGMatrix translate(num x, num y) {
    return _wrap(_ptr.translate(_unwrap(x), _unwrap(y)));
  }
}

class _SVGMetadataElementImpl extends _SVGElementImpl implements SVGMetadataElement {
  _SVGMetadataElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGMissingGlyphElementImpl extends _SVGElementImpl implements SVGMissingGlyphElement {
  _SVGMissingGlyphElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGNumberImpl extends _DOMTypeBase implements SVGNumber {
  _SVGNumberImpl._wrap(ptr) : super._wrap(ptr);

  num get value() => _wrap(_ptr.value);

  void set value(num value) { _ptr.value = _unwrap(value); }
}

class _SVGNumberListImpl extends _DOMTypeBase implements SVGNumberList {
  _SVGNumberListImpl._wrap(ptr) : super._wrap(ptr);

  int get numberOfItems() => _wrap(_ptr.numberOfItems);

  SVGNumber appendItem(SVGNumber item) {
    return _wrap(_ptr.appendItem(_unwrap(item)));
  }

  void clear() {
    _ptr.clear();
    return;
  }

  SVGNumber getItem(int index) {
    return _wrap(_ptr.getItem(_unwrap(index)));
  }

  SVGNumber initialize(SVGNumber item) {
    return _wrap(_ptr.initialize(_unwrap(item)));
  }

  SVGNumber insertItemBefore(SVGNumber item, int index) {
    return _wrap(_ptr.insertItemBefore(_unwrap(item), _unwrap(index)));
  }

  SVGNumber removeItem(int index) {
    return _wrap(_ptr.removeItem(_unwrap(index)));
  }

  SVGNumber replaceItem(SVGNumber item, int index) {
    return _wrap(_ptr.replaceItem(_unwrap(item), _unwrap(index)));
  }
}

class _SVGPaintImpl extends _SVGColorImpl implements SVGPaint {
  _SVGPaintImpl._wrap(ptr) : super._wrap(ptr);

  int get paintType() => _wrap(_ptr.paintType);

  String get uri() => _wrap(_ptr.uri);

  void setPaint(int paintType, String uri, String rgbColor, String iccColor) {
    _ptr.setPaint(_unwrap(paintType), _unwrap(uri), _unwrap(rgbColor), _unwrap(iccColor));
    return;
  }

  void setUri(String uri) {
    _ptr.setUri(_unwrap(uri));
    return;
  }
}

class _SVGPathElementImpl extends _SVGElementImpl implements SVGPathElement {
  _SVGPathElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGPathSegList get animatedNormalizedPathSegList() => _wrap(_ptr.animatedNormalizedPathSegList);

  SVGPathSegList get animatedPathSegList() => _wrap(_ptr.animatedPathSegList);

  SVGPathSegList get normalizedPathSegList() => _wrap(_ptr.normalizedPathSegList);

  SVGAnimatedNumber get pathLength() => _wrap(_ptr.pathLength);

  SVGPathSegList get pathSegList() => _wrap(_ptr.pathSegList);

  SVGPathSegArcAbs createSVGPathSegArcAbs(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag) {
    return _wrap(_ptr.createSVGPathSegArcAbs(_unwrap(x), _unwrap(y), _unwrap(r1), _unwrap(r2), _unwrap(angle), _unwrap(largeArcFlag), _unwrap(sweepFlag)));
  }

  SVGPathSegArcRel createSVGPathSegArcRel(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag) {
    return _wrap(_ptr.createSVGPathSegArcRel(_unwrap(x), _unwrap(y), _unwrap(r1), _unwrap(r2), _unwrap(angle), _unwrap(largeArcFlag), _unwrap(sweepFlag)));
  }

  SVGPathSegClosePath createSVGPathSegClosePath() {
    return _wrap(_ptr.createSVGPathSegClosePath());
  }

  SVGPathSegCurvetoCubicAbs createSVGPathSegCurvetoCubicAbs(num x, num y, num x1, num y1, num x2, num y2) {
    return _wrap(_ptr.createSVGPathSegCurvetoCubicAbs(_unwrap(x), _unwrap(y), _unwrap(x1), _unwrap(y1), _unwrap(x2), _unwrap(y2)));
  }

  SVGPathSegCurvetoCubicRel createSVGPathSegCurvetoCubicRel(num x, num y, num x1, num y1, num x2, num y2) {
    return _wrap(_ptr.createSVGPathSegCurvetoCubicRel(_unwrap(x), _unwrap(y), _unwrap(x1), _unwrap(y1), _unwrap(x2), _unwrap(y2)));
  }

  SVGPathSegCurvetoCubicSmoothAbs createSVGPathSegCurvetoCubicSmoothAbs(num x, num y, num x2, num y2) {
    return _wrap(_ptr.createSVGPathSegCurvetoCubicSmoothAbs(_unwrap(x), _unwrap(y), _unwrap(x2), _unwrap(y2)));
  }

  SVGPathSegCurvetoCubicSmoothRel createSVGPathSegCurvetoCubicSmoothRel(num x, num y, num x2, num y2) {
    return _wrap(_ptr.createSVGPathSegCurvetoCubicSmoothRel(_unwrap(x), _unwrap(y), _unwrap(x2), _unwrap(y2)));
  }

  SVGPathSegCurvetoQuadraticAbs createSVGPathSegCurvetoQuadraticAbs(num x, num y, num x1, num y1) {
    return _wrap(_ptr.createSVGPathSegCurvetoQuadraticAbs(_unwrap(x), _unwrap(y), _unwrap(x1), _unwrap(y1)));
  }

  SVGPathSegCurvetoQuadraticRel createSVGPathSegCurvetoQuadraticRel(num x, num y, num x1, num y1) {
    return _wrap(_ptr.createSVGPathSegCurvetoQuadraticRel(_unwrap(x), _unwrap(y), _unwrap(x1), _unwrap(y1)));
  }

  SVGPathSegCurvetoQuadraticSmoothAbs createSVGPathSegCurvetoQuadraticSmoothAbs(num x, num y) {
    return _wrap(_ptr.createSVGPathSegCurvetoQuadraticSmoothAbs(_unwrap(x), _unwrap(y)));
  }

  SVGPathSegCurvetoQuadraticSmoothRel createSVGPathSegCurvetoQuadraticSmoothRel(num x, num y) {
    return _wrap(_ptr.createSVGPathSegCurvetoQuadraticSmoothRel(_unwrap(x), _unwrap(y)));
  }

  SVGPathSegLinetoAbs createSVGPathSegLinetoAbs(num x, num y) {
    return _wrap(_ptr.createSVGPathSegLinetoAbs(_unwrap(x), _unwrap(y)));
  }

  SVGPathSegLinetoHorizontalAbs createSVGPathSegLinetoHorizontalAbs(num x) {
    return _wrap(_ptr.createSVGPathSegLinetoHorizontalAbs(_unwrap(x)));
  }

  SVGPathSegLinetoHorizontalRel createSVGPathSegLinetoHorizontalRel(num x) {
    return _wrap(_ptr.createSVGPathSegLinetoHorizontalRel(_unwrap(x)));
  }

  SVGPathSegLinetoRel createSVGPathSegLinetoRel(num x, num y) {
    return _wrap(_ptr.createSVGPathSegLinetoRel(_unwrap(x), _unwrap(y)));
  }

  SVGPathSegLinetoVerticalAbs createSVGPathSegLinetoVerticalAbs(num y) {
    return _wrap(_ptr.createSVGPathSegLinetoVerticalAbs(_unwrap(y)));
  }

  SVGPathSegLinetoVerticalRel createSVGPathSegLinetoVerticalRel(num y) {
    return _wrap(_ptr.createSVGPathSegLinetoVerticalRel(_unwrap(y)));
  }

  SVGPathSegMovetoAbs createSVGPathSegMovetoAbs(num x, num y) {
    return _wrap(_ptr.createSVGPathSegMovetoAbs(_unwrap(x), _unwrap(y)));
  }

  SVGPathSegMovetoRel createSVGPathSegMovetoRel(num x, num y) {
    return _wrap(_ptr.createSVGPathSegMovetoRel(_unwrap(x), _unwrap(y)));
  }

  int getPathSegAtLength(num distance) {
    return _wrap(_ptr.getPathSegAtLength(_unwrap(distance)));
  }

  SVGPoint getPointAtLength(num distance) {
    return _wrap(_ptr.getPointAtLength(_unwrap(distance)));
  }

  num getTotalLength() {
    return _wrap(_ptr.getTotalLength());
  }

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGPathSegImpl extends _DOMTypeBase implements SVGPathSeg {
  _SVGPathSegImpl._wrap(ptr) : super._wrap(ptr);

  int get pathSegType() => _wrap(_ptr.pathSegType);

  String get pathSegTypeAsLetter() => _wrap(_ptr.pathSegTypeAsLetter);
}

class _SVGPathSegArcAbsImpl extends _SVGPathSegImpl implements SVGPathSegArcAbs {
  _SVGPathSegArcAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get angle() => _wrap(_ptr.angle);

  void set angle(num value) { _ptr.angle = _unwrap(value); }

  bool get largeArcFlag() => _wrap(_ptr.largeArcFlag);

  void set largeArcFlag(bool value) { _ptr.largeArcFlag = _unwrap(value); }

  num get r1() => _wrap(_ptr.r1);

  void set r1(num value) { _ptr.r1 = _unwrap(value); }

  num get r2() => _wrap(_ptr.r2);

  void set r2(num value) { _ptr.r2 = _unwrap(value); }

  bool get sweepFlag() => _wrap(_ptr.sweepFlag);

  void set sweepFlag(bool value) { _ptr.sweepFlag = _unwrap(value); }

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegArcRelImpl extends _SVGPathSegImpl implements SVGPathSegArcRel {
  _SVGPathSegArcRelImpl._wrap(ptr) : super._wrap(ptr);

  num get angle() => _wrap(_ptr.angle);

  void set angle(num value) { _ptr.angle = _unwrap(value); }

  bool get largeArcFlag() => _wrap(_ptr.largeArcFlag);

  void set largeArcFlag(bool value) { _ptr.largeArcFlag = _unwrap(value); }

  num get r1() => _wrap(_ptr.r1);

  void set r1(num value) { _ptr.r1 = _unwrap(value); }

  num get r2() => _wrap(_ptr.r2);

  void set r2(num value) { _ptr.r2 = _unwrap(value); }

  bool get sweepFlag() => _wrap(_ptr.sweepFlag);

  void set sweepFlag(bool value) { _ptr.sweepFlag = _unwrap(value); }

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegClosePathImpl extends _SVGPathSegImpl implements SVGPathSegClosePath {
  _SVGPathSegClosePathImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGPathSegCurvetoCubicAbsImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoCubicAbs {
  _SVGPathSegCurvetoCubicAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get x1() => _wrap(_ptr.x1);

  void set x1(num value) { _ptr.x1 = _unwrap(value); }

  num get x2() => _wrap(_ptr.x2);

  void set x2(num value) { _ptr.x2 = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }

  num get y1() => _wrap(_ptr.y1);

  void set y1(num value) { _ptr.y1 = _unwrap(value); }

  num get y2() => _wrap(_ptr.y2);

  void set y2(num value) { _ptr.y2 = _unwrap(value); }
}

class _SVGPathSegCurvetoCubicRelImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoCubicRel {
  _SVGPathSegCurvetoCubicRelImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get x1() => _wrap(_ptr.x1);

  void set x1(num value) { _ptr.x1 = _unwrap(value); }

  num get x2() => _wrap(_ptr.x2);

  void set x2(num value) { _ptr.x2 = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }

  num get y1() => _wrap(_ptr.y1);

  void set y1(num value) { _ptr.y1 = _unwrap(value); }

  num get y2() => _wrap(_ptr.y2);

  void set y2(num value) { _ptr.y2 = _unwrap(value); }
}

class _SVGPathSegCurvetoCubicSmoothAbsImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoCubicSmoothAbs {
  _SVGPathSegCurvetoCubicSmoothAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get x2() => _wrap(_ptr.x2);

  void set x2(num value) { _ptr.x2 = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }

  num get y2() => _wrap(_ptr.y2);

  void set y2(num value) { _ptr.y2 = _unwrap(value); }
}

class _SVGPathSegCurvetoCubicSmoothRelImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoCubicSmoothRel {
  _SVGPathSegCurvetoCubicSmoothRelImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get x2() => _wrap(_ptr.x2);

  void set x2(num value) { _ptr.x2 = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }

  num get y2() => _wrap(_ptr.y2);

  void set y2(num value) { _ptr.y2 = _unwrap(value); }
}

class _SVGPathSegCurvetoQuadraticAbsImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoQuadraticAbs {
  _SVGPathSegCurvetoQuadraticAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get x1() => _wrap(_ptr.x1);

  void set x1(num value) { _ptr.x1 = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }

  num get y1() => _wrap(_ptr.y1);

  void set y1(num value) { _ptr.y1 = _unwrap(value); }
}

class _SVGPathSegCurvetoQuadraticRelImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoQuadraticRel {
  _SVGPathSegCurvetoQuadraticRelImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get x1() => _wrap(_ptr.x1);

  void set x1(num value) { _ptr.x1 = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }

  num get y1() => _wrap(_ptr.y1);

  void set y1(num value) { _ptr.y1 = _unwrap(value); }
}

class _SVGPathSegCurvetoQuadraticSmoothAbsImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoQuadraticSmoothAbs {
  _SVGPathSegCurvetoQuadraticSmoothAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegCurvetoQuadraticSmoothRelImpl extends _SVGPathSegImpl implements SVGPathSegCurvetoQuadraticSmoothRel {
  _SVGPathSegCurvetoQuadraticSmoothRelImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegLinetoAbsImpl extends _SVGPathSegImpl implements SVGPathSegLinetoAbs {
  _SVGPathSegLinetoAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegLinetoHorizontalAbsImpl extends _SVGPathSegImpl implements SVGPathSegLinetoHorizontalAbs {
  _SVGPathSegLinetoHorizontalAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }
}

class _SVGPathSegLinetoHorizontalRelImpl extends _SVGPathSegImpl implements SVGPathSegLinetoHorizontalRel {
  _SVGPathSegLinetoHorizontalRelImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }
}

class _SVGPathSegLinetoRelImpl extends _SVGPathSegImpl implements SVGPathSegLinetoRel {
  _SVGPathSegLinetoRelImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegLinetoVerticalAbsImpl extends _SVGPathSegImpl implements SVGPathSegLinetoVerticalAbs {
  _SVGPathSegLinetoVerticalAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegLinetoVerticalRelImpl extends _SVGPathSegImpl implements SVGPathSegLinetoVerticalRel {
  _SVGPathSegLinetoVerticalRelImpl._wrap(ptr) : super._wrap(ptr);

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegListImpl extends _DOMTypeBase implements SVGPathSegList {
  _SVGPathSegListImpl._wrap(ptr) : super._wrap(ptr);

  int get numberOfItems() => _wrap(_ptr.numberOfItems);

  SVGPathSeg appendItem(SVGPathSeg newItem) {
    return _wrap(_ptr.appendItem(_unwrap(newItem)));
  }

  void clear() {
    _ptr.clear();
    return;
  }

  SVGPathSeg getItem(int index) {
    return _wrap(_ptr.getItem(_unwrap(index)));
  }

  SVGPathSeg initialize(SVGPathSeg newItem) {
    return _wrap(_ptr.initialize(_unwrap(newItem)));
  }

  SVGPathSeg insertItemBefore(SVGPathSeg newItem, int index) {
    return _wrap(_ptr.insertItemBefore(_unwrap(newItem), _unwrap(index)));
  }

  SVGPathSeg removeItem(int index) {
    return _wrap(_ptr.removeItem(_unwrap(index)));
  }

  SVGPathSeg replaceItem(SVGPathSeg newItem, int index) {
    return _wrap(_ptr.replaceItem(_unwrap(newItem), _unwrap(index)));
  }
}

class _SVGPathSegMovetoAbsImpl extends _SVGPathSegImpl implements SVGPathSegMovetoAbs {
  _SVGPathSegMovetoAbsImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPathSegMovetoRelImpl extends _SVGPathSegImpl implements SVGPathSegMovetoRel {
  _SVGPathSegMovetoRelImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGPatternElementImpl extends _SVGElementImpl implements SVGPatternElement {
  _SVGPatternElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedEnumeration get patternContentUnits() => _wrap(_ptr.patternContentUnits);

  SVGAnimatedTransformList get patternTransform() => _wrap(_ptr.patternTransform);

  SVGAnimatedEnumeration get patternUnits() => _wrap(_ptr.patternUnits);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  SVGAnimatedRect get viewBox() => _wrap(_ptr.viewBox);
}

class _SVGPointImpl extends _DOMTypeBase implements SVGPoint {
  _SVGPointImpl._wrap(ptr) : super._wrap(ptr);

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }

  SVGPoint matrixTransform(SVGMatrix matrix) {
    return _wrap(_ptr.matrixTransform(_unwrap(matrix)));
  }
}

class _SVGPointListImpl extends _DOMTypeBase implements SVGPointList {
  _SVGPointListImpl._wrap(ptr) : super._wrap(ptr);

  int get numberOfItems() => _wrap(_ptr.numberOfItems);

  SVGPoint appendItem(SVGPoint item) {
    return _wrap(_ptr.appendItem(_unwrap(item)));
  }

  void clear() {
    _ptr.clear();
    return;
  }

  SVGPoint getItem(int index) {
    return _wrap(_ptr.getItem(_unwrap(index)));
  }

  SVGPoint initialize(SVGPoint item) {
    return _wrap(_ptr.initialize(_unwrap(item)));
  }

  SVGPoint insertItemBefore(SVGPoint item, int index) {
    return _wrap(_ptr.insertItemBefore(_unwrap(item), _unwrap(index)));
  }

  SVGPoint removeItem(int index) {
    return _wrap(_ptr.removeItem(_unwrap(index)));
  }

  SVGPoint replaceItem(SVGPoint item, int index) {
    return _wrap(_ptr.replaceItem(_unwrap(item), _unwrap(index)));
  }
}

class _SVGPolygonElementImpl extends _SVGElementImpl implements SVGPolygonElement {
  _SVGPolygonElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGPointList get animatedPoints() => _wrap(_ptr.animatedPoints);

  SVGPointList get points() => _wrap(_ptr.points);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGPolylineElementImpl extends _SVGElementImpl implements SVGPolylineElement {
  _SVGPolylineElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGPointList get animatedPoints() => _wrap(_ptr.animatedPoints);

  SVGPointList get points() => _wrap(_ptr.points);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGPreserveAspectRatioImpl extends _DOMTypeBase implements SVGPreserveAspectRatio {
  _SVGPreserveAspectRatioImpl._wrap(ptr) : super._wrap(ptr);

  int get align() => _wrap(_ptr.align);

  void set align(int value) { _ptr.align = _unwrap(value); }

  int get meetOrSlice() => _wrap(_ptr.meetOrSlice);

  void set meetOrSlice(int value) { _ptr.meetOrSlice = _unwrap(value); }
}

class _SVGRadialGradientElementImpl extends _SVGGradientElementImpl implements SVGRadialGradientElement {
  _SVGRadialGradientElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get cx() => _wrap(_ptr.cx);

  SVGAnimatedLength get cy() => _wrap(_ptr.cy);

  SVGAnimatedLength get fx() => _wrap(_ptr.fx);

  SVGAnimatedLength get fy() => _wrap(_ptr.fy);

  SVGAnimatedLength get r() => _wrap(_ptr.r);
}

class _SVGRectImpl extends _DOMTypeBase implements SVGRect {
  _SVGRectImpl._wrap(ptr) : super._wrap(ptr);

  num get height() => _wrap(_ptr.height);

  void set height(num value) { _ptr.height = _unwrap(value); }

  num get width() => _wrap(_ptr.width);

  void set width(num value) { _ptr.width = _unwrap(value); }

  num get x() => _wrap(_ptr.x);

  void set x(num value) { _ptr.x = _unwrap(value); }

  num get y() => _wrap(_ptr.y);

  void set y(num value) { _ptr.y = _unwrap(value); }
}

class _SVGRectElementImpl extends _SVGElementImpl implements SVGRectElement {
  _SVGRectElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGAnimatedLength get rx() => _wrap(_ptr.rx);

  SVGAnimatedLength get ry() => _wrap(_ptr.ry);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGRenderingIntentImpl extends _DOMTypeBase implements SVGRenderingIntent {
  _SVGRenderingIntentImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGSVGElementImpl extends _SVGElementImpl implements SVGSVGElement {
  _SVGSVGElementImpl._wrap(ptr) : super._wrap(ptr);

  String get contentScriptType() => _wrap(_ptr.contentScriptType);

  void set contentScriptType(String value) { _ptr.contentScriptType = _unwrap(value); }

  String get contentStyleType() => _wrap(_ptr.contentStyleType);

  void set contentStyleType(String value) { _ptr.contentStyleType = _unwrap(value); }

  num get currentScale() => _wrap(_ptr.currentScale);

  void set currentScale(num value) { _ptr.currentScale = _unwrap(value); }

  SVGPoint get currentTranslate() => _wrap(_ptr.currentTranslate);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  num get pixelUnitToMillimeterX() => _wrap(_ptr.pixelUnitToMillimeterX);

  num get pixelUnitToMillimeterY() => _wrap(_ptr.pixelUnitToMillimeterY);

  num get screenPixelToMillimeterX() => _wrap(_ptr.screenPixelToMillimeterX);

  num get screenPixelToMillimeterY() => _wrap(_ptr.screenPixelToMillimeterY);

  bool get useCurrentView() => _wrap(_ptr.useCurrentView);

  void set useCurrentView(bool value) { _ptr.useCurrentView = _unwrap(value); }

  SVGRect get viewport() => _wrap(_ptr.viewport);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  bool animationsPaused() {
    return _wrap(_ptr.animationsPaused());
  }

  bool checkEnclosure(SVGElement element, SVGRect rect) {
    return _wrap(_ptr.checkEnclosure(_unwrap(element), _unwrap(rect)));
  }

  bool checkIntersection(SVGElement element, SVGRect rect) {
    return _wrap(_ptr.checkIntersection(_unwrap(element), _unwrap(rect)));
  }

  SVGAngle createSVGAngle() {
    return _wrap(_ptr.createSVGAngle());
  }

  SVGLength createSVGLength() {
    return _wrap(_ptr.createSVGLength());
  }

  SVGMatrix createSVGMatrix() {
    return _wrap(_ptr.createSVGMatrix());
  }

  SVGNumber createSVGNumber() {
    return _wrap(_ptr.createSVGNumber());
  }

  SVGPoint createSVGPoint() {
    return _wrap(_ptr.createSVGPoint());
  }

  SVGRect createSVGRect() {
    return _wrap(_ptr.createSVGRect());
  }

  SVGTransform createSVGTransform() {
    return _wrap(_ptr.createSVGTransform());
  }

  SVGTransform createSVGTransformFromMatrix(SVGMatrix matrix) {
    return _wrap(_ptr.createSVGTransformFromMatrix(_unwrap(matrix)));
  }

  void deselectAll() {
    _ptr.deselectAll();
    return;
  }

  void forceRedraw() {
    _ptr.forceRedraw();
    return;
  }

  num getCurrentTime() {
    return _wrap(_ptr.getCurrentTime());
  }

  Element getElementById(String elementId) {
    return _wrap(_ptr.getElementById(_unwrap(elementId)));
  }

  NodeList getEnclosureList(SVGRect rect, SVGElement referenceElement) {
    return _wrap(_ptr.getEnclosureList(_unwrap(rect), _unwrap(referenceElement)));
  }

  NodeList getIntersectionList(SVGRect rect, SVGElement referenceElement) {
    return _wrap(_ptr.getIntersectionList(_unwrap(rect), _unwrap(referenceElement)));
  }

  void pauseAnimations() {
    _ptr.pauseAnimations();
    return;
  }

  void setCurrentTime(num seconds) {
    _ptr.setCurrentTime(_unwrap(seconds));
    return;
  }

  int suspendRedraw(int maxWaitMilliseconds) {
    return _wrap(_ptr.suspendRedraw(_unwrap(maxWaitMilliseconds)));
  }

  void unpauseAnimations() {
    _ptr.unpauseAnimations();
    return;
  }

  void unsuspendRedraw(int suspendHandleId) {
    _ptr.unsuspendRedraw(_unwrap(suspendHandleId));
    return;
  }

  void unsuspendRedrawAll() {
    _ptr.unsuspendRedrawAll();
    return;
  }

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  SVGAnimatedRect get viewBox() => _wrap(_ptr.viewBox);

  // From SVGZoomAndPan

  int get zoomAndPan() => _wrap(_ptr.zoomAndPan);

  void set zoomAndPan(int value) { _ptr.zoomAndPan = _unwrap(value); }
}

class _SVGScriptElementImpl extends _SVGElementImpl implements SVGScriptElement {
  _SVGScriptElementImpl._wrap(ptr) : super._wrap(ptr);

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);
}

class _SVGSetElementImpl extends _SVGAnimationElementImpl implements SVGSetElement {
  _SVGSetElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGStopElementImpl extends _SVGElementImpl implements SVGStopElement {
  _SVGStopElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedNumber get offset() => _wrap(_ptr.offset);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGStringListImpl extends _DOMTypeBase implements SVGStringList {
  _SVGStringListImpl._wrap(ptr) : super._wrap(ptr);

  int get numberOfItems() => _wrap(_ptr.numberOfItems);

  String appendItem(String item) {
    return _wrap(_ptr.appendItem(_unwrap(item)));
  }

  void clear() {
    _ptr.clear();
    return;
  }

  String getItem(int index) {
    return _wrap(_ptr.getItem(_unwrap(index)));
  }

  String initialize(String item) {
    return _wrap(_ptr.initialize(_unwrap(item)));
  }

  String insertItemBefore(String item, int index) {
    return _wrap(_ptr.insertItemBefore(_unwrap(item), _unwrap(index)));
  }

  String removeItem(int index) {
    return _wrap(_ptr.removeItem(_unwrap(index)));
  }

  String replaceItem(String item, int index) {
    return _wrap(_ptr.replaceItem(_unwrap(item), _unwrap(index)));
  }
}

class _SVGStylableImpl extends _DOMTypeBase implements SVGStylable {
  _SVGStylableImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGStyleElementImpl extends _SVGElementImpl implements SVGStyleElement {
  _SVGStyleElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  String get media() => _wrap(_ptr.media);

  void set media(String value) { _ptr.media = _unwrap(value); }

  String get title() => _wrap(_ptr.title);

  void set title(String value) { _ptr.title = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }
}

class _SVGSwitchElementImpl extends _SVGElementImpl implements SVGSwitchElement {
  _SVGSwitchElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGSymbolElementImpl extends _SVGElementImpl implements SVGSymbolElement {
  _SVGSymbolElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  SVGAnimatedRect get viewBox() => _wrap(_ptr.viewBox);
}

class _SVGTRefElementImpl extends _SVGTextPositioningElementImpl implements SVGTRefElement {
  _SVGTRefElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);
}

class _SVGTSpanElementImpl extends _SVGTextPositioningElementImpl implements SVGTSpanElement {
  _SVGTSpanElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGTestsImpl extends _DOMTypeBase implements SVGTests {
  _SVGTestsImpl._wrap(ptr) : super._wrap(ptr);

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }
}

class _SVGTextContentElementImpl extends _SVGElementImpl implements SVGTextContentElement {
  _SVGTextContentElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedEnumeration get lengthAdjust() => _wrap(_ptr.lengthAdjust);

  SVGAnimatedLength get textLength() => _wrap(_ptr.textLength);

  int getCharNumAtPosition(SVGPoint point) {
    return _wrap(_ptr.getCharNumAtPosition(_unwrap(point)));
  }

  num getComputedTextLength() {
    return _wrap(_ptr.getComputedTextLength());
  }

  SVGPoint getEndPositionOfChar(int offset) {
    return _wrap(_ptr.getEndPositionOfChar(_unwrap(offset)));
  }

  SVGRect getExtentOfChar(int offset) {
    return _wrap(_ptr.getExtentOfChar(_unwrap(offset)));
  }

  int getNumberOfChars() {
    return _wrap(_ptr.getNumberOfChars());
  }

  num getRotationOfChar(int offset) {
    return _wrap(_ptr.getRotationOfChar(_unwrap(offset)));
  }

  SVGPoint getStartPositionOfChar(int offset) {
    return _wrap(_ptr.getStartPositionOfChar(_unwrap(offset)));
  }

  num getSubStringLength(int offset, int length) {
    return _wrap(_ptr.getSubStringLength(_unwrap(offset), _unwrap(length)));
  }

  void selectSubString(int offset, int length) {
    _ptr.selectSubString(_unwrap(offset), _unwrap(length));
    return;
  }

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGTextElementImpl extends _SVGTextPositioningElementImpl implements SVGTextElement {
  _SVGTextElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGTextPathElementImpl extends _SVGTextContentElementImpl implements SVGTextPathElement {
  _SVGTextPathElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedEnumeration get method() => _wrap(_ptr.method);

  SVGAnimatedEnumeration get spacing() => _wrap(_ptr.spacing);

  SVGAnimatedLength get startOffset() => _wrap(_ptr.startOffset);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);
}

class _SVGTextPositioningElementImpl extends _SVGTextContentElementImpl implements SVGTextPositioningElement {
  _SVGTextPositioningElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedLengthList get dx() => _wrap(_ptr.dx);

  SVGAnimatedLengthList get dy() => _wrap(_ptr.dy);

  SVGAnimatedNumberList get rotate() => _wrap(_ptr.rotate);

  SVGAnimatedLengthList get x() => _wrap(_ptr.x);

  SVGAnimatedLengthList get y() => _wrap(_ptr.y);
}

class _SVGTitleElementImpl extends _SVGElementImpl implements SVGTitleElement {
  _SVGTitleElementImpl._wrap(ptr) : super._wrap(ptr);

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }
}

class _SVGTransformImpl extends _DOMTypeBase implements SVGTransform {
  _SVGTransformImpl._wrap(ptr) : super._wrap(ptr);

  num get angle() => _wrap(_ptr.angle);

  SVGMatrix get matrix() => _wrap(_ptr.matrix);

  int get type() => _wrap(_ptr.type);

  void setMatrix(SVGMatrix matrix) {
    _ptr.setMatrix(_unwrap(matrix));
    return;
  }

  void setRotate(num angle, num cx, num cy) {
    _ptr.setRotate(_unwrap(angle), _unwrap(cx), _unwrap(cy));
    return;
  }

  void setScale(num sx, num sy) {
    _ptr.setScale(_unwrap(sx), _unwrap(sy));
    return;
  }

  void setSkewX(num angle) {
    _ptr.setSkewX(_unwrap(angle));
    return;
  }

  void setSkewY(num angle) {
    _ptr.setSkewY(_unwrap(angle));
    return;
  }

  void setTranslate(num tx, num ty) {
    _ptr.setTranslate(_unwrap(tx), _unwrap(ty));
    return;
  }
}

class _SVGTransformListImpl extends _DOMTypeBase implements SVGTransformList {
  _SVGTransformListImpl._wrap(ptr) : super._wrap(ptr);

  int get numberOfItems() => _wrap(_ptr.numberOfItems);

  SVGTransform appendItem(SVGTransform item) {
    return _wrap(_ptr.appendItem(_unwrap(item)));
  }

  void clear() {
    _ptr.clear();
    return;
  }

  SVGTransform consolidate() {
    return _wrap(_ptr.consolidate());
  }

  SVGTransform createSVGTransformFromMatrix(SVGMatrix matrix) {
    return _wrap(_ptr.createSVGTransformFromMatrix(_unwrap(matrix)));
  }

  SVGTransform getItem(int index) {
    return _wrap(_ptr.getItem(_unwrap(index)));
  }

  SVGTransform initialize(SVGTransform item) {
    return _wrap(_ptr.initialize(_unwrap(item)));
  }

  SVGTransform insertItemBefore(SVGTransform item, int index) {
    return _wrap(_ptr.insertItemBefore(_unwrap(item), _unwrap(index)));
  }

  SVGTransform removeItem(int index) {
    return _wrap(_ptr.removeItem(_unwrap(index)));
  }

  SVGTransform replaceItem(SVGTransform item, int index) {
    return _wrap(_ptr.replaceItem(_unwrap(item), _unwrap(index)));
  }
}

class _SVGTransformableImpl extends _SVGLocatableImpl implements SVGTransformable {
  _SVGTransformableImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);
}

class _SVGURIReferenceImpl extends _DOMTypeBase implements SVGURIReference {
  _SVGURIReferenceImpl._wrap(ptr) : super._wrap(ptr);

  SVGAnimatedString get href() => _wrap(_ptr.href);
}

class _SVGUnitTypesImpl extends _DOMTypeBase implements SVGUnitTypes {
  _SVGUnitTypesImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGUseElementImpl extends _SVGElementImpl implements SVGUseElement {
  _SVGUseElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGElementInstance get animatedInstanceRoot() => _wrap(_ptr.animatedInstanceRoot);

  SVGAnimatedLength get height() => _wrap(_ptr.height);

  SVGElementInstance get instanceRoot() => _wrap(_ptr.instanceRoot);

  SVGAnimatedLength get width() => _wrap(_ptr.width);

  SVGAnimatedLength get x() => _wrap(_ptr.x);

  SVGAnimatedLength get y() => _wrap(_ptr.y);

  // From SVGURIReference

  SVGAnimatedString get href() => _wrap(_ptr.href);

  // From SVGTests

  SVGStringList get requiredExtensions() => _wrap(_ptr.requiredExtensions);

  SVGStringList get requiredFeatures() => _wrap(_ptr.requiredFeatures);

  SVGStringList get systemLanguage() => _wrap(_ptr.systemLanguage);

  bool hasExtension(String extension) {
    return _wrap(_ptr.hasExtension(_unwrap(extension)));
  }

  // From SVGLangSpace

  String get xmllang() => _wrap(_ptr.xmllang);

  void set xmllang(String value) { _ptr.xmllang = _unwrap(value); }

  String get xmlspace() => _wrap(_ptr.xmlspace);

  void set xmlspace(String value) { _ptr.xmlspace = _unwrap(value); }

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGStylable

  SVGAnimatedString get $dom_svgClassName() => _wrap(_ptr.className);

  CSSStyleDeclaration get style() => _wrap(_ptr.style);

  CSSValue getPresentationAttribute(String name) {
    return _wrap(_ptr.getPresentationAttribute(_unwrap(name)));
  }

  // From SVGTransformable

  SVGAnimatedTransformList get transform() => _wrap(_ptr.transform);

  // From SVGLocatable

  SVGElement get farthestViewportElement() => _wrap(_ptr.farthestViewportElement);

  SVGElement get nearestViewportElement() => _wrap(_ptr.nearestViewportElement);

  SVGRect getBBox() {
    return _wrap(_ptr.getBBox());
  }

  SVGMatrix getCTM() {
    return _wrap(_ptr.getCTM());
  }

  SVGMatrix getScreenCTM() {
    return _wrap(_ptr.getScreenCTM());
  }

  SVGMatrix getTransformToElement(SVGElement element) {
    return _wrap(_ptr.getTransformToElement(_unwrap(element)));
  }
}

class _SVGVKernElementImpl extends _SVGElementImpl implements SVGVKernElement {
  _SVGVKernElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SVGViewElementImpl extends _SVGElementImpl implements SVGViewElement {
  _SVGViewElementImpl._wrap(ptr) : super._wrap(ptr);

  SVGStringList get viewTarget() => _wrap(_ptr.viewTarget);

  // From SVGExternalResourcesRequired

  SVGAnimatedBoolean get externalResourcesRequired() => _wrap(_ptr.externalResourcesRequired);

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  SVGAnimatedRect get viewBox() => _wrap(_ptr.viewBox);

  // From SVGZoomAndPan

  int get zoomAndPan() => _wrap(_ptr.zoomAndPan);

  void set zoomAndPan(int value) { _ptr.zoomAndPan = _unwrap(value); }
}

class _SVGViewSpecImpl extends _SVGZoomAndPanImpl implements SVGViewSpec {
  _SVGViewSpecImpl._wrap(ptr) : super._wrap(ptr);

  String get preserveAspectRatioString() => _wrap(_ptr.preserveAspectRatioString);

  SVGTransformList get transform() => _wrap(_ptr.transform);

  String get transformString() => _wrap(_ptr.transformString);

  String get viewBoxString() => _wrap(_ptr.viewBoxString);

  SVGElement get viewTarget() => _wrap(_ptr.viewTarget);

  String get viewTargetString() => _wrap(_ptr.viewTargetString);

  // From SVGFitToViewBox

  SVGAnimatedPreserveAspectRatio get preserveAspectRatio() => _wrap(_ptr.preserveAspectRatio);

  SVGAnimatedRect get viewBox() => _wrap(_ptr.viewBox);
}

class _SVGZoomAndPanImpl extends _DOMTypeBase implements SVGZoomAndPan {
  _SVGZoomAndPanImpl._wrap(ptr) : super._wrap(ptr);

  int get zoomAndPan() => _wrap(_ptr.zoomAndPan);

  void set zoomAndPan(int value) { _ptr.zoomAndPan = _unwrap(value); }
}

class _SVGZoomEventImpl extends _UIEventImpl implements SVGZoomEvent {
  _SVGZoomEventImpl._wrap(ptr) : super._wrap(ptr);

  num get newScale() => _wrap(_ptr.newScale);

  SVGPoint get newTranslate() => _wrap(_ptr.newTranslate);

  num get previousScale() => _wrap(_ptr.previousScale);

  SVGPoint get previousTranslate() => _wrap(_ptr.previousTranslate);

  SVGRect get zoomRectScreen() => _wrap(_ptr.zoomRectScreen);
}

class _ScreenImpl extends _DOMTypeBase implements Screen {
  _ScreenImpl._wrap(ptr) : super._wrap(ptr);

  int get availHeight() => _wrap(_ptr.availHeight);

  int get availLeft() => _wrap(_ptr.availLeft);

  int get availTop() => _wrap(_ptr.availTop);

  int get availWidth() => _wrap(_ptr.availWidth);

  int get colorDepth() => _wrap(_ptr.colorDepth);

  int get height() => _wrap(_ptr.height);

  int get pixelDepth() => _wrap(_ptr.pixelDepth);

  int get width() => _wrap(_ptr.width);
}

class _ScriptElementImpl extends _ElementImpl implements ScriptElement {
  _ScriptElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get async() => _wrap(_ptr.async);

  void set async(bool value) { _ptr.async = _unwrap(value); }

  String get charset() => _wrap(_ptr.charset);

  void set charset(String value) { _ptr.charset = _unwrap(value); }

  String get crossOrigin() => _wrap(_ptr.crossOrigin);

  void set crossOrigin(String value) { _ptr.crossOrigin = _unwrap(value); }

  bool get defer() => _wrap(_ptr.defer);

  void set defer(bool value) { _ptr.defer = _unwrap(value); }

  String get event() => _wrap(_ptr.event);

  void set event(String value) { _ptr.event = _unwrap(value); }

  String get htmlFor() => _wrap(_ptr.htmlFor);

  void set htmlFor(String value) { _ptr.htmlFor = _unwrap(value); }

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }
}

class _ScriptProfileImpl extends _DOMTypeBase implements ScriptProfile {
  _ScriptProfileImpl._wrap(ptr) : super._wrap(ptr);

  ScriptProfileNode get head() => _wrap(_ptr.head);

  String get title() => _wrap(_ptr.title);

  int get uid() => _wrap(_ptr.uid);
}

class _ScriptProfileNodeImpl extends _DOMTypeBase implements ScriptProfileNode {
  _ScriptProfileNodeImpl._wrap(ptr) : super._wrap(ptr);

  int get callUID() => _wrap(_ptr.callUID);

  List<ScriptProfileNode> get children() => _wrap(_ptr.children);

  String get functionName() => _wrap(_ptr.functionName);

  int get lineNumber() => _wrap(_ptr.lineNumber);

  int get numberOfCalls() => _wrap(_ptr.numberOfCalls);

  num get selfTime() => _wrap(_ptr.selfTime);

  num get totalTime() => _wrap(_ptr.totalTime);

  String get url() => _wrap(_ptr.url);

  bool get visible() => _wrap(_ptr.visible);
}

class _SelectElementImpl extends _ElementImpl implements SelectElement {
  _SelectElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get autofocus() => _wrap(_ptr.autofocus);

  void set autofocus(bool value) { _ptr.autofocus = _unwrap(value); }

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  FormElement get form() => _wrap(_ptr.form);

  NodeList get labels() => _wrap(_ptr.labels);

  int get length() => _wrap(_ptr.length);

  void set length(int value) { _ptr.length = _unwrap(value); }

  bool get multiple() => _wrap(_ptr.multiple);

  void set multiple(bool value) { _ptr.multiple = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  HTMLOptionsCollection get options() => _wrap(_ptr.options);

  bool get required() => _wrap(_ptr.required);

  void set required(bool value) { _ptr.required = _unwrap(value); }

  int get selectedIndex() => _wrap(_ptr.selectedIndex);

  void set selectedIndex(int value) { _ptr.selectedIndex = _unwrap(value); }

  HTMLCollection get selectedOptions() => _wrap(_ptr.selectedOptions);

  int get size() => _wrap(_ptr.size);

  void set size(int value) { _ptr.size = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  String get validationMessage() => _wrap(_ptr.validationMessage);

  ValidityState get validity() => _wrap(_ptr.validity);

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }

  bool get willValidate() => _wrap(_ptr.willValidate);

  void add(Element element, Element before) {
    _ptr.add(_unwrap(element), _unwrap(before));
    return;
  }

  bool checkValidity() {
    return _wrap(_ptr.checkValidity());
  }

  Node item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }

  Node namedItem(String name) {
    return _wrap(_ptr.namedItem(_unwrap(name)));
  }

  void setCustomValidity(String error) {
    _ptr.setCustomValidity(_unwrap(error));
    return;
  }
}

class _SessionDescriptionImpl extends _DOMTypeBase implements SessionDescription {
  _SessionDescriptionImpl._wrap(ptr) : super._wrap(ptr);

  void addCandidate(IceCandidate candidate) {
    _ptr.addCandidate(_unwrap(candidate));
    return;
  }

  String toSdp() {
    return _wrap(_ptr.toSdp());
  }
}

class _ShadowElementImpl extends _ElementImpl implements ShadowElement {
  _ShadowElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _ShadowRootImpl extends _DocumentFragmentImpl implements ShadowRoot {
  _ShadowRootImpl._wrap(ptr) : super._wrap(ptr);

  Element get activeElement() => _wrap(_ptr.activeElement);

  Element get host() => _wrap(_ptr.host);

  String get innerHTML() => _wrap(_ptr.innerHTML);

  void set innerHTML(String value) { _ptr.innerHTML = _unwrap(value); }

  DOMSelection get selection() => _wrap(_ptr.selection);

  Element getElementById(String elementId) {
    return _wrap(_ptr.getElementById(_unwrap(elementId)));
  }

  NodeList getElementsByClassName(String className) {
    return _wrap(_ptr.getElementsByClassName(_unwrap(className)));
  }

  NodeList getElementsByTagName(String tagName) {
    return _wrap(_ptr.getElementsByTagName(_unwrap(tagName)));
  }

  NodeList getElementsByTagNameNS(String namespaceURI, String localName) {
    return _wrap(_ptr.getElementsByTagNameNS(_unwrap(namespaceURI), _unwrap(localName)));
  }
}

class _SharedWorkerImpl extends _AbstractWorkerImpl implements SharedWorker {
  _SharedWorkerImpl._wrap(ptr) : super._wrap(ptr);

  MessagePort get port() => _wrap(_ptr.port);
}

class _SharedWorkerContextImpl extends _WorkerContextImpl implements SharedWorkerContext {
  _SharedWorkerContextImpl._wrap(ptr) : super._wrap(ptr);

  _SharedWorkerContextEventsImpl get on() {
    if (_on == null) _on = new _SharedWorkerContextEventsImpl(this);
    return _on;
  }

  String get name() => _wrap(_ptr.name);
}

class _SharedWorkerContextEventsImpl extends _WorkerContextEventsImpl implements SharedWorkerContextEvents {
  _SharedWorkerContextEventsImpl(_ptr) : super(_ptr);

  EventListenerList get connect() => _get('connect');
}

class _SourceElementImpl extends _ElementImpl implements SourceElement {
  _SourceElementImpl._wrap(ptr) : super._wrap(ptr);

  String get media() => _wrap(_ptr.media);

  void set media(String value) { _ptr.media = _unwrap(value); }

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }
}

class _SpanElementImpl extends _ElementImpl implements SpanElement {
  _SpanElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _SpeechGrammarImpl extends _DOMTypeBase implements SpeechGrammar {
  _SpeechGrammarImpl._wrap(ptr) : super._wrap(ptr);

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  num get weight() => _wrap(_ptr.weight);

  void set weight(num value) { _ptr.weight = _unwrap(value); }
}

class _SpeechGrammarListImpl extends _DOMTypeBase implements SpeechGrammarList {
  _SpeechGrammarListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  void addFromString(String string, [num weight = null]) {
    if (weight === null) {
      _ptr.addFromString(_unwrap(string));
      return;
    } else {
      _ptr.addFromString(_unwrap(string), _unwrap(weight));
      return;
    }
  }

  void addFromUri(String src, [num weight = null]) {
    if (weight === null) {
      _ptr.addFromUri(_unwrap(src));
      return;
    } else {
      _ptr.addFromUri(_unwrap(src), _unwrap(weight));
      return;
    }
  }

  SpeechGrammar item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _SpeechInputEventImpl extends _EventImpl implements SpeechInputEvent {
  _SpeechInputEventImpl._wrap(ptr) : super._wrap(ptr);

  SpeechInputResultList get results() => _wrap(_ptr.results);
}

class _SpeechInputResultImpl extends _DOMTypeBase implements SpeechInputResult {
  _SpeechInputResultImpl._wrap(ptr) : super._wrap(ptr);

  num get confidence() => _wrap(_ptr.confidence);

  String get utterance() => _wrap(_ptr.utterance);
}

class _SpeechInputResultListImpl extends _DOMTypeBase implements SpeechInputResultList {
  _SpeechInputResultListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  SpeechInputResult item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _SpeechRecognitionImpl extends _EventTargetImpl implements SpeechRecognition {
  _SpeechRecognitionImpl._wrap(ptr) : super._wrap(ptr);

  _SpeechRecognitionEventsImpl get on() {
    if (_on == null) _on = new _SpeechRecognitionEventsImpl(this);
    return _on;
  }

  bool get continuous() => _wrap(_ptr.continuous);

  void set continuous(bool value) { _ptr.continuous = _unwrap(value); }

  SpeechGrammarList get grammars() => _wrap(_ptr.grammars);

  void set grammars(SpeechGrammarList value) { _ptr.grammars = _unwrap(value); }

  String get lang() => _wrap(_ptr.lang);

  void set lang(String value) { _ptr.lang = _unwrap(value); }

  void abort() {
    _ptr.abort();
    return;
  }

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool $dom_dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void start() {
    _ptr.start();
    return;
  }

  void stop() {
    _ptr.stop();
    return;
  }
}

class _SpeechRecognitionEventsImpl extends _EventsImpl implements SpeechRecognitionEvents {
  _SpeechRecognitionEventsImpl(_ptr) : super(_ptr);

  EventListenerList get audioEnd() => _get('audioend');

  EventListenerList get audioStart() => _get('audiostart');

  EventListenerList get end() => _get('end');

  EventListenerList get error() => _get('error');

  EventListenerList get noMatch() => _get('nomatch');

  EventListenerList get result() => _get('result');

  EventListenerList get resultDeleted() => _get('resultdeleted');

  EventListenerList get soundEnd() => _get('soundend');

  EventListenerList get soundStart() => _get('soundstart');

  EventListenerList get speechEnd() => _get('speechend');

  EventListenerList get speechStart() => _get('speechstart');

  EventListenerList get start() => _get('start');
}

class _SpeechRecognitionAlternativeImpl extends _DOMTypeBase implements SpeechRecognitionAlternative {
  _SpeechRecognitionAlternativeImpl._wrap(ptr) : super._wrap(ptr);

  num get confidence() => _wrap(_ptr.confidence);

  String get transcript() => _wrap(_ptr.transcript);
}

class _SpeechRecognitionErrorImpl extends _DOMTypeBase implements SpeechRecognitionError {
  _SpeechRecognitionErrorImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);
}

class _SpeechRecognitionEventImpl extends _EventImpl implements SpeechRecognitionEvent {
  _SpeechRecognitionEventImpl._wrap(ptr) : super._wrap(ptr);

  SpeechRecognitionError get error() => _wrap(_ptr.error);

  SpeechRecognitionResult get result() => _wrap(_ptr.result);

  SpeechRecognitionResultList get resultHistory() => _wrap(_ptr.resultHistory);

  int get resultIndex() => _wrap(_ptr.resultIndex);
}

class _SpeechRecognitionResultImpl extends _DOMTypeBase implements SpeechRecognitionResult {
  _SpeechRecognitionResultImpl._wrap(ptr) : super._wrap(ptr);

  bool get finalValue() => _wrap(_ptr.finalValue);

  int get length() => _wrap(_ptr.length);

  SpeechRecognitionAlternative item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _SpeechRecognitionResultListImpl extends _DOMTypeBase implements SpeechRecognitionResultList {
  _SpeechRecognitionResultListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  SpeechRecognitionResult item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _StorageImpl extends _DOMTypeBase implements Storage {

  // TODO(nweiz): update this when maps support lazy iteration
  bool containsValue(String value) => getValues().some((e) => e == value);

  bool containsKey(String key) => $dom_getItem(key) != null;

  String operator [](String key) => $dom_getItem(key);

  void operator []=(String key, String value) => $dom_setItem(key, value);

  String putIfAbsent(String key, String ifAbsent()) {
    if (!containsKey(key)) this[key] = ifAbsent();
    return this[key];
  }

  String remove(String key) {
    final value = this[key];
    $dom_removeItem(key);
    return value;
  }

  void clear() => $dom_clear();

  void forEach(void f(String key, String value)) {
    for (var i = 0; true; i++) {
      final key = $dom_key(i);
      if (key == null) return;

      f(key, this[key]);
    }
  }

  Collection<String> getKeys() {
    final keys = [];
    forEach((k, v) => keys.add(k));
    return keys;
  }

  Collection<String> getValues() {
    final values = [];
    forEach((k, v) => values.add(v));
    return values;
  }

  int get length() => $dom_length;

  bool isEmpty() => $dom_key(0) == null;
  _StorageImpl._wrap(ptr) : super._wrap(ptr);

  int get $dom_length() => _wrap(_ptr.length);

  void $dom_clear() {
    _ptr.clear();
    return;
  }

  String $dom_getItem(String key) {
    return _wrap(_ptr.getItem(_unwrap(key)));
  }

  String $dom_key(int index) {
    return _wrap(_ptr.key(_unwrap(index)));
  }

  void $dom_removeItem(String key) {
    _ptr.removeItem(_unwrap(key));
    return;
  }

  void $dom_setItem(String key, String data) {
    _ptr.setItem(_unwrap(key), _unwrap(data));
    return;
  }

}

class _StorageEventImpl extends _EventImpl implements StorageEvent {
  _StorageEventImpl._wrap(ptr) : super._wrap(ptr);

  String get key() => _wrap(_ptr.key);

  String get newValue() => _wrap(_ptr.newValue);

  String get oldValue() => _wrap(_ptr.oldValue);

  Storage get storageArea() => _wrap(_ptr.storageArea);

  String get url() => _wrap(_ptr.url);

  void initStorageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, String keyArg, String oldValueArg, String newValueArg, String urlArg, Storage storageAreaArg) {
    _ptr.initStorageEvent(_unwrap(typeArg), _unwrap(canBubbleArg), _unwrap(cancelableArg), _unwrap(keyArg), _unwrap(oldValueArg), _unwrap(newValueArg), _unwrap(urlArg), _unwrap(storageAreaArg));
    return;
  }
}

class _StorageInfoImpl extends _DOMTypeBase implements StorageInfo {
  _StorageInfoImpl._wrap(ptr) : super._wrap(ptr);

  void queryUsageAndQuota(int storageType, [StorageInfoUsageCallback usageCallback = null, StorageInfoErrorCallback errorCallback = null]) {
    if (usageCallback === null) {
      if (errorCallback === null) {
        _ptr.queryUsageAndQuota(_unwrap(storageType));
        return;
      }
    } else {
      if (errorCallback === null) {
        _ptr.queryUsageAndQuota(_unwrap(storageType), _unwrap(usageCallback));
        return;
      } else {
        _ptr.queryUsageAndQuota(_unwrap(storageType), _unwrap(usageCallback), _unwrap(errorCallback));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void requestQuota(int storageType, int newQuotaInBytes, [StorageInfoQuotaCallback quotaCallback = null, StorageInfoErrorCallback errorCallback = null]) {
    if (quotaCallback === null) {
      if (errorCallback === null) {
        _ptr.requestQuota(_unwrap(storageType), _unwrap(newQuotaInBytes));
        return;
      }
    } else {
      if (errorCallback === null) {
        _ptr.requestQuota(_unwrap(storageType), _unwrap(newQuotaInBytes), _unwrap(quotaCallback));
        return;
      } else {
        _ptr.requestQuota(_unwrap(storageType), _unwrap(newQuotaInBytes), _unwrap(quotaCallback), _unwrap(errorCallback));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }
}

class _StyleElementImpl extends _ElementImpl implements StyleElement {
  _StyleElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  String get media() => _wrap(_ptr.media);

  void set media(String value) { _ptr.media = _unwrap(value); }

  bool get scoped() => _wrap(_ptr.scoped);

  void set scoped(bool value) { _ptr.scoped = _unwrap(value); }

  StyleSheet get sheet() => _wrap(_ptr.sheet);

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }
}

class _StyleMediaImpl extends _DOMTypeBase implements StyleMedia {
  _StyleMediaImpl._wrap(ptr) : super._wrap(ptr);

  String get type() => _wrap(_ptr.type);

  bool matchMedium(String mediaquery) {
    return _wrap(_ptr.matchMedium(_unwrap(mediaquery)));
  }
}

class _StyleSheetImpl extends _DOMTypeBase implements StyleSheet {
  _StyleSheetImpl._wrap(ptr) : super._wrap(ptr);

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  String get href() => _wrap(_ptr.href);

  MediaList get media() => _wrap(_ptr.media);

  Node get ownerNode() => _wrap(_ptr.ownerNode);

  StyleSheet get parentStyleSheet() => _wrap(_ptr.parentStyleSheet);

  String get title() => _wrap(_ptr.title);

  String get type() => _wrap(_ptr.type);
}

class _StyleSheetListImpl extends _DOMTypeBase implements StyleSheetList {
  _StyleSheetListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  StyleSheet operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, StyleSheet value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }
  // -- start List<StyleSheet> mixins.
  // StyleSheet is the element type.

  // From Iterable<StyleSheet>:

  Iterator<StyleSheet> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<StyleSheet>(this);
  }

  // From Collection<StyleSheet>:

  void add(StyleSheet value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(StyleSheet value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<StyleSheet> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(StyleSheet element)) => _Collections.forEach(this, f);

  Collection map(f(StyleSheet element)) => _Collections.map(this, [], f);

  Collection<StyleSheet> filter(bool f(StyleSheet element)) =>
     _Collections.filter(this, <StyleSheet>[], f);

  bool every(bool f(StyleSheet element)) => _Collections.every(this, f);

  bool some(bool f(StyleSheet element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<StyleSheet>:

  void sort(int compare(StyleSheet a, StyleSheet b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(StyleSheet element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(StyleSheet element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  StyleSheet last() => this[length - 1];

  StyleSheet removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<StyleSheet> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [StyleSheet initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<StyleSheet> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <StyleSheet>[]);

  // -- end List<StyleSheet> mixins.

  StyleSheet item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _TableCaptionElementImpl extends _ElementImpl implements TableCaptionElement {
  _TableCaptionElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }
}

class _TableCellElementImpl extends _ElementImpl implements TableCellElement {
  _TableCellElementImpl._wrap(ptr) : super._wrap(ptr);

  String get abbr() => _wrap(_ptr.abbr);

  void set abbr(String value) { _ptr.abbr = _unwrap(value); }

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get axis() => _wrap(_ptr.axis);

  void set axis(String value) { _ptr.axis = _unwrap(value); }

  String get bgColor() => _wrap(_ptr.bgColor);

  void set bgColor(String value) { _ptr.bgColor = _unwrap(value); }

  int get cellIndex() => _wrap(_ptr.cellIndex);

  String get ch() => _wrap(_ptr.ch);

  void set ch(String value) { _ptr.ch = _unwrap(value); }

  String get chOff() => _wrap(_ptr.chOff);

  void set chOff(String value) { _ptr.chOff = _unwrap(value); }

  int get colSpan() => _wrap(_ptr.colSpan);

  void set colSpan(int value) { _ptr.colSpan = _unwrap(value); }

  String get headers() => _wrap(_ptr.headers);

  void set headers(String value) { _ptr.headers = _unwrap(value); }

  String get height() => _wrap(_ptr.height);

  void set height(String value) { _ptr.height = _unwrap(value); }

  bool get noWrap() => _wrap(_ptr.noWrap);

  void set noWrap(bool value) { _ptr.noWrap = _unwrap(value); }

  int get rowSpan() => _wrap(_ptr.rowSpan);

  void set rowSpan(int value) { _ptr.rowSpan = _unwrap(value); }

  String get scope() => _wrap(_ptr.scope);

  void set scope(String value) { _ptr.scope = _unwrap(value); }

  String get vAlign() => _wrap(_ptr.vAlign);

  void set vAlign(String value) { _ptr.vAlign = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }
}

class _TableColElementImpl extends _ElementImpl implements TableColElement {
  _TableColElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get ch() => _wrap(_ptr.ch);

  void set ch(String value) { _ptr.ch = _unwrap(value); }

  String get chOff() => _wrap(_ptr.chOff);

  void set chOff(String value) { _ptr.chOff = _unwrap(value); }

  int get span() => _wrap(_ptr.span);

  void set span(int value) { _ptr.span = _unwrap(value); }

  String get vAlign() => _wrap(_ptr.vAlign);

  void set vAlign(String value) { _ptr.vAlign = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }
}

class _TableElementImpl extends _ElementImpl implements TableElement {
  _TableElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get bgColor() => _wrap(_ptr.bgColor);

  void set bgColor(String value) { _ptr.bgColor = _unwrap(value); }

  String get border() => _wrap(_ptr.border);

  void set border(String value) { _ptr.border = _unwrap(value); }

  TableCaptionElement get caption() => _wrap(_ptr.caption);

  void set caption(TableCaptionElement value) { _ptr.caption = _unwrap(value); }

  String get cellPadding() => _wrap(_ptr.cellPadding);

  void set cellPadding(String value) { _ptr.cellPadding = _unwrap(value); }

  String get cellSpacing() => _wrap(_ptr.cellSpacing);

  void set cellSpacing(String value) { _ptr.cellSpacing = _unwrap(value); }

  String get frame() => _wrap(_ptr.frame);

  void set frame(String value) { _ptr.frame = _unwrap(value); }

  HTMLCollection get rows() => _wrap(_ptr.rows);

  String get rules() => _wrap(_ptr.rules);

  void set rules(String value) { _ptr.rules = _unwrap(value); }

  String get summary() => _wrap(_ptr.summary);

  void set summary(String value) { _ptr.summary = _unwrap(value); }

  HTMLCollection get tBodies() => _wrap(_ptr.tBodies);

  TableSectionElement get tFoot() => _wrap(_ptr.tFoot);

  void set tFoot(TableSectionElement value) { _ptr.tFoot = _unwrap(value); }

  TableSectionElement get tHead() => _wrap(_ptr.tHead);

  void set tHead(TableSectionElement value) { _ptr.tHead = _unwrap(value); }

  String get width() => _wrap(_ptr.width);

  void set width(String value) { _ptr.width = _unwrap(value); }

  Element createCaption() {
    return _wrap(_ptr.createCaption());
  }

  Element createTBody() {
    return _wrap(_ptr.createTBody());
  }

  Element createTFoot() {
    return _wrap(_ptr.createTFoot());
  }

  Element createTHead() {
    return _wrap(_ptr.createTHead());
  }

  void deleteCaption() {
    _ptr.deleteCaption();
    return;
  }

  void deleteRow(int index) {
    _ptr.deleteRow(_unwrap(index));
    return;
  }

  void deleteTFoot() {
    _ptr.deleteTFoot();
    return;
  }

  void deleteTHead() {
    _ptr.deleteTHead();
    return;
  }

  Element insertRow(int index) {
    return _wrap(_ptr.insertRow(_unwrap(index)));
  }
}

class _TableRowElementImpl extends _ElementImpl implements TableRowElement {
  _TableRowElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get bgColor() => _wrap(_ptr.bgColor);

  void set bgColor(String value) { _ptr.bgColor = _unwrap(value); }

  HTMLCollection get cells() => _wrap(_ptr.cells);

  String get ch() => _wrap(_ptr.ch);

  void set ch(String value) { _ptr.ch = _unwrap(value); }

  String get chOff() => _wrap(_ptr.chOff);

  void set chOff(String value) { _ptr.chOff = _unwrap(value); }

  int get rowIndex() => _wrap(_ptr.rowIndex);

  int get sectionRowIndex() => _wrap(_ptr.sectionRowIndex);

  String get vAlign() => _wrap(_ptr.vAlign);

  void set vAlign(String value) { _ptr.vAlign = _unwrap(value); }

  void deleteCell(int index) {
    _ptr.deleteCell(_unwrap(index));
    return;
  }

  Element insertCell(int index) {
    return _wrap(_ptr.insertCell(_unwrap(index)));
  }
}

class _TableSectionElementImpl extends _ElementImpl implements TableSectionElement {
  _TableSectionElementImpl._wrap(ptr) : super._wrap(ptr);

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  String get ch() => _wrap(_ptr.ch);

  void set ch(String value) { _ptr.ch = _unwrap(value); }

  String get chOff() => _wrap(_ptr.chOff);

  void set chOff(String value) { _ptr.chOff = _unwrap(value); }

  HTMLCollection get rows() => _wrap(_ptr.rows);

  String get vAlign() => _wrap(_ptr.vAlign);

  void set vAlign(String value) { _ptr.vAlign = _unwrap(value); }

  void deleteRow(int index) {
    _ptr.deleteRow(_unwrap(index));
    return;
  }

  Element insertRow(int index) {
    return _wrap(_ptr.insertRow(_unwrap(index)));
  }
}

class _TextImpl extends _CharacterDataImpl implements Text {
  _TextImpl._wrap(ptr) : super._wrap(ptr);

  String get wholeText() => _wrap(_ptr.wholeText);

  Text replaceWholeText(String content) {
    return _wrap(_ptr.replaceWholeText(_unwrap(content)));
  }

  Text splitText(int offset) {
    return _wrap(_ptr.splitText(_unwrap(offset)));
  }
}

class _TextAreaElementImpl extends _ElementImpl implements TextAreaElement {
  _TextAreaElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get autofocus() => _wrap(_ptr.autofocus);

  void set autofocus(bool value) { _ptr.autofocus = _unwrap(value); }

  int get cols() => _wrap(_ptr.cols);

  void set cols(int value) { _ptr.cols = _unwrap(value); }

  String get defaultValue() => _wrap(_ptr.defaultValue);

  void set defaultValue(String value) { _ptr.defaultValue = _unwrap(value); }

  bool get disabled() => _wrap(_ptr.disabled);

  void set disabled(bool value) { _ptr.disabled = _unwrap(value); }

  FormElement get form() => _wrap(_ptr.form);

  NodeList get labels() => _wrap(_ptr.labels);

  int get maxLength() => _wrap(_ptr.maxLength);

  void set maxLength(int value) { _ptr.maxLength = _unwrap(value); }

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  String get placeholder() => _wrap(_ptr.placeholder);

  void set placeholder(String value) { _ptr.placeholder = _unwrap(value); }

  bool get readOnly() => _wrap(_ptr.readOnly);

  void set readOnly(bool value) { _ptr.readOnly = _unwrap(value); }

  bool get required() => _wrap(_ptr.required);

  void set required(bool value) { _ptr.required = _unwrap(value); }

  int get rows() => _wrap(_ptr.rows);

  void set rows(int value) { _ptr.rows = _unwrap(value); }

  String get selectionDirection() => _wrap(_ptr.selectionDirection);

  void set selectionDirection(String value) { _ptr.selectionDirection = _unwrap(value); }

  int get selectionEnd() => _wrap(_ptr.selectionEnd);

  void set selectionEnd(int value) { _ptr.selectionEnd = _unwrap(value); }

  int get selectionStart() => _wrap(_ptr.selectionStart);

  void set selectionStart(int value) { _ptr.selectionStart = _unwrap(value); }

  int get textLength() => _wrap(_ptr.textLength);

  String get type() => _wrap(_ptr.type);

  String get validationMessage() => _wrap(_ptr.validationMessage);

  ValidityState get validity() => _wrap(_ptr.validity);

  String get value() => _wrap(_ptr.value);

  void set value(String value) { _ptr.value = _unwrap(value); }

  bool get willValidate() => _wrap(_ptr.willValidate);

  String get wrap() => _wrap(_ptr.wrap);

  void set wrap(String value) { _ptr.wrap = _unwrap(value); }

  bool checkValidity() {
    return _wrap(_ptr.checkValidity());
  }

  void select() {
    _ptr.select();
    return;
  }

  void setCustomValidity(String error) {
    _ptr.setCustomValidity(_unwrap(error));
    return;
  }

  void setSelectionRange(int start, int end, [String direction = null]) {
    if (direction === null) {
      _ptr.setSelectionRange(_unwrap(start), _unwrap(end));
      return;
    } else {
      _ptr.setSelectionRange(_unwrap(start), _unwrap(end), _unwrap(direction));
      return;
    }
  }
}

class _TextEventImpl extends _UIEventImpl implements TextEvent {
  _TextEventImpl._wrap(ptr) : super._wrap(ptr);

  String get data() => _wrap(_ptr.data);

  void initTextEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Window viewArg, String dataArg) {
    _ptr.initTextEvent(_unwrap(typeArg), _unwrap(canBubbleArg), _unwrap(cancelableArg), _unwrap(viewArg), _unwrap(dataArg));
    return;
  }
}

class _TextMetricsImpl extends _DOMTypeBase implements TextMetrics {
  _TextMetricsImpl._wrap(ptr) : super._wrap(ptr);

  num get width() => _wrap(_ptr.width);
}

class _TextTrackImpl extends _EventTargetImpl implements TextTrack {
  _TextTrackImpl._wrap(ptr) : super._wrap(ptr);

  _TextTrackEventsImpl get on() {
    if (_on == null) _on = new _TextTrackEventsImpl(this);
    return _on;
  }

  TextTrackCueList get activeCues() => _wrap(_ptr.activeCues);

  TextTrackCueList get cues() => _wrap(_ptr.cues);

  String get kind() => _wrap(_ptr.kind);

  String get label() => _wrap(_ptr.label);

  String get language() => _wrap(_ptr.language);

  int get mode() => _wrap(_ptr.mode);

  void set mode(int value) { _ptr.mode = _unwrap(value); }

  void addCue(TextTrackCue cue) {
    _ptr.addCue(_unwrap(cue));
    return;
  }

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool $dom_dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void removeCue(TextTrackCue cue) {
    _ptr.removeCue(_unwrap(cue));
    return;
  }

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _TextTrackEventsImpl extends _EventsImpl implements TextTrackEvents {
  _TextTrackEventsImpl(_ptr) : super(_ptr);

  EventListenerList get cueChange() => _get('cuechange');
}

class _TextTrackCueImpl extends _EventTargetImpl implements TextTrackCue {
  _TextTrackCueImpl._wrap(ptr) : super._wrap(ptr);

  _TextTrackCueEventsImpl get on() {
    if (_on == null) _on = new _TextTrackCueEventsImpl(this);
    return _on;
  }

  String get align() => _wrap(_ptr.align);

  void set align(String value) { _ptr.align = _unwrap(value); }

  num get endTime() => _wrap(_ptr.endTime);

  void set endTime(num value) { _ptr.endTime = _unwrap(value); }

  String get id() => _wrap(_ptr.id);

  void set id(String value) { _ptr.id = _unwrap(value); }

  int get line() => _wrap(_ptr.line);

  void set line(int value) { _ptr.line = _unwrap(value); }

  bool get pauseOnExit() => _wrap(_ptr.pauseOnExit);

  void set pauseOnExit(bool value) { _ptr.pauseOnExit = _unwrap(value); }

  int get position() => _wrap(_ptr.position);

  void set position(int value) { _ptr.position = _unwrap(value); }

  int get size() => _wrap(_ptr.size);

  void set size(int value) { _ptr.size = _unwrap(value); }

  bool get snapToLines() => _wrap(_ptr.snapToLines);

  void set snapToLines(bool value) { _ptr.snapToLines = _unwrap(value); }

  num get startTime() => _wrap(_ptr.startTime);

  void set startTime(num value) { _ptr.startTime = _unwrap(value); }

  String get text() => _wrap(_ptr.text);

  void set text(String value) { _ptr.text = _unwrap(value); }

  TextTrack get track() => _wrap(_ptr.track);

  String get vertical() => _wrap(_ptr.vertical);

  void set vertical(String value) { _ptr.vertical = _unwrap(value); }

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool $dom_dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  DocumentFragment getCueAsHTML() {
    return _wrap(_ptr.getCueAsHTML());
  }

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _TextTrackCueEventsImpl extends _EventsImpl implements TextTrackCueEvents {
  _TextTrackCueEventsImpl(_ptr) : super(_ptr);

  EventListenerList get enter() => _get('enter');

  EventListenerList get exit() => _get('exit');
}

class _TextTrackCueListImpl extends _DOMTypeBase implements TextTrackCueList {
  _TextTrackCueListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  TextTrackCue getCueById(String id) {
    return _wrap(_ptr.getCueById(_unwrap(id)));
  }

  TextTrackCue item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _TextTrackListImpl extends _EventTargetImpl implements TextTrackList {
  _TextTrackListImpl._wrap(ptr) : super._wrap(ptr);

  _TextTrackListEventsImpl get on() {
    if (_on == null) _on = new _TextTrackListEventsImpl(this);
    return _on;
  }

  int get length() => _wrap(_ptr.length);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool $dom_dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  TextTrack item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _TextTrackListEventsImpl extends _EventsImpl implements TextTrackListEvents {
  _TextTrackListEventsImpl(_ptr) : super(_ptr);

  EventListenerList get addTrack() => _get('addtrack');
}

class _TimeRangesImpl extends _DOMTypeBase implements TimeRanges {
  _TimeRangesImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  num end(int index) {
    return _wrap(_ptr.end(_unwrap(index)));
  }

  num start(int index) {
    return _wrap(_ptr.start(_unwrap(index)));
  }
}

class _TitleElementImpl extends _ElementImpl implements TitleElement {
  _TitleElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _TouchImpl extends _DOMTypeBase implements Touch {
  _TouchImpl._wrap(ptr) : super._wrap(ptr);

  int get clientX() => _wrap(_ptr.clientX);

  int get clientY() => _wrap(_ptr.clientY);

  int get identifier() => _wrap(_ptr.identifier);

  int get pageX() => _wrap(_ptr.pageX);

  int get pageY() => _wrap(_ptr.pageY);

  int get screenX() => _wrap(_ptr.screenX);

  int get screenY() => _wrap(_ptr.screenY);

  EventTarget get target() => _wrap(_ptr.target);

  num get webkitForce() => _wrap(_ptr.webkitForce);

  int get webkitRadiusX() => _wrap(_ptr.webkitRadiusX);

  int get webkitRadiusY() => _wrap(_ptr.webkitRadiusY);

  num get webkitRotationAngle() => _wrap(_ptr.webkitRotationAngle);
}

class _TouchEventImpl extends _UIEventImpl implements TouchEvent {
  _TouchEventImpl._wrap(ptr) : super._wrap(ptr);

  bool get altKey() => _wrap(_ptr.altKey);

  TouchList get changedTouches() => _wrap(_ptr.changedTouches);

  bool get ctrlKey() => _wrap(_ptr.ctrlKey);

  bool get metaKey() => _wrap(_ptr.metaKey);

  bool get shiftKey() => _wrap(_ptr.shiftKey);

  TouchList get targetTouches() => _wrap(_ptr.targetTouches);

  TouchList get touches() => _wrap(_ptr.touches);

  void initTouchEvent(TouchList touches, TouchList targetTouches, TouchList changedTouches, String type, Window view, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey) {
    _ptr.initTouchEvent(_unwrap(touches), _unwrap(targetTouches), _unwrap(changedTouches), _unwrap(type), _unwrap(view), _unwrap(screenX), _unwrap(screenY), _unwrap(clientX), _unwrap(clientY), _unwrap(ctrlKey), _unwrap(altKey), _unwrap(shiftKey), _unwrap(metaKey));
    return;
  }
}

class _TouchListImpl extends _DOMTypeBase implements TouchList {
  _TouchListImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  Touch operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, Touch value) {
    throw new UnsupportedOperationException("Cannot assign element of immutable List.");
  }
  // -- start List<Touch> mixins.
  // Touch is the element type.

  // From Iterable<Touch>:

  Iterator<Touch> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<Touch>(this);
  }

  // From Collection<Touch>:

  void add(Touch value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(Touch value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<Touch> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(Touch element)) => _Collections.forEach(this, f);

  Collection map(f(Touch element)) => _Collections.map(this, [], f);

  Collection<Touch> filter(bool f(Touch element)) =>
     _Collections.filter(this, <Touch>[], f);

  bool every(bool f(Touch element)) => _Collections.every(this, f);

  bool some(bool f(Touch element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<Touch>:

  void sort(int compare(Touch a, Touch b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(Touch element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(Touch element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  Touch last() => this[length - 1];

  Touch removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<Touch> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [Touch initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<Touch> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <Touch>[]);

  // -- end List<Touch> mixins.

  Touch item(int index) {
    return _wrap(_ptr.item(_unwrap(index)));
  }
}

class _TrackElementImpl extends _ElementImpl implements TrackElement {
  _TrackElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get defaultValue() => _wrap(_ptr.defaultValue);

  void set defaultValue(bool value) { _ptr.defaultValue = _unwrap(value); }

  String get kind() => _wrap(_ptr.kind);

  void set kind(String value) { _ptr.kind = _unwrap(value); }

  String get label() => _wrap(_ptr.label);

  void set label(String value) { _ptr.label = _unwrap(value); }

  int get readyState() => _wrap(_ptr.readyState);

  String get src() => _wrap(_ptr.src);

  void set src(String value) { _ptr.src = _unwrap(value); }

  String get srclang() => _wrap(_ptr.srclang);

  void set srclang(String value) { _ptr.srclang = _unwrap(value); }

  TextTrack get track() => _wrap(_ptr.track);
}

class _TrackEventImpl extends _EventImpl implements TrackEvent {
  _TrackEventImpl._wrap(ptr) : super._wrap(ptr);

  Object get track() => _wrap(_ptr.track);
}

class _TransitionEventImpl extends _EventImpl implements TransitionEvent {
  _TransitionEventImpl._wrap(ptr) : super._wrap(ptr);

  num get elapsedTime() => _wrap(_ptr.elapsedTime);

  String get propertyName() => _wrap(_ptr.propertyName);
}

class _TreeWalkerImpl extends _DOMTypeBase implements TreeWalker {
  _TreeWalkerImpl._wrap(ptr) : super._wrap(ptr);

  Node get currentNode() => _wrap(_ptr.currentNode);

  void set currentNode(Node value) { _ptr.currentNode = _unwrap(value); }

  bool get expandEntityReferences() => _wrap(_ptr.expandEntityReferences);

  NodeFilter get filter() => _wrap(_ptr.filter);

  Node get root() => _wrap(_ptr.root);

  int get whatToShow() => _wrap(_ptr.whatToShow);

  Node firstChild() {
    return _wrap(_ptr.firstChild());
  }

  Node lastChild() {
    return _wrap(_ptr.lastChild());
  }

  Node nextNode() {
    return _wrap(_ptr.nextNode());
  }

  Node nextSibling() {
    return _wrap(_ptr.nextSibling());
  }

  Node parentNode() {
    return _wrap(_ptr.parentNode());
  }

  Node previousNode() {
    return _wrap(_ptr.previousNode());
  }

  Node previousSibling() {
    return _wrap(_ptr.previousSibling());
  }
}

class _UIEventImpl extends _EventImpl implements UIEvent {
  _UIEventImpl._wrap(ptr) : super._wrap(ptr);

  int get charCode() => _wrap(_ptr.charCode);

  int get detail() => _wrap(_ptr.detail);

  int get keyCode() => _wrap(_ptr.keyCode);

  int get layerX() => _wrap(_ptr.layerX);

  int get layerY() => _wrap(_ptr.layerY);

  int get pageX() => _wrap(_ptr.pageX);

  int get pageY() => _wrap(_ptr.pageY);

  Window get view() => _wrap(_ptr.view);

  int get which() => _wrap(_ptr.which);

  void initUIEvent(String type, bool canBubble, bool cancelable, Window view, int detail) {
    _ptr.initUIEvent(_unwrap(type), _unwrap(canBubble), _unwrap(cancelable), _unwrap(view), _unwrap(detail));
    return;
  }
}

class _UListElementImpl extends _ElementImpl implements UListElement {
  _UListElementImpl._wrap(ptr) : super._wrap(ptr);

  bool get compact() => _wrap(_ptr.compact);

  void set compact(bool value) { _ptr.compact = _unwrap(value); }

  String get type() => _wrap(_ptr.type);

  void set type(String value) { _ptr.type = _unwrap(value); }
}

class _Uint16ArrayImpl extends _ArrayBufferViewImpl implements Uint16Array, List<int> {
  _Uint16ArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  int operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, int value) {
    return _ptr[index] = _unwrap(value);
  }
  // -- start List<int> mixins.
  // int is the element type.

  // From Iterable<int>:

  Iterator<int> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<int>(this);
  }

  // From Collection<int>:

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(int element)) => _Collections.forEach(this, f);

  Collection map(f(int element)) => _Collections.map(this, [], f);

  Collection<int> filter(bool f(int element)) =>
     _Collections.filter(this, <int>[], f);

  bool every(bool f(int element)) => _Collections.every(this, f);

  bool some(bool f(int element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<int>:

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(int element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(int element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int last() => this[length - 1];

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <int>[]);

  // -- end List<int> mixins.

  void setElements(Object array, [int offset = null]) {
    if (offset === null) {
      _ptr.setElements(_unwrap(array));
      return;
    } else {
      _ptr.setElements(_unwrap(array), _unwrap(offset));
      return;
    }
  }

  Uint16Array subarray(int start, [int end = null]) {
    if (end === null) {
      return _wrap(_ptr.subarray(_unwrap(start)));
    } else {
      return _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
    }
  }
}

class _Uint32ArrayImpl extends _ArrayBufferViewImpl implements Uint32Array, List<int> {
  _Uint32ArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  int operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, int value) {
    return _ptr[index] = _unwrap(value);
  }
  // -- start List<int> mixins.
  // int is the element type.

  // From Iterable<int>:

  Iterator<int> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<int>(this);
  }

  // From Collection<int>:

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(int element)) => _Collections.forEach(this, f);

  Collection map(f(int element)) => _Collections.map(this, [], f);

  Collection<int> filter(bool f(int element)) =>
     _Collections.filter(this, <int>[], f);

  bool every(bool f(int element)) => _Collections.every(this, f);

  bool some(bool f(int element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<int>:

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(int element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(int element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int last() => this[length - 1];

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <int>[]);

  // -- end List<int> mixins.

  void setElements(Object array, [int offset = null]) {
    if (offset === null) {
      _ptr.setElements(_unwrap(array));
      return;
    } else {
      _ptr.setElements(_unwrap(array), _unwrap(offset));
      return;
    }
  }

  Uint32Array subarray(int start, [int end = null]) {
    if (end === null) {
      return _wrap(_ptr.subarray(_unwrap(start)));
    } else {
      return _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
    }
  }
}

class _Uint8ArrayImpl extends _ArrayBufferViewImpl implements Uint8Array, List<int> {
  _Uint8ArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  int operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, int value) {
    return _ptr[index] = _unwrap(value);
  }
  // -- start List<int> mixins.
  // int is the element type.

  // From Iterable<int>:

  Iterator<int> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<int>(this);
  }

  // From Collection<int>:

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(int element)) => _Collections.forEach(this, f);

  Collection map(f(int element)) => _Collections.map(this, [], f);

  Collection<int> filter(bool f(int element)) =>
     _Collections.filter(this, <int>[], f);

  bool every(bool f(int element)) => _Collections.every(this, f);

  bool some(bool f(int element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<int>:

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(int element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(int element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int last() => this[length - 1];

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <int>[]);

  // -- end List<int> mixins.

  void setElements(Object array, [int offset = null]) {
    if (offset === null) {
      _ptr.setElements(_unwrap(array));
      return;
    } else {
      _ptr.setElements(_unwrap(array), _unwrap(offset));
      return;
    }
  }

  Uint8Array subarray(int start, [int end = null]) {
    if (end === null) {
      return _wrap(_ptr.subarray(_unwrap(start)));
    } else {
      return _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
    }
  }
}

class _Uint8ClampedArrayImpl extends _Uint8ArrayImpl implements Uint8ClampedArray, List<int> {
  _Uint8ClampedArrayImpl._wrap(ptr) : super._wrap(ptr);

  int get length() => _wrap(_ptr.length);

  int operator[](int index) => _wrap(_ptr[index]);

  void operator[]=(int index, int value) {
    return _ptr[index] = _unwrap(value);
  }
  // -- start List<int> mixins.
  // int is the element type.

  // From Iterable<int>:

  Iterator<int> iterator() {
    // Note: NodeLists are not fixed size. And most probably length shouldn't
    // be cached in both iterator _and_ forEach method. For now caching it
    // for consistency.
    return new _FixedSizeListIterator<int>(this);
  }

  // From Collection<int>:

  void add(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addLast(int value) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void addAll(Collection<int> collection) {
    throw new UnsupportedOperationException("Cannot add to immutable List.");
  }

  void forEach(void f(int element)) => _Collections.forEach(this, f);

  Collection map(f(int element)) => _Collections.map(this, [], f);

  Collection<int> filter(bool f(int element)) =>
     _Collections.filter(this, <int>[], f);

  bool every(bool f(int element)) => _Collections.every(this, f);

  bool some(bool f(int element)) => _Collections.some(this, f);

  bool isEmpty() => this.length == 0;

  // From List<int>:

  void sort(int compare(int a, int b)) {
    throw new UnsupportedOperationException("Cannot sort immutable List.");
  }

  int indexOf(int element, [int start = 0]) =>
      _Lists.indexOf(this, element, start, this.length);

  int lastIndexOf(int element, [int start]) {
    if (start === null) start = length - 1;
    return _Lists.lastIndexOf(this, element, start);
  }

  int last() => this[length - 1];

  int removeLast() {
    throw new UnsupportedOperationException("Cannot removeLast on immutable List.");
  }

  // FIXME: implement these.
  void setRange(int start, int rangeLength, List<int> from, [int startFrom]) {
    throw new UnsupportedOperationException("Cannot setRange on immutable List.");
  }

  void removeRange(int start, int rangeLength) {
    throw new UnsupportedOperationException("Cannot removeRange on immutable List.");
  }

  void insertRange(int start, int rangeLength, [int initialValue]) {
    throw new UnsupportedOperationException("Cannot insertRange on immutable List.");
  }

  List<int> getRange(int start, int rangeLength) =>
      _Lists.getRange(this, start, rangeLength, <int>[]);

  // -- end List<int> mixins.

  void setElements(Object array, [int offset = null]) {
    if (offset === null) {
      _ptr.setElements(_unwrap(array));
      return;
    } else {
      _ptr.setElements(_unwrap(array), _unwrap(offset));
      return;
    }
  }

  Uint8ClampedArray subarray(int start, [int end = null]) {
    if (end === null) {
      return _wrap(_ptr.subarray(_unwrap(start)));
    } else {
      return _wrap(_ptr.subarray(_unwrap(start), _unwrap(end)));
    }
  }

  // From ArrayBufferView

  ArrayBuffer get buffer() => _wrap(_ptr.buffer);

  int get byteLength() => _wrap(_ptr.byteLength);

  int get byteOffset() => _wrap(_ptr.byteOffset);
}

class _UnknownElementImpl extends _ElementImpl implements UnknownElement {
  _UnknownElementImpl._wrap(ptr) : super._wrap(ptr);
}

class _ValidityStateImpl extends _DOMTypeBase implements ValidityState {
  _ValidityStateImpl._wrap(ptr) : super._wrap(ptr);

  bool get customError() => _wrap(_ptr.customError);

  bool get patternMismatch() => _wrap(_ptr.patternMismatch);

  bool get rangeOverflow() => _wrap(_ptr.rangeOverflow);

  bool get rangeUnderflow() => _wrap(_ptr.rangeUnderflow);

  bool get stepMismatch() => _wrap(_ptr.stepMismatch);

  bool get tooLong() => _wrap(_ptr.tooLong);

  bool get typeMismatch() => _wrap(_ptr.typeMismatch);

  bool get valid() => _wrap(_ptr.valid);

  bool get valueMissing() => _wrap(_ptr.valueMissing);
}

class _VideoElementImpl extends _MediaElementImpl implements VideoElement {
  _VideoElementImpl._wrap(ptr) : super._wrap(ptr);

  int get height() => _wrap(_ptr.height);

  void set height(int value) { _ptr.height = _unwrap(value); }

  String get poster() => _wrap(_ptr.poster);

  void set poster(String value) { _ptr.poster = _unwrap(value); }

  int get videoHeight() => _wrap(_ptr.videoHeight);

  int get videoWidth() => _wrap(_ptr.videoWidth);

  int get webkitDecodedFrameCount() => _wrap(_ptr.webkitDecodedFrameCount);

  bool get webkitDisplayingFullscreen() => _wrap(_ptr.webkitDisplayingFullscreen);

  int get webkitDroppedFrameCount() => _wrap(_ptr.webkitDroppedFrameCount);

  bool get webkitSupportsFullscreen() => _wrap(_ptr.webkitSupportsFullscreen);

  int get width() => _wrap(_ptr.width);

  void set width(int value) { _ptr.width = _unwrap(value); }

  void webkitEnterFullScreen() {
    _ptr.webkitEnterFullScreen();
    return;
  }

  void webkitEnterFullscreen() {
    _ptr.webkitEnterFullscreen();
    return;
  }

  void webkitExitFullScreen() {
    _ptr.webkitExitFullScreen();
    return;
  }

  void webkitExitFullscreen() {
    _ptr.webkitExitFullscreen();
    return;
  }
}

class _WaveShaperNodeImpl extends _AudioNodeImpl implements WaveShaperNode {
  _WaveShaperNodeImpl._wrap(ptr) : super._wrap(ptr);

  Float32Array get curve() => _wrap(_ptr.curve);

  void set curve(Float32Array value) { _ptr.curve = _unwrap(value); }
}

class _WaveTableImpl extends _DOMTypeBase implements WaveTable {
  _WaveTableImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLActiveInfoImpl extends _DOMTypeBase implements WebGLActiveInfo {
  _WebGLActiveInfoImpl._wrap(ptr) : super._wrap(ptr);

  String get name() => _wrap(_ptr.name);

  int get size() => _wrap(_ptr.size);

  int get type() => _wrap(_ptr.type);
}

class _WebGLBufferImpl extends _DOMTypeBase implements WebGLBuffer {
  _WebGLBufferImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLCompressedTextureS3TCImpl extends _DOMTypeBase implements WebGLCompressedTextureS3TC {
  _WebGLCompressedTextureS3TCImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLContextAttributesImpl extends _DOMTypeBase implements WebGLContextAttributes {
  _WebGLContextAttributesImpl._wrap(ptr) : super._wrap(ptr);

  bool get alpha() => _wrap(_ptr.alpha);

  void set alpha(bool value) { _ptr.alpha = _unwrap(value); }

  bool get antialias() => _wrap(_ptr.antialias);

  void set antialias(bool value) { _ptr.antialias = _unwrap(value); }

  bool get depth() => _wrap(_ptr.depth);

  void set depth(bool value) { _ptr.depth = _unwrap(value); }

  bool get premultipliedAlpha() => _wrap(_ptr.premultipliedAlpha);

  void set premultipliedAlpha(bool value) { _ptr.premultipliedAlpha = _unwrap(value); }

  bool get preserveDrawingBuffer() => _wrap(_ptr.preserveDrawingBuffer);

  void set preserveDrawingBuffer(bool value) { _ptr.preserveDrawingBuffer = _unwrap(value); }

  bool get stencil() => _wrap(_ptr.stencil);

  void set stencil(bool value) { _ptr.stencil = _unwrap(value); }
}

class _WebGLContextEventImpl extends _EventImpl implements WebGLContextEvent {
  _WebGLContextEventImpl._wrap(ptr) : super._wrap(ptr);

  String get statusMessage() => _wrap(_ptr.statusMessage);
}

class _WebGLDebugRendererInfoImpl extends _DOMTypeBase implements WebGLDebugRendererInfo {
  _WebGLDebugRendererInfoImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLDebugShadersImpl extends _DOMTypeBase implements WebGLDebugShaders {
  _WebGLDebugShadersImpl._wrap(ptr) : super._wrap(ptr);

  String getTranslatedShaderSource(WebGLShader shader) {
    return _wrap(_ptr.getTranslatedShaderSource(_unwrap(shader)));
  }
}

class _WebGLFramebufferImpl extends _DOMTypeBase implements WebGLFramebuffer {
  _WebGLFramebufferImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLLoseContextImpl extends _DOMTypeBase implements WebGLLoseContext {
  _WebGLLoseContextImpl._wrap(ptr) : super._wrap(ptr);

  void loseContext() {
    _ptr.loseContext();
    return;
  }

  void restoreContext() {
    _ptr.restoreContext();
    return;
  }
}

class _WebGLProgramImpl extends _DOMTypeBase implements WebGLProgram {
  _WebGLProgramImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLRenderbufferImpl extends _DOMTypeBase implements WebGLRenderbuffer {
  _WebGLRenderbufferImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLRenderingContextImpl extends _CanvasRenderingContextImpl implements WebGLRenderingContext {
  _WebGLRenderingContextImpl._wrap(ptr) : super._wrap(ptr);

  int get drawingBufferHeight() => _wrap(_ptr.drawingBufferHeight);

  int get drawingBufferWidth() => _wrap(_ptr.drawingBufferWidth);

  void activeTexture(int texture) {
    _ptr.activeTexture(_unwrap(texture));
    return;
  }

  void attachShader(WebGLProgram program, WebGLShader shader) {
    _ptr.attachShader(_unwrap(program), _unwrap(shader));
    return;
  }

  void bindAttribLocation(WebGLProgram program, int index, String name) {
    _ptr.bindAttribLocation(_unwrap(program), _unwrap(index), _unwrap(name));
    return;
  }

  void bindBuffer(int target, WebGLBuffer buffer) {
    _ptr.bindBuffer(_unwrap(target), _unwrap(buffer));
    return;
  }

  void bindFramebuffer(int target, WebGLFramebuffer framebuffer) {
    _ptr.bindFramebuffer(_unwrap(target), _unwrap(framebuffer));
    return;
  }

  void bindRenderbuffer(int target, WebGLRenderbuffer renderbuffer) {
    _ptr.bindRenderbuffer(_unwrap(target), _unwrap(renderbuffer));
    return;
  }

  void bindTexture(int target, WebGLTexture texture) {
    _ptr.bindTexture(_unwrap(target), _unwrap(texture));
    return;
  }

  void blendColor(num red, num green, num blue, num alpha) {
    _ptr.blendColor(_unwrap(red), _unwrap(green), _unwrap(blue), _unwrap(alpha));
    return;
  }

  void blendEquation(int mode) {
    _ptr.blendEquation(_unwrap(mode));
    return;
  }

  void blendEquationSeparate(int modeRGB, int modeAlpha) {
    _ptr.blendEquationSeparate(_unwrap(modeRGB), _unwrap(modeAlpha));
    return;
  }

  void blendFunc(int sfactor, int dfactor) {
    _ptr.blendFunc(_unwrap(sfactor), _unwrap(dfactor));
    return;
  }

  void blendFuncSeparate(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha) {
    _ptr.blendFuncSeparate(_unwrap(srcRGB), _unwrap(dstRGB), _unwrap(srcAlpha), _unwrap(dstAlpha));
    return;
  }

  void bufferData(int target, data_OR_size, int usage) {
    if (data_OR_size is ArrayBuffer) {
      _ptr.bufferData(_unwrap(target), _unwrap(data_OR_size), _unwrap(usage));
      return;
    } else {
      if (data_OR_size is ArrayBufferView) {
        _ptr.bufferData(_unwrap(target), _unwrap(data_OR_size), _unwrap(usage));
        return;
      } else {
        if (data_OR_size is int) {
          _ptr.bufferData(_unwrap(target), _unwrap(data_OR_size), _unwrap(usage));
          return;
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void bufferSubData(int target, int offset, data) {
    if (data is ArrayBuffer) {
      _ptr.bufferSubData(_unwrap(target), _unwrap(offset), _unwrap(data));
      return;
    } else {
      if (data is ArrayBufferView) {
        _ptr.bufferSubData(_unwrap(target), _unwrap(offset), _unwrap(data));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }

  int checkFramebufferStatus(int target) {
    return _wrap(_ptr.checkFramebufferStatus(_unwrap(target)));
  }

  void clear(int mask) {
    _ptr.clear(_unwrap(mask));
    return;
  }

  void clearColor(num red, num green, num blue, num alpha) {
    _ptr.clearColor(_unwrap(red), _unwrap(green), _unwrap(blue), _unwrap(alpha));
    return;
  }

  void clearDepth(num depth) {
    _ptr.clearDepth(_unwrap(depth));
    return;
  }

  void clearStencil(int s) {
    _ptr.clearStencil(_unwrap(s));
    return;
  }

  void colorMask(bool red, bool green, bool blue, bool alpha) {
    _ptr.colorMask(_unwrap(red), _unwrap(green), _unwrap(blue), _unwrap(alpha));
    return;
  }

  void compileShader(WebGLShader shader) {
    _ptr.compileShader(_unwrap(shader));
    return;
  }

  void compressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, ArrayBufferView data) {
    _ptr.compressedTexImage2D(_unwrap(target), _unwrap(level), _unwrap(internalformat), _unwrap(width), _unwrap(height), _unwrap(border), _unwrap(data));
    return;
  }

  void compressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, ArrayBufferView data) {
    _ptr.compressedTexSubImage2D(_unwrap(target), _unwrap(level), _unwrap(xoffset), _unwrap(yoffset), _unwrap(width), _unwrap(height), _unwrap(format), _unwrap(data));
    return;
  }

  void copyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border) {
    _ptr.copyTexImage2D(_unwrap(target), _unwrap(level), _unwrap(internalformat), _unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height), _unwrap(border));
    return;
  }

  void copyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height) {
    _ptr.copyTexSubImage2D(_unwrap(target), _unwrap(level), _unwrap(xoffset), _unwrap(yoffset), _unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height));
    return;
  }

  WebGLBuffer createBuffer() {
    return _wrap(_ptr.createBuffer());
  }

  WebGLFramebuffer createFramebuffer() {
    return _wrap(_ptr.createFramebuffer());
  }

  WebGLProgram createProgram() {
    return _wrap(_ptr.createProgram());
  }

  WebGLRenderbuffer createRenderbuffer() {
    return _wrap(_ptr.createRenderbuffer());
  }

  WebGLShader createShader(int type) {
    return _wrap(_ptr.createShader(_unwrap(type)));
  }

  WebGLTexture createTexture() {
    return _wrap(_ptr.createTexture());
  }

  void cullFace(int mode) {
    _ptr.cullFace(_unwrap(mode));
    return;
  }

  void deleteBuffer(WebGLBuffer buffer) {
    _ptr.deleteBuffer(_unwrap(buffer));
    return;
  }

  void deleteFramebuffer(WebGLFramebuffer framebuffer) {
    _ptr.deleteFramebuffer(_unwrap(framebuffer));
    return;
  }

  void deleteProgram(WebGLProgram program) {
    _ptr.deleteProgram(_unwrap(program));
    return;
  }

  void deleteRenderbuffer(WebGLRenderbuffer renderbuffer) {
    _ptr.deleteRenderbuffer(_unwrap(renderbuffer));
    return;
  }

  void deleteShader(WebGLShader shader) {
    _ptr.deleteShader(_unwrap(shader));
    return;
  }

  void deleteTexture(WebGLTexture texture) {
    _ptr.deleteTexture(_unwrap(texture));
    return;
  }

  void depthFunc(int func) {
    _ptr.depthFunc(_unwrap(func));
    return;
  }

  void depthMask(bool flag) {
    _ptr.depthMask(_unwrap(flag));
    return;
  }

  void depthRange(num zNear, num zFar) {
    _ptr.depthRange(_unwrap(zNear), _unwrap(zFar));
    return;
  }

  void detachShader(WebGLProgram program, WebGLShader shader) {
    _ptr.detachShader(_unwrap(program), _unwrap(shader));
    return;
  }

  void disable(int cap) {
    _ptr.disable(_unwrap(cap));
    return;
  }

  void disableVertexAttribArray(int index) {
    _ptr.disableVertexAttribArray(_unwrap(index));
    return;
  }

  void drawArrays(int mode, int first, int count) {
    _ptr.drawArrays(_unwrap(mode), _unwrap(first), _unwrap(count));
    return;
  }

  void drawElements(int mode, int count, int type, int offset) {
    _ptr.drawElements(_unwrap(mode), _unwrap(count), _unwrap(type), _unwrap(offset));
    return;
  }

  void enable(int cap) {
    _ptr.enable(_unwrap(cap));
    return;
  }

  void enableVertexAttribArray(int index) {
    _ptr.enableVertexAttribArray(_unwrap(index));
    return;
  }

  void finish() {
    _ptr.finish();
    return;
  }

  void flush() {
    _ptr.flush();
    return;
  }

  void framebufferRenderbuffer(int target, int attachment, int renderbuffertarget, WebGLRenderbuffer renderbuffer) {
    _ptr.framebufferRenderbuffer(_unwrap(target), _unwrap(attachment), _unwrap(renderbuffertarget), _unwrap(renderbuffer));
    return;
  }

  void framebufferTexture2D(int target, int attachment, int textarget, WebGLTexture texture, int level) {
    _ptr.framebufferTexture2D(_unwrap(target), _unwrap(attachment), _unwrap(textarget), _unwrap(texture), _unwrap(level));
    return;
  }

  void frontFace(int mode) {
    _ptr.frontFace(_unwrap(mode));
    return;
  }

  void generateMipmap(int target) {
    _ptr.generateMipmap(_unwrap(target));
    return;
  }

  WebGLActiveInfo getActiveAttrib(WebGLProgram program, int index) {
    return _wrap(_ptr.getActiveAttrib(_unwrap(program), _unwrap(index)));
  }

  WebGLActiveInfo getActiveUniform(WebGLProgram program, int index) {
    return _wrap(_ptr.getActiveUniform(_unwrap(program), _unwrap(index)));
  }

  List getAttachedShaders(WebGLProgram program) {
    return _wrap(_ptr.getAttachedShaders(_unwrap(program)));
  }

  int getAttribLocation(WebGLProgram program, String name) {
    return _wrap(_ptr.getAttribLocation(_unwrap(program), _unwrap(name)));
  }

  Object getBufferParameter(int target, int pname) {
    return _wrap(_ptr.getBufferParameter(_unwrap(target), _unwrap(pname)));
  }

  WebGLContextAttributes getContextAttributes() {
    return _wrap(_ptr.getContextAttributes());
  }

  int getError() {
    return _wrap(_ptr.getError());
  }

  Object getExtension(String name) {
    return _wrap(_ptr.getExtension(_unwrap(name)));
  }

  Object getFramebufferAttachmentParameter(int target, int attachment, int pname) {
    return _wrap(_ptr.getFramebufferAttachmentParameter(_unwrap(target), _unwrap(attachment), _unwrap(pname)));
  }

  Object getParameter(int pname) {
    return _wrap(_ptr.getParameter(_unwrap(pname)));
  }

  String getProgramInfoLog(WebGLProgram program) {
    return _wrap(_ptr.getProgramInfoLog(_unwrap(program)));
  }

  Object getProgramParameter(WebGLProgram program, int pname) {
    return _wrap(_ptr.getProgramParameter(_unwrap(program), _unwrap(pname)));
  }

  Object getRenderbufferParameter(int target, int pname) {
    return _wrap(_ptr.getRenderbufferParameter(_unwrap(target), _unwrap(pname)));
  }

  String getShaderInfoLog(WebGLShader shader) {
    return _wrap(_ptr.getShaderInfoLog(_unwrap(shader)));
  }

  Object getShaderParameter(WebGLShader shader, int pname) {
    return _wrap(_ptr.getShaderParameter(_unwrap(shader), _unwrap(pname)));
  }

  WebGLShaderPrecisionFormat getShaderPrecisionFormat(int shadertype, int precisiontype) {
    return _wrap(_ptr.getShaderPrecisionFormat(_unwrap(shadertype), _unwrap(precisiontype)));
  }

  String getShaderSource(WebGLShader shader) {
    return _wrap(_ptr.getShaderSource(_unwrap(shader)));
  }

  Object getTexParameter(int target, int pname) {
    return _wrap(_ptr.getTexParameter(_unwrap(target), _unwrap(pname)));
  }

  Object getUniform(WebGLProgram program, WebGLUniformLocation location) {
    return _wrap(_ptr.getUniform(_unwrap(program), _unwrap(location)));
  }

  WebGLUniformLocation getUniformLocation(WebGLProgram program, String name) {
    return _wrap(_ptr.getUniformLocation(_unwrap(program), _unwrap(name)));
  }

  Object getVertexAttrib(int index, int pname) {
    return _wrap(_ptr.getVertexAttrib(_unwrap(index), _unwrap(pname)));
  }

  int getVertexAttribOffset(int index, int pname) {
    return _wrap(_ptr.getVertexAttribOffset(_unwrap(index), _unwrap(pname)));
  }

  void hint(int target, int mode) {
    _ptr.hint(_unwrap(target), _unwrap(mode));
    return;
  }

  bool isBuffer(WebGLBuffer buffer) {
    return _wrap(_ptr.isBuffer(_unwrap(buffer)));
  }

  bool isContextLost() {
    return _wrap(_ptr.isContextLost());
  }

  bool isEnabled(int cap) {
    return _wrap(_ptr.isEnabled(_unwrap(cap)));
  }

  bool isFramebuffer(WebGLFramebuffer framebuffer) {
    return _wrap(_ptr.isFramebuffer(_unwrap(framebuffer)));
  }

  bool isProgram(WebGLProgram program) {
    return _wrap(_ptr.isProgram(_unwrap(program)));
  }

  bool isRenderbuffer(WebGLRenderbuffer renderbuffer) {
    return _wrap(_ptr.isRenderbuffer(_unwrap(renderbuffer)));
  }

  bool isShader(WebGLShader shader) {
    return _wrap(_ptr.isShader(_unwrap(shader)));
  }

  bool isTexture(WebGLTexture texture) {
    return _wrap(_ptr.isTexture(_unwrap(texture)));
  }

  void lineWidth(num width) {
    _ptr.lineWidth(_unwrap(width));
    return;
  }

  void linkProgram(WebGLProgram program) {
    _ptr.linkProgram(_unwrap(program));
    return;
  }

  void pixelStorei(int pname, int param) {
    _ptr.pixelStorei(_unwrap(pname), _unwrap(param));
    return;
  }

  void polygonOffset(num factor, num units) {
    _ptr.polygonOffset(_unwrap(factor), _unwrap(units));
    return;
  }

  void readPixels(int x, int y, int width, int height, int format, int type, ArrayBufferView pixels) {
    _ptr.readPixels(_unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height), _unwrap(format), _unwrap(type), _unwrap(pixels));
    return;
  }

  void releaseShaderCompiler() {
    _ptr.releaseShaderCompiler();
    return;
  }

  void renderbufferStorage(int target, int internalformat, int width, int height) {
    _ptr.renderbufferStorage(_unwrap(target), _unwrap(internalformat), _unwrap(width), _unwrap(height));
    return;
  }

  void sampleCoverage(num value, bool invert) {
    _ptr.sampleCoverage(_unwrap(value), _unwrap(invert));
    return;
  }

  void scissor(int x, int y, int width, int height) {
    _ptr.scissor(_unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height));
    return;
  }

  void shaderSource(WebGLShader shader, String string) {
    _ptr.shaderSource(_unwrap(shader), _unwrap(string));
    return;
  }

  void stencilFunc(int func, int ref, int mask) {
    _ptr.stencilFunc(_unwrap(func), _unwrap(ref), _unwrap(mask));
    return;
  }

  void stencilFuncSeparate(int face, int func, int ref, int mask) {
    _ptr.stencilFuncSeparate(_unwrap(face), _unwrap(func), _unwrap(ref), _unwrap(mask));
    return;
  }

  void stencilMask(int mask) {
    _ptr.stencilMask(_unwrap(mask));
    return;
  }

  void stencilMaskSeparate(int face, int mask) {
    _ptr.stencilMaskSeparate(_unwrap(face), _unwrap(mask));
    return;
  }

  void stencilOp(int fail, int zfail, int zpass) {
    _ptr.stencilOp(_unwrap(fail), _unwrap(zfail), _unwrap(zpass));
    return;
  }

  void stencilOpSeparate(int face, int fail, int zfail, int zpass) {
    _ptr.stencilOpSeparate(_unwrap(face), _unwrap(fail), _unwrap(zfail), _unwrap(zpass));
    return;
  }

  void texImage2D(int target, int level, int internalformat, int format_OR_width, int height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video, [int format = null, int type = null, ArrayBufferView pixels = null]) {
    if (border_OR_canvas_OR_image_OR_pixels_OR_video is ImageData) {
      if (format === null) {
        if (type === null) {
          if (pixels === null) {
            _ptr.texImage2D(_unwrap(target), _unwrap(level), _unwrap(internalformat), _unwrap(format_OR_width), _unwrap(height_OR_type), _unwrap(border_OR_canvas_OR_image_OR_pixels_OR_video));
            return;
          }
        }
      }
    } else {
      if (border_OR_canvas_OR_image_OR_pixels_OR_video is ImageElement) {
        if (format === null) {
          if (type === null) {
            if (pixels === null) {
              _ptr.texImage2D(_unwrap(target), _unwrap(level), _unwrap(internalformat), _unwrap(format_OR_width), _unwrap(height_OR_type), _unwrap(border_OR_canvas_OR_image_OR_pixels_OR_video));
              return;
            }
          }
        }
      } else {
        if (border_OR_canvas_OR_image_OR_pixels_OR_video is CanvasElement) {
          if (format === null) {
            if (type === null) {
              if (pixels === null) {
                _ptr.texImage2D(_unwrap(target), _unwrap(level), _unwrap(internalformat), _unwrap(format_OR_width), _unwrap(height_OR_type), _unwrap(border_OR_canvas_OR_image_OR_pixels_OR_video));
                return;
              }
            }
          }
        } else {
          if (border_OR_canvas_OR_image_OR_pixels_OR_video is VideoElement) {
            if (format === null) {
              if (type === null) {
                if (pixels === null) {
                  _ptr.texImage2D(_unwrap(target), _unwrap(level), _unwrap(internalformat), _unwrap(format_OR_width), _unwrap(height_OR_type), _unwrap(border_OR_canvas_OR_image_OR_pixels_OR_video));
                  return;
                }
              }
            }
          } else {
            if (border_OR_canvas_OR_image_OR_pixels_OR_video is int) {
              _ptr.texImage2D(_unwrap(target), _unwrap(level), _unwrap(internalformat), _unwrap(format_OR_width), _unwrap(height_OR_type), _unwrap(border_OR_canvas_OR_image_OR_pixels_OR_video), _unwrap(format), _unwrap(type), _unwrap(pixels));
              return;
            }
          }
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void texParameterf(int target, int pname, num param) {
    _ptr.texParameterf(_unwrap(target), _unwrap(pname), _unwrap(param));
    return;
  }

  void texParameteri(int target, int pname, int param) {
    _ptr.texParameteri(_unwrap(target), _unwrap(pname), _unwrap(param));
    return;
  }

  void texSubImage2D(int target, int level, int xoffset, int yoffset, int format_OR_width, int height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video, [int type = null, ArrayBufferView pixels = null]) {
    if (canvas_OR_format_OR_image_OR_pixels_OR_video is ImageData) {
      if (type === null) {
        if (pixels === null) {
          _ptr.texSubImage2D(_unwrap(target), _unwrap(level), _unwrap(xoffset), _unwrap(yoffset), _unwrap(format_OR_width), _unwrap(height_OR_type), _unwrap(canvas_OR_format_OR_image_OR_pixels_OR_video));
          return;
        }
      }
    } else {
      if (canvas_OR_format_OR_image_OR_pixels_OR_video is ImageElement) {
        if (type === null) {
          if (pixels === null) {
            _ptr.texSubImage2D(_unwrap(target), _unwrap(level), _unwrap(xoffset), _unwrap(yoffset), _unwrap(format_OR_width), _unwrap(height_OR_type), _unwrap(canvas_OR_format_OR_image_OR_pixels_OR_video));
            return;
          }
        }
      } else {
        if (canvas_OR_format_OR_image_OR_pixels_OR_video is CanvasElement) {
          if (type === null) {
            if (pixels === null) {
              _ptr.texSubImage2D(_unwrap(target), _unwrap(level), _unwrap(xoffset), _unwrap(yoffset), _unwrap(format_OR_width), _unwrap(height_OR_type), _unwrap(canvas_OR_format_OR_image_OR_pixels_OR_video));
              return;
            }
          }
        } else {
          if (canvas_OR_format_OR_image_OR_pixels_OR_video is VideoElement) {
            if (type === null) {
              if (pixels === null) {
                _ptr.texSubImage2D(_unwrap(target), _unwrap(level), _unwrap(xoffset), _unwrap(yoffset), _unwrap(format_OR_width), _unwrap(height_OR_type), _unwrap(canvas_OR_format_OR_image_OR_pixels_OR_video));
                return;
              }
            }
          } else {
            if (canvas_OR_format_OR_image_OR_pixels_OR_video is int) {
              _ptr.texSubImage2D(_unwrap(target), _unwrap(level), _unwrap(xoffset), _unwrap(yoffset), _unwrap(format_OR_width), _unwrap(height_OR_type), _unwrap(canvas_OR_format_OR_image_OR_pixels_OR_video), _unwrap(type), _unwrap(pixels));
              return;
            }
          }
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void uniform1f(WebGLUniformLocation location, num x) {
    _ptr.uniform1f(_unwrap(location), _unwrap(x));
    return;
  }

  void uniform1fv(WebGLUniformLocation location, Float32Array v) {
    _ptr.uniform1fv(_unwrap(location), _unwrap(v));
    return;
  }

  void uniform1i(WebGLUniformLocation location, int x) {
    _ptr.uniform1i(_unwrap(location), _unwrap(x));
    return;
  }

  void uniform1iv(WebGLUniformLocation location, Int32Array v) {
    _ptr.uniform1iv(_unwrap(location), _unwrap(v));
    return;
  }

  void uniform2f(WebGLUniformLocation location, num x, num y) {
    _ptr.uniform2f(_unwrap(location), _unwrap(x), _unwrap(y));
    return;
  }

  void uniform2fv(WebGLUniformLocation location, Float32Array v) {
    _ptr.uniform2fv(_unwrap(location), _unwrap(v));
    return;
  }

  void uniform2i(WebGLUniformLocation location, int x, int y) {
    _ptr.uniform2i(_unwrap(location), _unwrap(x), _unwrap(y));
    return;
  }

  void uniform2iv(WebGLUniformLocation location, Int32Array v) {
    _ptr.uniform2iv(_unwrap(location), _unwrap(v));
    return;
  }

  void uniform3f(WebGLUniformLocation location, num x, num y, num z) {
    _ptr.uniform3f(_unwrap(location), _unwrap(x), _unwrap(y), _unwrap(z));
    return;
  }

  void uniform3fv(WebGLUniformLocation location, Float32Array v) {
    _ptr.uniform3fv(_unwrap(location), _unwrap(v));
    return;
  }

  void uniform3i(WebGLUniformLocation location, int x, int y, int z) {
    _ptr.uniform3i(_unwrap(location), _unwrap(x), _unwrap(y), _unwrap(z));
    return;
  }

  void uniform3iv(WebGLUniformLocation location, Int32Array v) {
    _ptr.uniform3iv(_unwrap(location), _unwrap(v));
    return;
  }

  void uniform4f(WebGLUniformLocation location, num x, num y, num z, num w) {
    _ptr.uniform4f(_unwrap(location), _unwrap(x), _unwrap(y), _unwrap(z), _unwrap(w));
    return;
  }

  void uniform4fv(WebGLUniformLocation location, Float32Array v) {
    _ptr.uniform4fv(_unwrap(location), _unwrap(v));
    return;
  }

  void uniform4i(WebGLUniformLocation location, int x, int y, int z, int w) {
    _ptr.uniform4i(_unwrap(location), _unwrap(x), _unwrap(y), _unwrap(z), _unwrap(w));
    return;
  }

  void uniform4iv(WebGLUniformLocation location, Int32Array v) {
    _ptr.uniform4iv(_unwrap(location), _unwrap(v));
    return;
  }

  void uniformMatrix2fv(WebGLUniformLocation location, bool transpose, Float32Array array) {
    _ptr.uniformMatrix2fv(_unwrap(location), _unwrap(transpose), _unwrap(array));
    return;
  }

  void uniformMatrix3fv(WebGLUniformLocation location, bool transpose, Float32Array array) {
    _ptr.uniformMatrix3fv(_unwrap(location), _unwrap(transpose), _unwrap(array));
    return;
  }

  void uniformMatrix4fv(WebGLUniformLocation location, bool transpose, Float32Array array) {
    _ptr.uniformMatrix4fv(_unwrap(location), _unwrap(transpose), _unwrap(array));
    return;
  }

  void useProgram(WebGLProgram program) {
    _ptr.useProgram(_unwrap(program));
    return;
  }

  void validateProgram(WebGLProgram program) {
    _ptr.validateProgram(_unwrap(program));
    return;
  }

  void vertexAttrib1f(int indx, num x) {
    _ptr.vertexAttrib1f(_unwrap(indx), _unwrap(x));
    return;
  }

  void vertexAttrib1fv(int indx, Float32Array values) {
    _ptr.vertexAttrib1fv(_unwrap(indx), _unwrap(values));
    return;
  }

  void vertexAttrib2f(int indx, num x, num y) {
    _ptr.vertexAttrib2f(_unwrap(indx), _unwrap(x), _unwrap(y));
    return;
  }

  void vertexAttrib2fv(int indx, Float32Array values) {
    _ptr.vertexAttrib2fv(_unwrap(indx), _unwrap(values));
    return;
  }

  void vertexAttrib3f(int indx, num x, num y, num z) {
    _ptr.vertexAttrib3f(_unwrap(indx), _unwrap(x), _unwrap(y), _unwrap(z));
    return;
  }

  void vertexAttrib3fv(int indx, Float32Array values) {
    _ptr.vertexAttrib3fv(_unwrap(indx), _unwrap(values));
    return;
  }

  void vertexAttrib4f(int indx, num x, num y, num z, num w) {
    _ptr.vertexAttrib4f(_unwrap(indx), _unwrap(x), _unwrap(y), _unwrap(z), _unwrap(w));
    return;
  }

  void vertexAttrib4fv(int indx, Float32Array values) {
    _ptr.vertexAttrib4fv(_unwrap(indx), _unwrap(values));
    return;
  }

  void vertexAttribPointer(int indx, int size, int type, bool normalized, int stride, int offset) {
    _ptr.vertexAttribPointer(_unwrap(indx), _unwrap(size), _unwrap(type), _unwrap(normalized), _unwrap(stride), _unwrap(offset));
    return;
  }

  void viewport(int x, int y, int width, int height) {
    _ptr.viewport(_unwrap(x), _unwrap(y), _unwrap(width), _unwrap(height));
    return;
  }
}

class _WebGLShaderImpl extends _DOMTypeBase implements WebGLShader {
  _WebGLShaderImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLShaderPrecisionFormatImpl extends _DOMTypeBase implements WebGLShaderPrecisionFormat {
  _WebGLShaderPrecisionFormatImpl._wrap(ptr) : super._wrap(ptr);

  int get precision() => _wrap(_ptr.precision);

  int get rangeMax() => _wrap(_ptr.rangeMax);

  int get rangeMin() => _wrap(_ptr.rangeMin);
}

class _WebGLTextureImpl extends _DOMTypeBase implements WebGLTexture {
  _WebGLTextureImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLUniformLocationImpl extends _DOMTypeBase implements WebGLUniformLocation {
  _WebGLUniformLocationImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebGLVertexArrayObjectOESImpl extends _DOMTypeBase implements WebGLVertexArrayObjectOES {
  _WebGLVertexArrayObjectOESImpl._wrap(ptr) : super._wrap(ptr);
}

class _WebKitCSSFilterValueImpl extends _CSSValueListImpl implements WebKitCSSFilterValue {
  _WebKitCSSFilterValueImpl._wrap(ptr) : super._wrap(ptr);

  int get operationType() => _wrap(_ptr.operationType);
}

class _WebKitCSSRegionRuleImpl extends _CSSRuleImpl implements WebKitCSSRegionRule {
  _WebKitCSSRegionRuleImpl._wrap(ptr) : super._wrap(ptr);

  CSSRuleList get cssRules() => _wrap(_ptr.cssRules);
}

class _WebKitMutationObserverImpl extends _DOMTypeBase implements WebKitMutationObserver {
  _WebKitMutationObserverImpl._wrap(ptr) : super._wrap(ptr);

  void disconnect() {
    _ptr.disconnect();
    return;
  }

  List<MutationRecord> takeRecords() {
    return _wrap(_ptr.takeRecords());
  }
}

class _WebKitNamedFlowImpl extends _DOMTypeBase implements WebKitNamedFlow {
  _WebKitNamedFlowImpl._wrap(ptr) : super._wrap(ptr);

  NodeList get contentNodes() => _wrap(_ptr.contentNodes);

  bool get overflow() => _wrap(_ptr.overflow);

  NodeList getRegionsByContentNode(Node contentNode) {
    return _wrap(_ptr.getRegionsByContentNode(_unwrap(contentNode)));
  }
}

class _WebSocketImpl extends _EventTargetImpl implements WebSocket {
  _WebSocketImpl._wrap(ptr) : super._wrap(ptr);

  _WebSocketEventsImpl get on() {
    if (_on == null) _on = new _WebSocketEventsImpl(this);
    return _on;
  }

  String get URL() => _wrap(_ptr.URL);

  String get binaryType() => _wrap(_ptr.binaryType);

  void set binaryType(String value) { _ptr.binaryType = _unwrap(value); }

  int get bufferedAmount() => _wrap(_ptr.bufferedAmount);

  String get extensions() => _wrap(_ptr.extensions);

  String get protocol() => _wrap(_ptr.protocol);

  int get readyState() => _wrap(_ptr.readyState);

  String get url() => _wrap(_ptr.url);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void close([int code = null, String reason = null]) {
    if (code === null) {
      if (reason === null) {
        _ptr.close();
        return;
      }
    } else {
      if (reason === null) {
        _ptr.close(_unwrap(code));
        return;
      } else {
        _ptr.close(_unwrap(code), _unwrap(reason));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }

  bool $dom_dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool send(String data) {
    return _wrap(_ptr.send(_unwrap(data)));
  }
}

class _WebSocketEventsImpl extends _EventsImpl implements WebSocketEvents {
  _WebSocketEventsImpl(_ptr) : super(_ptr);

  EventListenerList get close() => _get('close');

  EventListenerList get error() => _get('error');

  EventListenerList get message() => _get('message');

  EventListenerList get open() => _get('open');
}

class _WheelEventImpl extends _UIEventImpl implements WheelEvent {
  _WheelEventImpl._wrap(ptr) : super._wrap(ptr);

  bool get altKey() => _wrap(_ptr.altKey);

  int get clientX() => _wrap(_ptr.clientX);

  int get clientY() => _wrap(_ptr.clientY);

  bool get ctrlKey() => _wrap(_ptr.ctrlKey);

  bool get metaKey() => _wrap(_ptr.metaKey);

  int get offsetX() => _wrap(_ptr.offsetX);

  int get offsetY() => _wrap(_ptr.offsetY);

  int get screenX() => _wrap(_ptr.screenX);

  int get screenY() => _wrap(_ptr.screenY);

  bool get shiftKey() => _wrap(_ptr.shiftKey);

  bool get webkitDirectionInvertedFromDevice() => _wrap(_ptr.webkitDirectionInvertedFromDevice);

  int get wheelDelta() => _wrap(_ptr.wheelDelta);

  int get wheelDeltaX() => _wrap(_ptr.wheelDeltaX);

  int get wheelDeltaY() => _wrap(_ptr.wheelDeltaY);

  int get x() => _wrap(_ptr.x);

  int get y() => _wrap(_ptr.y);

  void initWebKitWheelEvent(int wheelDeltaX, int wheelDeltaY, Window view, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey) {
    _ptr.initWebKitWheelEvent(_unwrap(wheelDeltaX), _unwrap(wheelDeltaY), _unwrap(view), _unwrap(screenX), _unwrap(screenY), _unwrap(clientX), _unwrap(clientY), _unwrap(ctrlKey), _unwrap(altKey), _unwrap(shiftKey), _unwrap(metaKey));
    return;
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _WindowImpl extends _EventTargetImpl implements Window {

  _DocumentImpl get document() => _wrap(_ptr.document);

  void requestLayoutFrame(TimeoutHandler callback) {
    _addMeasurementFrameCallback(callback);
  }

  int requestAnimationFrame(RequestAnimationFrameCallback callback) =>
      webkitRequestAnimationFrame(callback);

  _WindowImpl._wrap(ptr) : super._wrap(ptr);

  _WindowEventsImpl get on() {
    if (_on == null) _on = new _WindowEventsImpl(this);
    return _on;
  }

  DOMApplicationCache get applicationCache() => _wrap(_ptr.applicationCache);

  Navigator get clientInformation() => _wrap(_ptr.clientInformation);

  bool get closed() => _wrap(_ptr.closed);

  Console get console() => _wrap(_ptr.console);

  Crypto get crypto() => _wrap(_ptr.crypto);

  String get defaultStatus() => _wrap(_ptr.defaultStatus);

  void set defaultStatus(String value) { _ptr.defaultStatus = _unwrap(value); }

  String get defaultstatus() => _wrap(_ptr.defaultstatus);

  void set defaultstatus(String value) { _ptr.defaultstatus = _unwrap(value); }

  num get devicePixelRatio() => _wrap(_ptr.devicePixelRatio);

  Event get event() => _wrap(_ptr.event);

  Window get frames() => _wrap(_ptr.frames);

  History get history() => _wrap(_ptr.history);

  int get innerHeight() => _wrap(_ptr.innerHeight);

  int get innerWidth() => _wrap(_ptr.innerWidth);

  int get length() => _wrap(_ptr.length);

  Storage get localStorage() => _wrap(_ptr.localStorage);

  Location get location() => _wrap(_ptr.location);

  void set location(Location value) { _ptr.location = _unwrap(value); }

  BarInfo get locationbar() => _wrap(_ptr.locationbar);

  BarInfo get menubar() => _wrap(_ptr.menubar);

  String get name() => _wrap(_ptr.name);

  void set name(String value) { _ptr.name = _unwrap(value); }

  Navigator get navigator() => _wrap(_ptr.navigator);

  bool get offscreenBuffering() => _wrap(_ptr.offscreenBuffering);

  Window get opener() => _wrap(_ptr.opener);

  int get outerHeight() => _wrap(_ptr.outerHeight);

  int get outerWidth() => _wrap(_ptr.outerWidth);

  int get pageXOffset() => _wrap(_ptr.pageXOffset);

  int get pageYOffset() => _wrap(_ptr.pageYOffset);

  Window get parent() => _wrap(_ptr.parent);

  Performance get performance() => _wrap(_ptr.performance);

  BarInfo get personalbar() => _wrap(_ptr.personalbar);

  Screen get screen() => _wrap(_ptr.screen);

  int get screenLeft() => _wrap(_ptr.screenLeft);

  int get screenTop() => _wrap(_ptr.screenTop);

  int get screenX() => _wrap(_ptr.screenX);

  int get screenY() => _wrap(_ptr.screenY);

  int get scrollX() => _wrap(_ptr.scrollX);

  int get scrollY() => _wrap(_ptr.scrollY);

  BarInfo get scrollbars() => _wrap(_ptr.scrollbars);

  Window get self() => _wrap(_ptr.self);

  Storage get sessionStorage() => _wrap(_ptr.sessionStorage);

  String get status() => _wrap(_ptr.status);

  void set status(String value) { _ptr.status = _unwrap(value); }

  BarInfo get statusbar() => _wrap(_ptr.statusbar);

  StyleMedia get styleMedia() => _wrap(_ptr.styleMedia);

  BarInfo get toolbar() => _wrap(_ptr.toolbar);

  IDBFactory get webkitIndexedDB() => _wrap(_ptr.webkitIndexedDB);

  NotificationCenter get webkitNotifications() => _wrap(_ptr.webkitNotifications);

  StorageInfo get webkitStorageInfo() => _wrap(_ptr.webkitStorageInfo);

  Window get window() => _wrap(_ptr.window);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void alert(String message) {
    _ptr.alert(_unwrap(message));
    return;
  }

  String atob(String string) {
    return _wrap(_ptr.atob(_unwrap(string)));
  }

  void blur() {
    _ptr.blur();
    return;
  }

  String btoa(String string) {
    return _wrap(_ptr.btoa(_unwrap(string)));
  }

  void captureEvents() {
    _ptr.captureEvents();
    return;
  }

  void clearInterval(int handle) {
    _ptr.clearInterval(_unwrap(handle));
    return;
  }

  void clearTimeout(int handle) {
    _ptr.clearTimeout(_unwrap(handle));
    return;
  }

  void close() {
    _ptr.close();
    return;
  }

  bool confirm(String message) {
    return _wrap(_ptr.confirm(_unwrap(message)));
  }

  bool $dom_dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  bool find(String string, bool caseSensitive, bool backwards, bool wrap, bool wholeWord, bool searchInFrames, bool showDialog) {
    return _wrap(_ptr.find(_unwrap(string), _unwrap(caseSensitive), _unwrap(backwards), _unwrap(wrap), _unwrap(wholeWord), _unwrap(searchInFrames), _unwrap(showDialog)));
  }

  void focus() {
    _ptr.focus();
    return;
  }

  CSSStyleDeclaration $dom_getComputedStyle(Element element, String pseudoElement) {
    return _wrap(_ptr.getComputedStyle(_unwrap(element), _unwrap(pseudoElement)));
  }

  CSSRuleList getMatchedCSSRules(Element element, String pseudoElement) {
    return _wrap(_ptr.getMatchedCSSRules(_unwrap(element), _unwrap(pseudoElement)));
  }

  DOMSelection getSelection() {
    return _wrap(_ptr.getSelection());
  }

  MediaQueryList matchMedia(String query) {
    return _wrap(_ptr.matchMedia(_unwrap(query)));
  }

  void moveBy(num x, num y) {
    _ptr.moveBy(_unwrap(x), _unwrap(y));
    return;
  }

  void moveTo(num x, num y) {
    _ptr.moveTo(_unwrap(x), _unwrap(y));
    return;
  }

  Window open(String url, String name, [String options = null]) {
    if (options === null) {
      return _wrap(_ptr.open(_unwrap(url), _unwrap(name)));
    } else {
      return _wrap(_ptr.open(_unwrap(url), _unwrap(name), _unwrap(options)));
    }
  }

  Database openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback = null]) {
    if (creationCallback === null) {
      return _wrap(_ptr.openDatabase(_unwrap(name), _unwrap(version), _unwrap(displayName), _unwrap(estimatedSize)));
    } else {
      return _wrap(_ptr.openDatabase(_unwrap(name), _unwrap(version), _unwrap(displayName), _unwrap(estimatedSize), _unwrap(creationCallback)));
    }
  }

  void postMessage(/*SerializedScriptValue*/ message, String targetOrigin, [List messagePorts = null]) {
    if (messagePorts === null) {
      _ptr.postMessage(_unwrap(message), _unwrap(targetOrigin));
      return;
    } else {
      _ptr.postMessage(_unwrap(message), _unwrap(targetOrigin), _unwrap(messagePorts));
      return;
    }
  }

  void print() {
    _ptr.print();
    return;
  }

  String prompt(String message, String defaultValue) {
    return _wrap(_ptr.prompt(_unwrap(message), _unwrap(defaultValue)));
  }

  void releaseEvents() {
    _ptr.releaseEvents();
    return;
  }

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void resizeBy(num x, num y) {
    _ptr.resizeBy(_unwrap(x), _unwrap(y));
    return;
  }

  void resizeTo(num width, num height) {
    _ptr.resizeTo(_unwrap(width), _unwrap(height));
    return;
  }

  void scroll(int x, int y) {
    _ptr.scroll(_unwrap(x), _unwrap(y));
    return;
  }

  void scrollBy(int x, int y) {
    _ptr.scrollBy(_unwrap(x), _unwrap(y));
    return;
  }

  void scrollTo(int x, int y) {
    _ptr.scrollTo(_unwrap(x), _unwrap(y));
    return;
  }

  int setInterval(TimeoutHandler handler, int timeout) {
    return _wrap(_ptr.setInterval(_unwrap(handler), _unwrap(timeout)));
  }

  int setTimeout(TimeoutHandler handler, int timeout) {
    return _wrap(_ptr.setTimeout(_unwrap(handler), _unwrap(timeout)));
  }

  Object showModalDialog(String url, [Object dialogArgs = null, String featureArgs = null]) {
    if (dialogArgs === null) {
      if (featureArgs === null) {
        return _wrap(_ptr.showModalDialog(_unwrap(url)));
      }
    } else {
      if (featureArgs === null) {
        return _wrap(_ptr.showModalDialog(_unwrap(url), _unwrap(dialogArgs)));
      } else {
        return _wrap(_ptr.showModalDialog(_unwrap(url), _unwrap(dialogArgs), _unwrap(featureArgs)));
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void stop() {
    _ptr.stop();
    return;
  }

  void webkitCancelAnimationFrame(int id) {
    _ptr.webkitCancelAnimationFrame(_unwrap(id));
    return;
  }

  void webkitCancelRequestAnimationFrame(int id) {
    _ptr.webkitCancelRequestAnimationFrame(_unwrap(id));
    return;
  }

  Point webkitConvertPointFromNodeToPage(Node node, Point p) {
    return _wrap(_ptr.webkitConvertPointFromNodeToPage(_unwrap(node), _unwrap(p)));
  }

  Point webkitConvertPointFromPageToNode(Node node, Point p) {
    return _wrap(_ptr.webkitConvertPointFromPageToNode(_unwrap(node), _unwrap(p)));
  }

  void webkitPostMessage(/*SerializedScriptValue*/ message, String targetOrigin, [List transferList = null]) {
    if (transferList === null) {
      _ptr.webkitPostMessage(_unwrap(message), _unwrap(targetOrigin));
      return;
    } else {
      _ptr.webkitPostMessage(_unwrap(message), _unwrap(targetOrigin), _unwrap(transferList));
      return;
    }
  }

  int webkitRequestAnimationFrame(RequestAnimationFrameCallback callback) {
    return _wrap(_ptr.webkitRequestAnimationFrame(_unwrap(callback)));
  }

  void webkitRequestFileSystem(int type, int size, FileSystemCallback successCallback, [ErrorCallback errorCallback = null]) {
    if (errorCallback === null) {
      _ptr.webkitRequestFileSystem(_unwrap(type), _unwrap(size), _unwrap(successCallback));
      return;
    } else {
      _ptr.webkitRequestFileSystem(_unwrap(type), _unwrap(size), _unwrap(successCallback), _unwrap(errorCallback));
      return;
    }
  }

  void webkitResolveLocalFileSystemURL(String url, [EntryCallback successCallback = null, ErrorCallback errorCallback = null]) {
    if (successCallback === null) {
      if (errorCallback === null) {
        _ptr.webkitResolveLocalFileSystemURL(_unwrap(url));
        return;
      }
    } else {
      if (errorCallback === null) {
        _ptr.webkitResolveLocalFileSystemURL(_unwrap(url), _unwrap(successCallback));
        return;
      } else {
        _ptr.webkitResolveLocalFileSystemURL(_unwrap(url), _unwrap(successCallback), _unwrap(errorCallback));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }

}

class _WindowEventsImpl extends _EventsImpl implements WindowEvents {
  _WindowEventsImpl(_ptr) : super(_ptr);

  EventListenerList get abort() => _get('abort');

  EventListenerList get animationEnd() => _get('webkitAnimationEnd');

  EventListenerList get animationIteration() => _get('webkitAnimationIteration');

  EventListenerList get animationStart() => _get('webkitAnimationStart');

  EventListenerList get beforeUnload() => _get('beforeunload');

  EventListenerList get blur() => _get('blur');

  EventListenerList get canPlay() => _get('canplay');

  EventListenerList get canPlayThrough() => _get('canplaythrough');

  EventListenerList get change() => _get('change');

  EventListenerList get click() => _get('click');

  EventListenerList get contentLoaded() => _get('DOMContentLoaded');

  EventListenerList get contextMenu() => _get('contextmenu');

  EventListenerList get deviceMotion() => _get('devicemotion');

  EventListenerList get deviceOrientation() => _get('deviceorientation');

  EventListenerList get doubleClick() => _get('dblclick');

  EventListenerList get drag() => _get('drag');

  EventListenerList get dragEnd() => _get('dragend');

  EventListenerList get dragEnter() => _get('dragenter');

  EventListenerList get dragLeave() => _get('dragleave');

  EventListenerList get dragOver() => _get('dragover');

  EventListenerList get dragStart() => _get('dragstart');

  EventListenerList get drop() => _get('drop');

  EventListenerList get durationChange() => _get('durationchange');

  EventListenerList get emptied() => _get('emptied');

  EventListenerList get ended() => _get('ended');

  EventListenerList get error() => _get('error');

  EventListenerList get focus() => _get('focus');

  EventListenerList get hashChange() => _get('hashchange');

  EventListenerList get input() => _get('input');

  EventListenerList get invalid() => _get('invalid');

  EventListenerList get keyDown() => _get('keydown');

  EventListenerList get keyPress() => _get('keypress');

  EventListenerList get keyUp() => _get('keyup');

  EventListenerList get load() => _get('load');

  EventListenerList get loadStart() => _get('loadstart');

  EventListenerList get loadedData() => _get('loadeddata');

  EventListenerList get loadedMetadata() => _get('loadedmetadata');

  EventListenerList get message() => _get('message');

  EventListenerList get mouseDown() => _get('mousedown');

  EventListenerList get mouseMove() => _get('mousemove');

  EventListenerList get mouseOut() => _get('mouseout');

  EventListenerList get mouseOver() => _get('mouseover');

  EventListenerList get mouseUp() => _get('mouseup');

  EventListenerList get mouseWheel() => _get('mousewheel');

  EventListenerList get offline() => _get('offline');

  EventListenerList get online() => _get('online');

  EventListenerList get pageHide() => _get('pagehide');

  EventListenerList get pageShow() => _get('pageshow');

  EventListenerList get pause() => _get('pause');

  EventListenerList get play() => _get('play');

  EventListenerList get playing() => _get('playing');

  EventListenerList get popState() => _get('popstate');

  EventListenerList get progress() => _get('progress');

  EventListenerList get rateChange() => _get('ratechange');

  EventListenerList get reset() => _get('reset');

  EventListenerList get resize() => _get('resize');

  EventListenerList get scroll() => _get('scroll');

  EventListenerList get search() => _get('search');

  EventListenerList get seeked() => _get('seeked');

  EventListenerList get seeking() => _get('seeking');

  EventListenerList get select() => _get('select');

  EventListenerList get stalled() => _get('stalled');

  EventListenerList get storage() => _get('storage');

  EventListenerList get submit() => _get('submit');

  EventListenerList get suspend() => _get('suspend');

  EventListenerList get timeUpdate() => _get('timeupdate');

  EventListenerList get touchCancel() => _get('touchcancel');

  EventListenerList get touchEnd() => _get('touchend');

  EventListenerList get touchMove() => _get('touchmove');

  EventListenerList get touchStart() => _get('touchstart');

  EventListenerList get transitionEnd() => _get('webkitTransitionEnd');

  EventListenerList get unload() => _get('unload');

  EventListenerList get volumeChange() => _get('volumechange');

  EventListenerList get waiting() => _get('waiting');
}

class _WorkerImpl extends _AbstractWorkerImpl implements Worker {
  _WorkerImpl._wrap(ptr) : super._wrap(ptr);

  _WorkerEventsImpl get on() {
    if (_on == null) _on = new _WorkerEventsImpl(this);
    return _on;
  }

  void postMessage(/*SerializedScriptValue*/ message, [List messagePorts = null]) {
    if (messagePorts === null) {
      _ptr.postMessage(_unwrap(message));
      return;
    } else {
      _ptr.postMessage(_unwrap(message), _unwrap(messagePorts));
      return;
    }
  }

  void terminate() {
    _ptr.terminate();
    return;
  }

  void webkitPostMessage(/*SerializedScriptValue*/ message, [List messagePorts = null]) {
    if (messagePorts === null) {
      _ptr.webkitPostMessage(_unwrap(message));
      return;
    } else {
      _ptr.webkitPostMessage(_unwrap(message), _unwrap(messagePorts));
      return;
    }
  }
}

class _WorkerEventsImpl extends _AbstractWorkerEventsImpl implements WorkerEvents {
  _WorkerEventsImpl(_ptr) : super(_ptr);

  EventListenerList get message() => _get('message');
}

class _WorkerContextImpl extends _EventTargetImpl implements WorkerContext {
  _WorkerContextImpl._wrap(ptr) : super._wrap(ptr);

  _WorkerContextEventsImpl get on() {
    if (_on == null) _on = new _WorkerContextEventsImpl(this);
    return _on;
  }

  WorkerLocation get location() => _wrap(_ptr.location);

  WorkerNavigator get navigator() => _wrap(_ptr.navigator);

  WorkerContext get self() => _wrap(_ptr.self);

  IDBFactory get webkitIndexedDB() => _wrap(_ptr.webkitIndexedDB);

  NotificationCenter get webkitNotifications() => _wrap(_ptr.webkitNotifications);

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void clearInterval(int handle) {
    _ptr.clearInterval(_unwrap(handle));
    return;
  }

  void clearTimeout(int handle) {
    _ptr.clearTimeout(_unwrap(handle));
    return;
  }

  void close() {
    _ptr.close();
    return;
  }

  bool $dom_dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void importScripts() {
    _ptr.importScripts();
    return;
  }

  Database openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback = null]) {
    if (creationCallback === null) {
      return _wrap(_ptr.openDatabase(_unwrap(name), _unwrap(version), _unwrap(displayName), _unwrap(estimatedSize)));
    } else {
      return _wrap(_ptr.openDatabase(_unwrap(name), _unwrap(version), _unwrap(displayName), _unwrap(estimatedSize), _unwrap(creationCallback)));
    }
  }

  DatabaseSync openDatabaseSync(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback = null]) {
    if (creationCallback === null) {
      return _wrap(_ptr.openDatabaseSync(_unwrap(name), _unwrap(version), _unwrap(displayName), _unwrap(estimatedSize)));
    } else {
      return _wrap(_ptr.openDatabaseSync(_unwrap(name), _unwrap(version), _unwrap(displayName), _unwrap(estimatedSize), _unwrap(creationCallback)));
    }
  }

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  int setInterval(TimeoutHandler handler, int timeout) {
    return _wrap(_ptr.setInterval(_unwrap(handler), _unwrap(timeout)));
  }

  int setTimeout(TimeoutHandler handler, int timeout) {
    return _wrap(_ptr.setTimeout(_unwrap(handler), _unwrap(timeout)));
  }

  void webkitRequestFileSystem(int type, int size, [FileSystemCallback successCallback = null, ErrorCallback errorCallback = null]) {
    if (successCallback === null) {
      if (errorCallback === null) {
        _ptr.webkitRequestFileSystem(_unwrap(type), _unwrap(size));
        return;
      }
    } else {
      if (errorCallback === null) {
        _ptr.webkitRequestFileSystem(_unwrap(type), _unwrap(size), _unwrap(successCallback));
        return;
      } else {
        _ptr.webkitRequestFileSystem(_unwrap(type), _unwrap(size), _unwrap(successCallback), _unwrap(errorCallback));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }

  DOMFileSystemSync webkitRequestFileSystemSync(int type, int size) {
    return _wrap(_ptr.webkitRequestFileSystemSync(_unwrap(type), _unwrap(size)));
  }

  EntrySync webkitResolveLocalFileSystemSyncURL(String url) {
    return _wrap(_ptr.webkitResolveLocalFileSystemSyncURL(_unwrap(url)));
  }

  void webkitResolveLocalFileSystemURL(String url, [EntryCallback successCallback = null, ErrorCallback errorCallback = null]) {
    if (successCallback === null) {
      if (errorCallback === null) {
        _ptr.webkitResolveLocalFileSystemURL(_unwrap(url));
        return;
      }
    } else {
      if (errorCallback === null) {
        _ptr.webkitResolveLocalFileSystemURL(_unwrap(url), _unwrap(successCallback));
        return;
      } else {
        _ptr.webkitResolveLocalFileSystemURL(_unwrap(url), _unwrap(successCallback), _unwrap(errorCallback));
        return;
      }
    }
    throw "Incorrect number or type of arguments";
  }
}

class _WorkerContextEventsImpl extends _EventsImpl implements WorkerContextEvents {
  _WorkerContextEventsImpl(_ptr) : super(_ptr);

  EventListenerList get error() => _get('error');
}

class _WorkerLocationImpl extends _DOMTypeBase implements WorkerLocation {
  _WorkerLocationImpl._wrap(ptr) : super._wrap(ptr);

  String get hash() => _wrap(_ptr.hash);

  String get host() => _wrap(_ptr.host);

  String get hostname() => _wrap(_ptr.hostname);

  String get href() => _wrap(_ptr.href);

  String get pathname() => _wrap(_ptr.pathname);

  String get port() => _wrap(_ptr.port);

  String get protocol() => _wrap(_ptr.protocol);

  String get search() => _wrap(_ptr.search);

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _WorkerNavigatorImpl extends _DOMTypeBase implements WorkerNavigator {
  _WorkerNavigatorImpl._wrap(ptr) : super._wrap(ptr);

  String get appName() => _wrap(_ptr.appName);

  String get appVersion() => _wrap(_ptr.appVersion);

  bool get onLine() => _wrap(_ptr.onLine);

  String get platform() => _wrap(_ptr.platform);

  String get userAgent() => _wrap(_ptr.userAgent);
}

class _XMLHttpRequestImpl extends _EventTargetImpl implements XMLHttpRequest {
  _XMLHttpRequestImpl._wrap(ptr) : super._wrap(ptr);

  _XMLHttpRequestEventsImpl get on() {
    if (_on == null) _on = new _XMLHttpRequestEventsImpl(this);
    return _on;
  }

  bool get asBlob() => _wrap(_ptr.asBlob);

  void set asBlob(bool value) { _ptr.asBlob = _unwrap(value); }

  int get readyState() => _wrap(_ptr.readyState);

  Object get response() => _wrap(_ptr.response);

  Blob get responseBlob() => _wrap(_ptr.responseBlob);

  String get responseText() => _wrap(_ptr.responseText);

  String get responseType() => _wrap(_ptr.responseType);

  void set responseType(String value) { _ptr.responseType = _unwrap(value); }

  Document get responseXML() => _wrap(_ptr.responseXML);

  int get status() => _wrap(_ptr.status);

  String get statusText() => _wrap(_ptr.statusText);

  XMLHttpRequestUpload get upload() => _wrap(_ptr.upload);

  bool get withCredentials() => _wrap(_ptr.withCredentials);

  void set withCredentials(bool value) { _ptr.withCredentials = _unwrap(value); }

  void abort() {
    _ptr.abort();
    return;
  }

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool $dom_dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  String getAllResponseHeaders() {
    return _wrap(_ptr.getAllResponseHeaders());
  }

  String getResponseHeader(String header) {
    return _wrap(_ptr.getResponseHeader(_unwrap(header)));
  }

  void open(String method, String url, [bool async = null, String user = null, String password = null]) {
    if (async === null) {
      if (user === null) {
        if (password === null) {
          _ptr.open(_unwrap(method), _unwrap(url));
          return;
        }
      }
    } else {
      if (user === null) {
        if (password === null) {
          _ptr.open(_unwrap(method), _unwrap(url), _unwrap(async));
          return;
        }
      } else {
        if (password === null) {
          _ptr.open(_unwrap(method), _unwrap(url), _unwrap(async), _unwrap(user));
          return;
        } else {
          _ptr.open(_unwrap(method), _unwrap(url), _unwrap(async), _unwrap(user), _unwrap(password));
          return;
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void overrideMimeType(String override) {
    _ptr.overrideMimeType(_unwrap(override));
    return;
  }

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  void send([data = null]) {
    if (data === null) {
      _ptr.send();
      return;
    } else {
      if (data is ArrayBuffer) {
        _ptr.send(_unwrap(data));
        return;
      } else {
        if (data is Blob) {
          _ptr.send(_unwrap(data));
          return;
        } else {
          if (data is Document) {
            _ptr.send(_unwrap(data));
            return;
          } else {
            if (data is String) {
              _ptr.send(_unwrap(data));
              return;
            } else {
              if (data is DOMFormData) {
                _ptr.send(_unwrap(data));
                return;
              }
            }
          }
        }
      }
    }
    throw "Incorrect number or type of arguments";
  }

  void setRequestHeader(String header, String value) {
    _ptr.setRequestHeader(_unwrap(header), _unwrap(value));
    return;
  }
}

class _XMLHttpRequestEventsImpl extends _EventsImpl implements XMLHttpRequestEvents {
  _XMLHttpRequestEventsImpl(_ptr) : super(_ptr);

  EventListenerList get abort() => _get('abort');

  EventListenerList get error() => _get('error');

  EventListenerList get load() => _get('load');

  EventListenerList get loadEnd() => _get('loadend');

  EventListenerList get loadStart() => _get('loadstart');

  EventListenerList get progress() => _get('progress');

  EventListenerList get readyStateChange() => _get('readystatechange');
}

class _XMLHttpRequestExceptionImpl extends _DOMTypeBase implements XMLHttpRequestException {
  _XMLHttpRequestExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _XMLHttpRequestProgressEventImpl extends _ProgressEventImpl implements XMLHttpRequestProgressEvent {
  _XMLHttpRequestProgressEventImpl._wrap(ptr) : super._wrap(ptr);

  int get position() => _wrap(_ptr.position);

  int get totalSize() => _wrap(_ptr.totalSize);
}

class _XMLHttpRequestUploadImpl extends _EventTargetImpl implements XMLHttpRequestUpload {
  _XMLHttpRequestUploadImpl._wrap(ptr) : super._wrap(ptr);

  _XMLHttpRequestUploadEventsImpl get on() {
    if (_on == null) _on = new _XMLHttpRequestUploadEventsImpl(this);
    return _on;
  }

  void $dom_addEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.addEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }

  bool $dom_dispatchEvent(Event evt) {
    return _wrap(_ptr.dispatchEvent(_unwrap(evt)));
  }

  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture = null]) {
    if (useCapture === null) {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener));
      return;
    } else {
      _ptr.removeEventListener(_unwrap(type), _unwrap(listener), _unwrap(useCapture));
      return;
    }
  }
}

class _XMLHttpRequestUploadEventsImpl extends _EventsImpl implements XMLHttpRequestUploadEvents {
  _XMLHttpRequestUploadEventsImpl(_ptr) : super(_ptr);

  EventListenerList get abort() => _get('abort');

  EventListenerList get error() => _get('error');

  EventListenerList get load() => _get('load');

  EventListenerList get loadEnd() => _get('loadend');

  EventListenerList get loadStart() => _get('loadstart');

  EventListenerList get progress() => _get('progress');
}

class _XMLSerializerImpl extends _DOMTypeBase implements XMLSerializer {
  _XMLSerializerImpl._wrap(ptr) : super._wrap(ptr);

  String serializeToString(Node node) {
    return _wrap(_ptr.serializeToString(_unwrap(node)));
  }
}

class _XPathEvaluatorImpl extends _DOMTypeBase implements XPathEvaluator {
  _XPathEvaluatorImpl._wrap(ptr) : super._wrap(ptr);

  XPathExpression createExpression(String expression, XPathNSResolver resolver) {
    return _wrap(_ptr.createExpression(_unwrap(expression), _unwrap(resolver)));
  }

  XPathNSResolver createNSResolver(Node nodeResolver) {
    return _wrap(_ptr.createNSResolver(_unwrap(nodeResolver)));
  }

  XPathResult evaluate(String expression, Node contextNode, XPathNSResolver resolver, int type, XPathResult inResult) {
    return _wrap(_ptr.evaluate(_unwrap(expression), _unwrap(contextNode), _unwrap(resolver), _unwrap(type), _unwrap(inResult)));
  }
}

class _XPathExceptionImpl extends _DOMTypeBase implements XPathException {
  _XPathExceptionImpl._wrap(ptr) : super._wrap(ptr);

  int get code() => _wrap(_ptr.code);

  String get message() => _wrap(_ptr.message);

  String get name() => _wrap(_ptr.name);

  String toString() {
    return _wrap(_ptr.toString());
  }
}

class _XPathExpressionImpl extends _DOMTypeBase implements XPathExpression {
  _XPathExpressionImpl._wrap(ptr) : super._wrap(ptr);

  XPathResult evaluate(Node contextNode, int type, XPathResult inResult) {
    return _wrap(_ptr.evaluate(_unwrap(contextNode), _unwrap(type), _unwrap(inResult)));
  }
}

class _XPathNSResolverImpl extends _DOMTypeBase implements XPathNSResolver {
  _XPathNSResolverImpl._wrap(ptr) : super._wrap(ptr);

  String lookupNamespaceURI(String prefix) {
    return _wrap(_ptr.lookupNamespaceURI(_unwrap(prefix)));
  }
}

class _XPathResultImpl extends _DOMTypeBase implements XPathResult {
  _XPathResultImpl._wrap(ptr) : super._wrap(ptr);

  bool get booleanValue() => _wrap(_ptr.booleanValue);

  bool get invalidIteratorState() => _wrap(_ptr.invalidIteratorState);

  num get numberValue() => _wrap(_ptr.numberValue);

  int get resultType() => _wrap(_ptr.resultType);

  Node get singleNodeValue() => _wrap(_ptr.singleNodeValue);

  int get snapshotLength() => _wrap(_ptr.snapshotLength);

  String get stringValue() => _wrap(_ptr.stringValue);

  Node iterateNext() {
    return _wrap(_ptr.iterateNext());
  }

  Node snapshotItem(int index) {
    return _wrap(_ptr.snapshotItem(_unwrap(index)));
  }
}

class _XSLTProcessorImpl extends _DOMTypeBase implements XSLTProcessor {
  _XSLTProcessorImpl._wrap(ptr) : super._wrap(ptr);

  void clearParameters() {
    _ptr.clearParameters();
    return;
  }

  String getParameter(String namespaceURI, String localName) {
    return _wrap(_ptr.getParameter(_unwrap(namespaceURI), _unwrap(localName)));
  }

  void importStylesheet(Node stylesheet) {
    _ptr.importStylesheet(_unwrap(stylesheet));
    return;
  }

  void removeParameter(String namespaceURI, String localName) {
    _ptr.removeParameter(_unwrap(namespaceURI), _unwrap(localName));
    return;
  }

  void reset() {
    _ptr.reset();
    return;
  }

  void setParameter(String namespaceURI, String localName, String value) {
    _ptr.setParameter(_unwrap(namespaceURI), _unwrap(localName), _unwrap(value));
    return;
  }

  Document transformToDocument(Node source) {
    return _wrap(_ptr.transformToDocument(_unwrap(source)));
  }

  DocumentFragment transformToFragment(Node source, Document docVal) {
    return _wrap(_ptr.transformToFragment(_unwrap(source), _unwrap(docVal)));
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _AudioElementFactoryProvider {
  factory AudioElement([String src = null]) =>
      _wrap(new dom.HTMLAudioElement(_unwrap(src)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _CSSMatrixFactoryProvider {
  factory CSSMatrix([String cssValue = '']) =>
      _wrap(new dom.WebKitCSSMatrix(cssValue));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _DOMParserFactoryProvider {
  factory DOMParser() =>
      _wrap(new dom.DOMParser());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _DOMURLFactoryProvider {
  factory DOMURL() =>
      _wrap(new dom.DOMURL());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _DeprecatedPeerConnectionFactoryProvider {
  factory DeprecatedPeerConnection(String serverConfiguration, SignalingCallback signalingCallback) =>
      _wrap(new dom.DeprecatedPeerConnection(_unwrap(serverConfiguration), _unwrap(signalingCallback)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _EventSourceFactoryProvider {
  factory EventSource(String scriptUrl) =>
      _wrap(new dom.EventSource(_unwrap(scriptUrl)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _FileReaderFactoryProvider {
  factory FileReader() =>
      _wrap(new dom.FileReader());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _FileReaderSyncFactoryProvider {
  factory FileReaderSync() =>
      _wrap(new dom.FileReaderSync());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _IceCandidateFactoryProvider {
  factory IceCandidate(String label, String candidateLine) =>
      _wrap(new dom.IceCandidate(_unwrap(label), _unwrap(candidateLine)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _MediaControllerFactoryProvider {
  factory MediaController() =>
      _wrap(new dom.MediaController());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _MediaStreamFactoryProvider {
  factory MediaStream(MediaStreamTrackList audioTracks, MediaStreamTrackList videoTracks) =>
      _wrap(new dom.MediaStream(_unwrap(audioTracks), _unwrap(videoTracks)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _MessageChannelFactoryProvider {
  factory MessageChannel() =>
      _wrap(new dom.MessageChannel());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _NotificationFactoryProvider {
  factory Notification(String title, [Map options = null]) =>
      _wrap(new dom.Notification(_unwrap(title), _unwrap(options)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _OptionElementFactoryProvider {
  factory OptionElement([String data = null, String value = null, bool defaultSelected = null, bool selected = null]) =>
      _wrap(new dom.HTMLOptionElement(_unwrap(data), _unwrap(value), _unwrap(defaultSelected), _unwrap(selected)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _PeerConnection00FactoryProvider {
  factory PeerConnection00(String serverConfiguration, IceCallback iceCallback) =>
      _wrap(new dom.PeerConnection00(_unwrap(serverConfiguration), _unwrap(iceCallback)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _SessionDescriptionFactoryProvider {
  factory SessionDescription(String sdp) =>
      _wrap(new dom.SessionDescription(_unwrap(sdp)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _ShadowRootFactoryProvider {
  factory ShadowRoot(Element host) =>
      _wrap(new dom.ShadowRoot(_unwrap(host)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _SharedWorkerFactoryProvider {
  factory SharedWorker(String scriptURL, [String name = null]) =>
      _wrap(new dom.SharedWorker(_unwrap(scriptURL), _unwrap(name)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _SpeechGrammarFactoryProvider {
  factory SpeechGrammar() =>
      _wrap(new dom.SpeechGrammar());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _SpeechGrammarListFactoryProvider {
  factory SpeechGrammarList() =>
      _wrap(new dom.SpeechGrammarList());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _SpeechRecognitionFactoryProvider {
  factory SpeechRecognition() =>
      _wrap(new dom.SpeechRecognition());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _TextTrackCueFactoryProvider {
  factory TextTrackCue(String id, num startTime, num endTime, String text, [String settings = null, bool pauseOnExit = null]) =>
      _wrap(new dom.TextTrackCue(_unwrap(id), _unwrap(startTime), _unwrap(endTime), _unwrap(text), _unwrap(settings), _unwrap(pauseOnExit)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _WorkerFactoryProvider {
  factory Worker(String scriptUrl) =>
      _wrap(new dom.Worker(_unwrap(scriptUrl)));
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _XMLHttpRequestFactoryProvider {
  factory XMLHttpRequest() => _wrap(new dom.XMLHttpRequest());

  factory XMLHttpRequest.get(String url,
                                     onSuccess(XMLHttpRequest request)) =>
      _XMLHttpRequestUtils.get(url, onSuccess);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _XMLSerializerFactoryProvider {
  factory XMLSerializer() =>
      _wrap(new dom.XMLSerializer());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _XPathEvaluatorFactoryProvider {
  factory XPathEvaluator() =>
      _wrap(new dom.XPathEvaluator());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _XSLTProcessorFactoryProvider {
  factory XSLTProcessor() =>
      _wrap(new dom.XSLTProcessor());
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AbstractWorker
interface AbstractWorker extends EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  AbstractWorkerEvents get on();

  /** @domName AbstractWorker.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName AbstractWorker.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName AbstractWorker.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

interface AbstractWorkerEvents extends Events {

  EventListenerList get error();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLAnchorElement
interface AnchorElement extends Element {

  /** @domName HTMLAnchorElement.charset */
  String charset;

  /** @domName HTMLAnchorElement.coords */
  String coords;

  /** @domName HTMLAnchorElement.download */
  String download;

  /** @domName HTMLAnchorElement.hash */
  String hash;

  /** @domName HTMLAnchorElement.host */
  String host;

  /** @domName HTMLAnchorElement.hostname */
  String hostname;

  /** @domName HTMLAnchorElement.href */
  String href;

  /** @domName HTMLAnchorElement.hreflang */
  String hreflang;

  /** @domName HTMLAnchorElement.name */
  String name;

  /** @domName HTMLAnchorElement.origin */
  final String origin;

  /** @domName HTMLAnchorElement.pathname */
  String pathname;

  /** @domName HTMLAnchorElement.ping */
  String ping;

  /** @domName HTMLAnchorElement.port */
  String port;

  /** @domName HTMLAnchorElement.protocol */
  String protocol;

  /** @domName HTMLAnchorElement.rel */
  String rel;

  /** @domName HTMLAnchorElement.rev */
  String rev;

  /** @domName HTMLAnchorElement.search */
  String search;

  /** @domName HTMLAnchorElement.shape */
  String shape;

  /** @domName HTMLAnchorElement.target */
  String target;

  /** @domName HTMLAnchorElement.type */
  String type;

  /** @domName HTMLAnchorElement.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitAnimation
interface Animation {

  static final int DIRECTION_ALTERNATE = 1;

  static final int DIRECTION_NORMAL = 0;

  static final int FILL_BACKWARDS = 1;

  static final int FILL_BOTH = 3;

  static final int FILL_FORWARDS = 2;

  static final int FILL_NONE = 0;

  /** @domName WebKitAnimation.delay */
  final num delay;

  /** @domName WebKitAnimation.direction */
  final int direction;

  /** @domName WebKitAnimation.duration */
  final num duration;

  /** @domName WebKitAnimation.elapsedTime */
  num elapsedTime;

  /** @domName WebKitAnimation.ended */
  final bool ended;

  /** @domName WebKitAnimation.fillMode */
  final int fillMode;

  /** @domName WebKitAnimation.iterationCount */
  final int iterationCount;

  /** @domName WebKitAnimation.name */
  final String name;

  /** @domName WebKitAnimation.paused */
  final bool paused;

  /** @domName WebKitAnimation.pause */
  void pause();

  /** @domName WebKitAnimation.play */
  void play();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitAnimationEvent
interface AnimationEvent extends Event {

  /** @domName WebKitAnimationEvent.animationName */
  final String animationName;

  /** @domName WebKitAnimationEvent.elapsedTime */
  final num elapsedTime;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitAnimationList
interface AnimationList {

  /** @domName WebKitAnimationList.length */
  final int length;

  /** @domName WebKitAnimationList.item */
  Animation item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLAppletElement
interface AppletElement extends Element {

  /** @domName HTMLAppletElement.align */
  String align;

  /** @domName HTMLAppletElement.alt */
  String alt;

  /** @domName HTMLAppletElement.archive */
  String archive;

  /** @domName HTMLAppletElement.code */
  String code;

  /** @domName HTMLAppletElement.codeBase */
  String codeBase;

  /** @domName HTMLAppletElement.height */
  String height;

  /** @domName HTMLAppletElement.hspace */
  String hspace;

  /** @domName HTMLAppletElement.name */
  String name;

  /** @domName HTMLAppletElement.object */
  String object;

  /** @domName HTMLAppletElement.vspace */
  String vspace;

  /** @domName HTMLAppletElement.width */
  String width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLAreaElement
interface AreaElement extends Element {

  /** @domName HTMLAreaElement.alt */
  String alt;

  /** @domName HTMLAreaElement.coords */
  String coords;

  /** @domName HTMLAreaElement.hash */
  final String hash;

  /** @domName HTMLAreaElement.host */
  final String host;

  /** @domName HTMLAreaElement.hostname */
  final String hostname;

  /** @domName HTMLAreaElement.href */
  String href;

  /** @domName HTMLAreaElement.noHref */
  bool noHref;

  /** @domName HTMLAreaElement.pathname */
  final String pathname;

  /** @domName HTMLAreaElement.ping */
  String ping;

  /** @domName HTMLAreaElement.port */
  final String port;

  /** @domName HTMLAreaElement.protocol */
  final String protocol;

  /** @domName HTMLAreaElement.search */
  final String search;

  /** @domName HTMLAreaElement.shape */
  String shape;

  /** @domName HTMLAreaElement.target */
  String target;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ArrayBuffer
interface ArrayBuffer {

  /** @domName ArrayBuffer.byteLength */
  final int byteLength;

  /** @domName ArrayBuffer.slice */
  ArrayBuffer slice(int begin, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ArrayBufferView
interface ArrayBufferView {

  /** @domName ArrayBufferView.buffer */
  final ArrayBuffer buffer;

  /** @domName ArrayBufferView.byteLength */
  final int byteLength;

  /** @domName ArrayBufferView.byteOffset */
  final int byteOffset;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Attr
interface Attr extends Node {

  /** @domName Attr.isId */
  final bool isId;

  /** @domName Attr.name */
  final String name;

  /** @domName Attr.ownerElement */
  final Element ownerElement;

  /** @domName Attr.specified */
  final bool specified;

  /** @domName Attr.value */
  String value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioBuffer
interface AudioBuffer {

  /** @domName AudioBuffer.duration */
  final num duration;

  /** @domName AudioBuffer.gain */
  num gain;

  /** @domName AudioBuffer.length */
  final int length;

  /** @domName AudioBuffer.numberOfChannels */
  final int numberOfChannels;

  /** @domName AudioBuffer.sampleRate */
  final num sampleRate;

  /** @domName AudioBuffer.getChannelData */
  Float32Array getChannelData(int channelIndex);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool AudioBufferCallback(AudioBuffer audioBuffer);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioBufferSourceNode
interface AudioBufferSourceNode extends AudioSourceNode {

  static final int FINISHED_STATE = 3;

  static final int PLAYING_STATE = 2;

  static final int SCHEDULED_STATE = 1;

  static final int UNSCHEDULED_STATE = 0;

  /** @domName AudioBufferSourceNode.buffer */
  AudioBuffer buffer;

  /** @domName AudioBufferSourceNode.gain */
  final AudioGain gain;

  /** @domName AudioBufferSourceNode.loop */
  bool loop;

  /** @domName AudioBufferSourceNode.looping */
  bool looping;

  /** @domName AudioBufferSourceNode.playbackRate */
  final AudioParam playbackRate;

  /** @domName AudioBufferSourceNode.playbackState */
  final int playbackState;

  /** @domName AudioBufferSourceNode.noteGrainOn */
  void noteGrainOn(num when, num grainOffset, num grainDuration);

  /** @domName AudioBufferSourceNode.noteOff */
  void noteOff(num when);

  /** @domName AudioBufferSourceNode.noteOn */
  void noteOn(num when);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioChannelMerger
interface AudioChannelMerger extends AudioNode {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioChannelSplitter
interface AudioChannelSplitter extends AudioNode {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioContext
interface AudioContext extends EventTarget default _AudioContextFactoryProvider {
  AudioContext();

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  AudioContextEvents get on();

  /** @domName AudioContext.activeSourceCount */
  final int activeSourceCount;

  /** @domName AudioContext.currentTime */
  final num currentTime;

  /** @domName AudioContext.destination */
  final AudioDestinationNode destination;

  /** @domName AudioContext.listener */
  final AudioListener listener;

  /** @domName AudioContext.sampleRate */
  final num sampleRate;

  /** @domName AudioContext.createAnalyser */
  RealtimeAnalyserNode createAnalyser();

  /** @domName AudioContext.createBiquadFilter */
  BiquadFilterNode createBiquadFilter();

  /** @domName AudioContext.createBuffer */
  AudioBuffer createBuffer(buffer_OR_numberOfChannels, mixToMono_OR_numberOfFrames, [num sampleRate]);

  /** @domName AudioContext.createBufferSource */
  AudioBufferSourceNode createBufferSource();

  /** @domName AudioContext.createChannelMerger */
  AudioChannelMerger createChannelMerger([int numberOfInputs]);

  /** @domName AudioContext.createChannelSplitter */
  AudioChannelSplitter createChannelSplitter([int numberOfOutputs]);

  /** @domName AudioContext.createConvolver */
  ConvolverNode createConvolver();

  /** @domName AudioContext.createDelayNode */
  DelayNode createDelayNode([num maxDelayTime]);

  /** @domName AudioContext.createDynamicsCompressor */
  DynamicsCompressorNode createDynamicsCompressor();

  /** @domName AudioContext.createGainNode */
  AudioGainNode createGainNode();

  /** @domName AudioContext.createJavaScriptNode */
  JavaScriptAudioNode createJavaScriptNode(int bufferSize, [int numberOfInputChannels, int numberOfOutputChannels]);

  /** @domName AudioContext.createMediaElementSource */
  MediaElementAudioSourceNode createMediaElementSource(MediaElement mediaElement);

  /** @domName AudioContext.createOscillator */
  Oscillator createOscillator();

  /** @domName AudioContext.createPanner */
  AudioPannerNode createPanner();

  /** @domName AudioContext.createWaveShaper */
  WaveShaperNode createWaveShaper();

  /** @domName AudioContext.createWaveTable */
  WaveTable createWaveTable(Float32Array real, Float32Array imag);

  /** @domName AudioContext.decodeAudioData */
  void decodeAudioData(ArrayBuffer audioData, AudioBufferCallback successCallback, [AudioBufferCallback errorCallback]);

  /** @domName AudioContext.startRendering */
  void startRendering();
}

interface AudioContextEvents extends Events {

  EventListenerList get complete();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioDestinationNode
interface AudioDestinationNode extends AudioNode {

  /** @domName AudioDestinationNode.numberOfChannels */
  final int numberOfChannels;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLAudioElement
interface AudioElement extends MediaElement default _AudioElementFactoryProvider {

  AudioElement([String src]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioGain
interface AudioGain extends AudioParam {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioGainNode
interface AudioGainNode extends AudioNode {

  /** @domName AudioGainNode.gain */
  final AudioGain gain;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioListener
interface AudioListener {

  /** @domName AudioListener.dopplerFactor */
  num dopplerFactor;

  /** @domName AudioListener.speedOfSound */
  num speedOfSound;

  /** @domName AudioListener.setOrientation */
  void setOrientation(num x, num y, num z, num xUp, num yUp, num zUp);

  /** @domName AudioListener.setPosition */
  void setPosition(num x, num y, num z);

  /** @domName AudioListener.setVelocity */
  void setVelocity(num x, num y, num z);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioNode
interface AudioNode {

  /** @domName AudioNode.context */
  final AudioContext context;

  /** @domName AudioNode.numberOfInputs */
  final int numberOfInputs;

  /** @domName AudioNode.numberOfOutputs */
  final int numberOfOutputs;

  /** @domName AudioNode.connect */
  void connect(destination, int output, [int input]);

  /** @domName AudioNode.disconnect */
  void disconnect(int output);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioPannerNode
interface AudioPannerNode extends AudioNode {

  static final int EQUALPOWER = 0;

  static final int EXPONENTIAL_DISTANCE = 2;

  static final int HRTF = 1;

  static final int INVERSE_DISTANCE = 1;

  static final int LINEAR_DISTANCE = 0;

  static final int SOUNDFIELD = 2;

  /** @domName AudioPannerNode.coneGain */
  final AudioGain coneGain;

  /** @domName AudioPannerNode.coneInnerAngle */
  num coneInnerAngle;

  /** @domName AudioPannerNode.coneOuterAngle */
  num coneOuterAngle;

  /** @domName AudioPannerNode.coneOuterGain */
  num coneOuterGain;

  /** @domName AudioPannerNode.distanceGain */
  final AudioGain distanceGain;

  /** @domName AudioPannerNode.distanceModel */
  int distanceModel;

  /** @domName AudioPannerNode.maxDistance */
  num maxDistance;

  /** @domName AudioPannerNode.panningModel */
  int panningModel;

  /** @domName AudioPannerNode.refDistance */
  num refDistance;

  /** @domName AudioPannerNode.rolloffFactor */
  num rolloffFactor;

  /** @domName AudioPannerNode.setOrientation */
  void setOrientation(num x, num y, num z);

  /** @domName AudioPannerNode.setPosition */
  void setPosition(num x, num y, num z);

  /** @domName AudioPannerNode.setVelocity */
  void setVelocity(num x, num y, num z);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioParam
interface AudioParam {

  /** @domName AudioParam.defaultValue */
  final num defaultValue;

  /** @domName AudioParam.maxValue */
  final num maxValue;

  /** @domName AudioParam.minValue */
  final num minValue;

  /** @domName AudioParam.name */
  final String name;

  /** @domName AudioParam.units */
  final int units;

  /** @domName AudioParam.value */
  num value;

  /** @domName AudioParam.cancelScheduledValues */
  void cancelScheduledValues(num startTime);

  /** @domName AudioParam.exponentialRampToValueAtTime */
  void exponentialRampToValueAtTime(num value, num time);

  /** @domName AudioParam.linearRampToValueAtTime */
  void linearRampToValueAtTime(num value, num time);

  /** @domName AudioParam.setTargetValueAtTime */
  void setTargetValueAtTime(num targetValue, num time, num timeConstant);

  /** @domName AudioParam.setValueAtTime */
  void setValueAtTime(num value, num time);

  /** @domName AudioParam.setValueCurveAtTime */
  void setValueCurveAtTime(Float32Array values, num time, num duration);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioProcessingEvent
interface AudioProcessingEvent extends Event {

  /** @domName AudioProcessingEvent.inputBuffer */
  final AudioBuffer inputBuffer;

  /** @domName AudioProcessingEvent.outputBuffer */
  final AudioBuffer outputBuffer;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName AudioSourceNode
interface AudioSourceNode extends AudioNode {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLBRElement
interface BRElement extends Element {

  /** @domName HTMLBRElement.clear */
  String clear;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName BarInfo
interface BarInfo {

  /** @domName BarInfo.visible */
  final bool visible;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLBaseElement
interface BaseElement extends Element {

  /** @domName HTMLBaseElement.href */
  String href;

  /** @domName HTMLBaseElement.target */
  String target;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLBaseFontElement
interface BaseFontElement extends Element {

  /** @domName HTMLBaseFontElement.color */
  String color;

  /** @domName HTMLBaseFontElement.face */
  String face;

  /** @domName HTMLBaseFontElement.size */
  int size;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName BatteryManager
interface BatteryManager extends EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  BatteryManagerEvents get on();

  /** @domName BatteryManager.charging */
  final bool charging;

  /** @domName BatteryManager.chargingTime */
  final num chargingTime;

  /** @domName BatteryManager.dischargingTime */
  final num dischargingTime;

  /** @domName BatteryManager.level */
  final num level;

  /** @domName BatteryManager.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName BatteryManager.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName BatteryManager.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

interface BatteryManagerEvents extends Events {

  EventListenerList get chargingChange();

  EventListenerList get chargingTimeChange();

  EventListenerList get dischargingTimeChange();

  EventListenerList get levelChange();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName BeforeLoadEvent
interface BeforeLoadEvent extends Event {

  /** @domName BeforeLoadEvent.url */
  final String url;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName BiquadFilterNode
interface BiquadFilterNode extends AudioNode {

  static final int ALLPASS = 7;

  static final int BANDPASS = 2;

  static final int HIGHPASS = 1;

  static final int HIGHSHELF = 4;

  static final int LOWPASS = 0;

  static final int LOWSHELF = 3;

  static final int NOTCH = 6;

  static final int PEAKING = 5;

  /** @domName BiquadFilterNode.Q */
  final AudioParam Q;

  /** @domName BiquadFilterNode.frequency */
  final AudioParam frequency;

  /** @domName BiquadFilterNode.gain */
  final AudioParam gain;

  /** @domName BiquadFilterNode.type */
  int type;

  /** @domName BiquadFilterNode.getFrequencyResponse */
  void getFrequencyResponse(Float32Array frequencyHz, Float32Array magResponse, Float32Array phaseResponse);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Blob
interface Blob {

  /** @domName Blob.size */
  final int size;

  /** @domName Blob.type */
  final String type;

  /** @domName Blob.webkitSlice */
  Blob webkitSlice([int start, int end, String contentType]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLBodyElement
interface BodyElement extends Element {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  BodyElementEvents get on();

  /** @domName HTMLBodyElement.aLink */
  String aLink;

  /** @domName HTMLBodyElement.background */
  String background;

  /** @domName HTMLBodyElement.bgColor */
  String bgColor;

  /** @domName HTMLBodyElement.link */
  String link;

  /** @domName HTMLBodyElement.vLink */
  String vLink;
}

interface BodyElementEvents extends ElementEvents {

  EventListenerList get beforeUnload();

  EventListenerList get blur();

  EventListenerList get error();

  EventListenerList get focus();

  EventListenerList get hashChange();

  EventListenerList get load();

  EventListenerList get message();

  EventListenerList get offline();

  EventListenerList get online();

  EventListenerList get popState();

  EventListenerList get resize();

  EventListenerList get storage();

  EventListenerList get unload();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLButtonElement
interface ButtonElement extends Element {

  /** @domName HTMLButtonElement.autofocus */
  bool autofocus;

  /** @domName HTMLButtonElement.disabled */
  bool disabled;

  /** @domName HTMLButtonElement.form */
  final FormElement form;

  /** @domName HTMLButtonElement.formAction */
  String formAction;

  /** @domName HTMLButtonElement.formEnctype */
  String formEnctype;

  /** @domName HTMLButtonElement.formMethod */
  String formMethod;

  /** @domName HTMLButtonElement.formNoValidate */
  bool formNoValidate;

  /** @domName HTMLButtonElement.formTarget */
  String formTarget;

  /** @domName HTMLButtonElement.labels */
  final NodeList labels;

  /** @domName HTMLButtonElement.name */
  String name;

  /** @domName HTMLButtonElement.type */
  final String type;

  /** @domName HTMLButtonElement.validationMessage */
  final String validationMessage;

  /** @domName HTMLButtonElement.validity */
  final ValidityState validity;

  /** @domName HTMLButtonElement.value */
  String value;

  /** @domName HTMLButtonElement.willValidate */
  final bool willValidate;

  /** @domName HTMLButtonElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLButtonElement.setCustomValidity */
  void setCustomValidity(String error);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CDATASection
interface CDATASection extends Text {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSCharsetRule
interface CSSCharsetRule extends CSSRule {

  /** @domName CSSCharsetRule.encoding */
  String encoding;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSFontFaceRule
interface CSSFontFaceRule extends CSSRule {

  /** @domName CSSFontFaceRule.style */
  final CSSStyleDeclaration style;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSImportRule
interface CSSImportRule extends CSSRule {

  /** @domName CSSImportRule.href */
  final String href;

  /** @domName CSSImportRule.media */
  final MediaList media;

  /** @domName CSSImportRule.styleSheet */
  final CSSStyleSheet styleSheet;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitCSSKeyframeRule
interface CSSKeyframeRule extends CSSRule {

  /** @domName WebKitCSSKeyframeRule.keyText */
  String keyText;

  /** @domName WebKitCSSKeyframeRule.style */
  final CSSStyleDeclaration style;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitCSSKeyframesRule
interface CSSKeyframesRule extends CSSRule {

  /** @domName WebKitCSSKeyframesRule.cssRules */
  final CSSRuleList cssRules;

  /** @domName WebKitCSSKeyframesRule.name */
  String name;

  /** @domName WebKitCSSKeyframesRule.deleteRule */
  void deleteRule(String key);

  /** @domName WebKitCSSKeyframesRule.findRule */
  CSSKeyframeRule findRule(String key);

  /** @domName WebKitCSSKeyframesRule.insertRule */
  void insertRule(String rule);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitCSSMatrix
interface CSSMatrix default _CSSMatrixFactoryProvider {

  CSSMatrix([String cssValue]);

  /** @domName WebKitCSSMatrix.a */
  num a;

  /** @domName WebKitCSSMatrix.b */
  num b;

  /** @domName WebKitCSSMatrix.c */
  num c;

  /** @domName WebKitCSSMatrix.d */
  num d;

  /** @domName WebKitCSSMatrix.e */
  num e;

  /** @domName WebKitCSSMatrix.f */
  num f;

  /** @domName WebKitCSSMatrix.m11 */
  num m11;

  /** @domName WebKitCSSMatrix.m12 */
  num m12;

  /** @domName WebKitCSSMatrix.m13 */
  num m13;

  /** @domName WebKitCSSMatrix.m14 */
  num m14;

  /** @domName WebKitCSSMatrix.m21 */
  num m21;

  /** @domName WebKitCSSMatrix.m22 */
  num m22;

  /** @domName WebKitCSSMatrix.m23 */
  num m23;

  /** @domName WebKitCSSMatrix.m24 */
  num m24;

  /** @domName WebKitCSSMatrix.m31 */
  num m31;

  /** @domName WebKitCSSMatrix.m32 */
  num m32;

  /** @domName WebKitCSSMatrix.m33 */
  num m33;

  /** @domName WebKitCSSMatrix.m34 */
  num m34;

  /** @domName WebKitCSSMatrix.m41 */
  num m41;

  /** @domName WebKitCSSMatrix.m42 */
  num m42;

  /** @domName WebKitCSSMatrix.m43 */
  num m43;

  /** @domName WebKitCSSMatrix.m44 */
  num m44;

  /** @domName WebKitCSSMatrix.inverse */
  CSSMatrix inverse();

  /** @domName WebKitCSSMatrix.multiply */
  CSSMatrix multiply(CSSMatrix secondMatrix);

  /** @domName WebKitCSSMatrix.rotate */
  CSSMatrix rotate(num rotX, num rotY, num rotZ);

  /** @domName WebKitCSSMatrix.rotateAxisAngle */
  CSSMatrix rotateAxisAngle(num x, num y, num z, num angle);

  /** @domName WebKitCSSMatrix.scale */
  CSSMatrix scale(num scaleX, num scaleY, num scaleZ);

  /** @domName WebKitCSSMatrix.setMatrixValue */
  void setMatrixValue(String string);

  /** @domName WebKitCSSMatrix.skewX */
  CSSMatrix skewX(num angle);

  /** @domName WebKitCSSMatrix.skewY */
  CSSMatrix skewY(num angle);

  /** @domName WebKitCSSMatrix.toString */
  String toString();

  /** @domName WebKitCSSMatrix.translate */
  CSSMatrix translate(num x, num y, num z);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSMediaRule
interface CSSMediaRule extends CSSRule {

  /** @domName CSSMediaRule.cssRules */
  final CSSRuleList cssRules;

  /** @domName CSSMediaRule.media */
  final MediaList media;

  /** @domName CSSMediaRule.deleteRule */
  void deleteRule(int index);

  /** @domName CSSMediaRule.insertRule */
  int insertRule(String rule, int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSPageRule
interface CSSPageRule extends CSSRule {

  /** @domName CSSPageRule.selectorText */
  String selectorText;

  /** @domName CSSPageRule.style */
  final CSSStyleDeclaration style;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSPrimitiveValue
interface CSSPrimitiveValue extends CSSValue {

  static final int CSS_ATTR = 22;

  static final int CSS_CM = 6;

  static final int CSS_COUNTER = 23;

  static final int CSS_DEG = 11;

  static final int CSS_DIMENSION = 18;

  static final int CSS_EMS = 3;

  static final int CSS_EXS = 4;

  static final int CSS_GRAD = 13;

  static final int CSS_HZ = 16;

  static final int CSS_IDENT = 21;

  static final int CSS_IN = 8;

  static final int CSS_KHZ = 17;

  static final int CSS_MM = 7;

  static final int CSS_MS = 14;

  static final int CSS_NUMBER = 1;

  static final int CSS_PC = 10;

  static final int CSS_PERCENTAGE = 2;

  static final int CSS_PT = 9;

  static final int CSS_PX = 5;

  static final int CSS_RAD = 12;

  static final int CSS_RECT = 24;

  static final int CSS_RGBCOLOR = 25;

  static final int CSS_S = 15;

  static final int CSS_STRING = 19;

  static final int CSS_UNKNOWN = 0;

  static final int CSS_URI = 20;

  static final int CSS_VH = 27;

  static final int CSS_VMIN = 28;

  static final int CSS_VW = 26;

  /** @domName CSSPrimitiveValue.primitiveType */
  final int primitiveType;

  /** @domName CSSPrimitiveValue.getCounterValue */
  Counter getCounterValue();

  /** @domName CSSPrimitiveValue.getFloatValue */
  num getFloatValue(int unitType);

  /** @domName CSSPrimitiveValue.getRGBColorValue */
  RGBColor getRGBColorValue();

  /** @domName CSSPrimitiveValue.getRectValue */
  Rect getRectValue();

  /** @domName CSSPrimitiveValue.getStringValue */
  String getStringValue();

  /** @domName CSSPrimitiveValue.setFloatValue */
  void setFloatValue(int unitType, num floatValue);

  /** @domName CSSPrimitiveValue.setStringValue */
  void setStringValue(int stringType, String stringValue);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSRule
interface CSSRule {

  static final int CHARSET_RULE = 2;

  static final int FONT_FACE_RULE = 5;

  static final int IMPORT_RULE = 3;

  static final int MEDIA_RULE = 4;

  static final int PAGE_RULE = 6;

  static final int STYLE_RULE = 1;

  static final int UNKNOWN_RULE = 0;

  static final int WEBKIT_KEYFRAMES_RULE = 7;

  static final int WEBKIT_KEYFRAME_RULE = 8;

  static final int WEBKIT_REGION_RULE = 10;

  /** @domName CSSRule.cssText */
  String cssText;

  /** @domName CSSRule.parentRule */
  final CSSRule parentRule;

  /** @domName CSSRule.parentStyleSheet */
  final CSSStyleSheet parentStyleSheet;

  /** @domName CSSRule.type */
  final int type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSRuleList
interface CSSRuleList {

  /** @domName CSSRuleList.length */
  final int length;

  /** @domName CSSRuleList.item */
  CSSRule item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSStyleDeclaration
interface CSSStyleDeclaration default _CSSStyleDeclarationFactoryProvider {
  CSSStyleDeclaration();
  CSSStyleDeclaration.css(String css);


  /** @domName CSSStyleDeclaration.cssText */
  String cssText;

  /** @domName CSSStyleDeclaration.length */
  final int length;

  /** @domName CSSStyleDeclaration.parentRule */
  final CSSRule parentRule;

  /** @domName CSSStyleDeclaration.getPropertyCSSValue */
  CSSValue getPropertyCSSValue(String propertyName);

  /** @domName CSSStyleDeclaration.getPropertyPriority */
  String getPropertyPriority(String propertyName);

  /** @domName CSSStyleDeclaration.getPropertyShorthand */
  String getPropertyShorthand(String propertyName);

  /** @domName CSSStyleDeclaration.getPropertyValue */
  String getPropertyValue(String propertyName);

  /** @domName CSSStyleDeclaration.isPropertyImplicit */
  bool isPropertyImplicit(String propertyName);

  /** @domName CSSStyleDeclaration.item */
  String item(int index);

  /** @domName CSSStyleDeclaration.removeProperty */
  String removeProperty(String propertyName);

  /** @domName CSSStyleDeclaration.setProperty */
  void setProperty(String propertyName, String value, [String priority]);


  /** Gets the value of "animation" */
  String get animation();

  /** Sets the value of "animation" */
  void set animation(var value);

  /** Gets the value of "animation-delay" */
  String get animationDelay();

  /** Sets the value of "animation-delay" */
  void set animationDelay(var value);

  /** Gets the value of "animation-direction" */
  String get animationDirection();

  /** Sets the value of "animation-direction" */
  void set animationDirection(var value);

  /** Gets the value of "animation-duration" */
  String get animationDuration();

  /** Sets the value of "animation-duration" */
  void set animationDuration(var value);

  /** Gets the value of "animation-fill-mode" */
  String get animationFillMode();

  /** Sets the value of "animation-fill-mode" */
  void set animationFillMode(var value);

  /** Gets the value of "animation-iteration-count" */
  String get animationIterationCount();

  /** Sets the value of "animation-iteration-count" */
  void set animationIterationCount(var value);

  /** Gets the value of "animation-name" */
  String get animationName();

  /** Sets the value of "animation-name" */
  void set animationName(var value);

  /** Gets the value of "animation-play-state" */
  String get animationPlayState();

  /** Sets the value of "animation-play-state" */
  void set animationPlayState(var value);

  /** Gets the value of "animation-timing-function" */
  String get animationTimingFunction();

  /** Sets the value of "animation-timing-function" */
  void set animationTimingFunction(var value);

  /** Gets the value of "appearance" */
  String get appearance();

  /** Sets the value of "appearance" */
  void set appearance(var value);

  /** Gets the value of "backface-visibility" */
  String get backfaceVisibility();

  /** Sets the value of "backface-visibility" */
  void set backfaceVisibility(var value);

  /** Gets the value of "background" */
  String get background();

  /** Sets the value of "background" */
  void set background(var value);

  /** Gets the value of "background-attachment" */
  String get backgroundAttachment();

  /** Sets the value of "background-attachment" */
  void set backgroundAttachment(var value);

  /** Gets the value of "background-clip" */
  String get backgroundClip();

  /** Sets the value of "background-clip" */
  void set backgroundClip(var value);

  /** Gets the value of "background-color" */
  String get backgroundColor();

  /** Sets the value of "background-color" */
  void set backgroundColor(var value);

  /** Gets the value of "background-composite" */
  String get backgroundComposite();

  /** Sets the value of "background-composite" */
  void set backgroundComposite(var value);

  /** Gets the value of "background-image" */
  String get backgroundImage();

  /** Sets the value of "background-image" */
  void set backgroundImage(var value);

  /** Gets the value of "background-origin" */
  String get backgroundOrigin();

  /** Sets the value of "background-origin" */
  void set backgroundOrigin(var value);

  /** Gets the value of "background-position" */
  String get backgroundPosition();

  /** Sets the value of "background-position" */
  void set backgroundPosition(var value);

  /** Gets the value of "background-position-x" */
  String get backgroundPositionX();

  /** Sets the value of "background-position-x" */
  void set backgroundPositionX(var value);

  /** Gets the value of "background-position-y" */
  String get backgroundPositionY();

  /** Sets the value of "background-position-y" */
  void set backgroundPositionY(var value);

  /** Gets the value of "background-repeat" */
  String get backgroundRepeat();

  /** Sets the value of "background-repeat" */
  void set backgroundRepeat(var value);

  /** Gets the value of "background-repeat-x" */
  String get backgroundRepeatX();

  /** Sets the value of "background-repeat-x" */
  void set backgroundRepeatX(var value);

  /** Gets the value of "background-repeat-y" */
  String get backgroundRepeatY();

  /** Sets the value of "background-repeat-y" */
  void set backgroundRepeatY(var value);

  /** Gets the value of "background-size" */
  String get backgroundSize();

  /** Sets the value of "background-size" */
  void set backgroundSize(var value);

  /** Gets the value of "border" */
  String get border();

  /** Sets the value of "border" */
  void set border(var value);

  /** Gets the value of "border-after" */
  String get borderAfter();

  /** Sets the value of "border-after" */
  void set borderAfter(var value);

  /** Gets the value of "border-after-color" */
  String get borderAfterColor();

  /** Sets the value of "border-after-color" */
  void set borderAfterColor(var value);

  /** Gets the value of "border-after-style" */
  String get borderAfterStyle();

  /** Sets the value of "border-after-style" */
  void set borderAfterStyle(var value);

  /** Gets the value of "border-after-width" */
  String get borderAfterWidth();

  /** Sets the value of "border-after-width" */
  void set borderAfterWidth(var value);

  /** Gets the value of "border-before" */
  String get borderBefore();

  /** Sets the value of "border-before" */
  void set borderBefore(var value);

  /** Gets the value of "border-before-color" */
  String get borderBeforeColor();

  /** Sets the value of "border-before-color" */
  void set borderBeforeColor(var value);

  /** Gets the value of "border-before-style" */
  String get borderBeforeStyle();

  /** Sets the value of "border-before-style" */
  void set borderBeforeStyle(var value);

  /** Gets the value of "border-before-width" */
  String get borderBeforeWidth();

  /** Sets the value of "border-before-width" */
  void set borderBeforeWidth(var value);

  /** Gets the value of "border-bottom" */
  String get borderBottom();

  /** Sets the value of "border-bottom" */
  void set borderBottom(var value);

  /** Gets the value of "border-bottom-color" */
  String get borderBottomColor();

  /** Sets the value of "border-bottom-color" */
  void set borderBottomColor(var value);

  /** Gets the value of "border-bottom-left-radius" */
  String get borderBottomLeftRadius();

  /** Sets the value of "border-bottom-left-radius" */
  void set borderBottomLeftRadius(var value);

  /** Gets the value of "border-bottom-right-radius" */
  String get borderBottomRightRadius();

  /** Sets the value of "border-bottom-right-radius" */
  void set borderBottomRightRadius(var value);

  /** Gets the value of "border-bottom-style" */
  String get borderBottomStyle();

  /** Sets the value of "border-bottom-style" */
  void set borderBottomStyle(var value);

  /** Gets the value of "border-bottom-width" */
  String get borderBottomWidth();

  /** Sets the value of "border-bottom-width" */
  void set borderBottomWidth(var value);

  /** Gets the value of "border-collapse" */
  String get borderCollapse();

  /** Sets the value of "border-collapse" */
  void set borderCollapse(var value);

  /** Gets the value of "border-color" */
  String get borderColor();

  /** Sets the value of "border-color" */
  void set borderColor(var value);

  /** Gets the value of "border-end" */
  String get borderEnd();

  /** Sets the value of "border-end" */
  void set borderEnd(var value);

  /** Gets the value of "border-end-color" */
  String get borderEndColor();

  /** Sets the value of "border-end-color" */
  void set borderEndColor(var value);

  /** Gets the value of "border-end-style" */
  String get borderEndStyle();

  /** Sets the value of "border-end-style" */
  void set borderEndStyle(var value);

  /** Gets the value of "border-end-width" */
  String get borderEndWidth();

  /** Sets the value of "border-end-width" */
  void set borderEndWidth(var value);

  /** Gets the value of "border-fit" */
  String get borderFit();

  /** Sets the value of "border-fit" */
  void set borderFit(var value);

  /** Gets the value of "border-horizontal-spacing" */
  String get borderHorizontalSpacing();

  /** Sets the value of "border-horizontal-spacing" */
  void set borderHorizontalSpacing(var value);

  /** Gets the value of "border-image" */
  String get borderImage();

  /** Sets the value of "border-image" */
  void set borderImage(var value);

  /** Gets the value of "border-image-outset" */
  String get borderImageOutset();

  /** Sets the value of "border-image-outset" */
  void set borderImageOutset(var value);

  /** Gets the value of "border-image-repeat" */
  String get borderImageRepeat();

  /** Sets the value of "border-image-repeat" */
  void set borderImageRepeat(var value);

  /** Gets the value of "border-image-slice" */
  String get borderImageSlice();

  /** Sets the value of "border-image-slice" */
  void set borderImageSlice(var value);

  /** Gets the value of "border-image-source" */
  String get borderImageSource();

  /** Sets the value of "border-image-source" */
  void set borderImageSource(var value);

  /** Gets the value of "border-image-width" */
  String get borderImageWidth();

  /** Sets the value of "border-image-width" */
  void set borderImageWidth(var value);

  /** Gets the value of "border-left" */
  String get borderLeft();

  /** Sets the value of "border-left" */
  void set borderLeft(var value);

  /** Gets the value of "border-left-color" */
  String get borderLeftColor();

  /** Sets the value of "border-left-color" */
  void set borderLeftColor(var value);

  /** Gets the value of "border-left-style" */
  String get borderLeftStyle();

  /** Sets the value of "border-left-style" */
  void set borderLeftStyle(var value);

  /** Gets the value of "border-left-width" */
  String get borderLeftWidth();

  /** Sets the value of "border-left-width" */
  void set borderLeftWidth(var value);

  /** Gets the value of "border-radius" */
  String get borderRadius();

  /** Sets the value of "border-radius" */
  void set borderRadius(var value);

  /** Gets the value of "border-right" */
  String get borderRight();

  /** Sets the value of "border-right" */
  void set borderRight(var value);

  /** Gets the value of "border-right-color" */
  String get borderRightColor();

  /** Sets the value of "border-right-color" */
  void set borderRightColor(var value);

  /** Gets the value of "border-right-style" */
  String get borderRightStyle();

  /** Sets the value of "border-right-style" */
  void set borderRightStyle(var value);

  /** Gets the value of "border-right-width" */
  String get borderRightWidth();

  /** Sets the value of "border-right-width" */
  void set borderRightWidth(var value);

  /** Gets the value of "border-spacing" */
  String get borderSpacing();

  /** Sets the value of "border-spacing" */
  void set borderSpacing(var value);

  /** Gets the value of "border-start" */
  String get borderStart();

  /** Sets the value of "border-start" */
  void set borderStart(var value);

  /** Gets the value of "border-start-color" */
  String get borderStartColor();

  /** Sets the value of "border-start-color" */
  void set borderStartColor(var value);

  /** Gets the value of "border-start-style" */
  String get borderStartStyle();

  /** Sets the value of "border-start-style" */
  void set borderStartStyle(var value);

  /** Gets the value of "border-start-width" */
  String get borderStartWidth();

  /** Sets the value of "border-start-width" */
  void set borderStartWidth(var value);

  /** Gets the value of "border-style" */
  String get borderStyle();

  /** Sets the value of "border-style" */
  void set borderStyle(var value);

  /** Gets the value of "border-top" */
  String get borderTop();

  /** Sets the value of "border-top" */
  void set borderTop(var value);

  /** Gets the value of "border-top-color" */
  String get borderTopColor();

  /** Sets the value of "border-top-color" */
  void set borderTopColor(var value);

  /** Gets the value of "border-top-left-radius" */
  String get borderTopLeftRadius();

  /** Sets the value of "border-top-left-radius" */
  void set borderTopLeftRadius(var value);

  /** Gets the value of "border-top-right-radius" */
  String get borderTopRightRadius();

  /** Sets the value of "border-top-right-radius" */
  void set borderTopRightRadius(var value);

  /** Gets the value of "border-top-style" */
  String get borderTopStyle();

  /** Sets the value of "border-top-style" */
  void set borderTopStyle(var value);

  /** Gets the value of "border-top-width" */
  String get borderTopWidth();

  /** Sets the value of "border-top-width" */
  void set borderTopWidth(var value);

  /** Gets the value of "border-vertical-spacing" */
  String get borderVerticalSpacing();

  /** Sets the value of "border-vertical-spacing" */
  void set borderVerticalSpacing(var value);

  /** Gets the value of "border-width" */
  String get borderWidth();

  /** Sets the value of "border-width" */
  void set borderWidth(var value);

  /** Gets the value of "bottom" */
  String get bottom();

  /** Sets the value of "bottom" */
  void set bottom(var value);

  /** Gets the value of "box-align" */
  String get boxAlign();

  /** Sets the value of "box-align" */
  void set boxAlign(var value);

  /** Gets the value of "box-direction" */
  String get boxDirection();

  /** Sets the value of "box-direction" */
  void set boxDirection(var value);

  /** Gets the value of "box-flex" */
  String get boxFlex();

  /** Sets the value of "box-flex" */
  void set boxFlex(var value);

  /** Gets the value of "box-flex-group" */
  String get boxFlexGroup();

  /** Sets the value of "box-flex-group" */
  void set boxFlexGroup(var value);

  /** Gets the value of "box-lines" */
  String get boxLines();

  /** Sets the value of "box-lines" */
  void set boxLines(var value);

  /** Gets the value of "box-ordinal-group" */
  String get boxOrdinalGroup();

  /** Sets the value of "box-ordinal-group" */
  void set boxOrdinalGroup(var value);

  /** Gets the value of "box-orient" */
  String get boxOrient();

  /** Sets the value of "box-orient" */
  void set boxOrient(var value);

  /** Gets the value of "box-pack" */
  String get boxPack();

  /** Sets the value of "box-pack" */
  void set boxPack(var value);

  /** Gets the value of "box-reflect" */
  String get boxReflect();

  /** Sets the value of "box-reflect" */
  void set boxReflect(var value);

  /** Gets the value of "box-shadow" */
  String get boxShadow();

  /** Sets the value of "box-shadow" */
  void set boxShadow(var value);

  /** Gets the value of "box-sizing" */
  String get boxSizing();

  /** Sets the value of "box-sizing" */
  void set boxSizing(var value);

  /** Gets the value of "caption-side" */
  String get captionSide();

  /** Sets the value of "caption-side" */
  void set captionSide(var value);

  /** Gets the value of "clear" */
  String get clear();

  /** Sets the value of "clear" */
  void set clear(var value);

  /** Gets the value of "clip" */
  String get clip();

  /** Sets the value of "clip" */
  void set clip(var value);

  /** Gets the value of "color" */
  String get color();

  /** Sets the value of "color" */
  void set color(var value);

  /** Gets the value of "color-correction" */
  String get colorCorrection();

  /** Sets the value of "color-correction" */
  void set colorCorrection(var value);

  /** Gets the value of "column-break-after" */
  String get columnBreakAfter();

  /** Sets the value of "column-break-after" */
  void set columnBreakAfter(var value);

  /** Gets the value of "column-break-before" */
  String get columnBreakBefore();

  /** Sets the value of "column-break-before" */
  void set columnBreakBefore(var value);

  /** Gets the value of "column-break-inside" */
  String get columnBreakInside();

  /** Sets the value of "column-break-inside" */
  void set columnBreakInside(var value);

  /** Gets the value of "column-count" */
  String get columnCount();

  /** Sets the value of "column-count" */
  void set columnCount(var value);

  /** Gets the value of "column-gap" */
  String get columnGap();

  /** Sets the value of "column-gap" */
  void set columnGap(var value);

  /** Gets the value of "column-rule" */
  String get columnRule();

  /** Sets the value of "column-rule" */
  void set columnRule(var value);

  /** Gets the value of "column-rule-color" */
  String get columnRuleColor();

  /** Sets the value of "column-rule-color" */
  void set columnRuleColor(var value);

  /** Gets the value of "column-rule-style" */
  String get columnRuleStyle();

  /** Sets the value of "column-rule-style" */
  void set columnRuleStyle(var value);

  /** Gets the value of "column-rule-width" */
  String get columnRuleWidth();

  /** Sets the value of "column-rule-width" */
  void set columnRuleWidth(var value);

  /** Gets the value of "column-span" */
  String get columnSpan();

  /** Sets the value of "column-span" */
  void set columnSpan(var value);

  /** Gets the value of "column-width" */
  String get columnWidth();

  /** Sets the value of "column-width" */
  void set columnWidth(var value);

  /** Gets the value of "columns" */
  String get columns();

  /** Sets the value of "columns" */
  void set columns(var value);

  /** Gets the value of "content" */
  String get content();

  /** Sets the value of "content" */
  void set content(var value);

  /** Gets the value of "counter-increment" */
  String get counterIncrement();

  /** Sets the value of "counter-increment" */
  void set counterIncrement(var value);

  /** Gets the value of "counter-reset" */
  String get counterReset();

  /** Sets the value of "counter-reset" */
  void set counterReset(var value);

  /** Gets the value of "cursor" */
  String get cursor();

  /** Sets the value of "cursor" */
  void set cursor(var value);

  /** Gets the value of "direction" */
  String get direction();

  /** Sets the value of "direction" */
  void set direction(var value);

  /** Gets the value of "display" */
  String get display();

  /** Sets the value of "display" */
  void set display(var value);

  /** Gets the value of "empty-cells" */
  String get emptyCells();

  /** Sets the value of "empty-cells" */
  void set emptyCells(var value);

  /** Gets the value of "filter" */
  String get filter();

  /** Sets the value of "filter" */
  void set filter(var value);

  /** Gets the value of "flex-align" */
  String get flexAlign();

  /** Sets the value of "flex-align" */
  void set flexAlign(var value);

  /** Gets the value of "flex-flow" */
  String get flexFlow();

  /** Sets the value of "flex-flow" */
  void set flexFlow(var value);

  /** Gets the value of "flex-order" */
  String get flexOrder();

  /** Sets the value of "flex-order" */
  void set flexOrder(var value);

  /** Gets the value of "flex-pack" */
  String get flexPack();

  /** Sets the value of "flex-pack" */
  void set flexPack(var value);

  /** Gets the value of "float" */
  String get float();

  /** Sets the value of "float" */
  void set float(var value);

  /** Gets the value of "flow-from" */
  String get flowFrom();

  /** Sets the value of "flow-from" */
  void set flowFrom(var value);

  /** Gets the value of "flow-into" */
  String get flowInto();

  /** Sets the value of "flow-into" */
  void set flowInto(var value);

  /** Gets the value of "font" */
  String get font();

  /** Sets the value of "font" */
  void set font(var value);

  /** Gets the value of "font-family" */
  String get fontFamily();

  /** Sets the value of "font-family" */
  void set fontFamily(var value);

  /** Gets the value of "font-feature-settings" */
  String get fontFeatureSettings();

  /** Sets the value of "font-feature-settings" */
  void set fontFeatureSettings(var value);

  /** Gets the value of "font-size" */
  String get fontSize();

  /** Sets the value of "font-size" */
  void set fontSize(var value);

  /** Gets the value of "font-size-delta" */
  String get fontSizeDelta();

  /** Sets the value of "font-size-delta" */
  void set fontSizeDelta(var value);

  /** Gets the value of "font-smoothing" */
  String get fontSmoothing();

  /** Sets the value of "font-smoothing" */
  void set fontSmoothing(var value);

  /** Gets the value of "font-stretch" */
  String get fontStretch();

  /** Sets the value of "font-stretch" */
  void set fontStretch(var value);

  /** Gets the value of "font-style" */
  String get fontStyle();

  /** Sets the value of "font-style" */
  void set fontStyle(var value);

  /** Gets the value of "font-variant" */
  String get fontVariant();

  /** Sets the value of "font-variant" */
  void set fontVariant(var value);

  /** Gets the value of "font-weight" */
  String get fontWeight();

  /** Sets the value of "font-weight" */
  void set fontWeight(var value);

  /** Gets the value of "height" */
  String get height();

  /** Sets the value of "height" */
  void set height(var value);

  /** Gets the value of "highlight" */
  String get highlight();

  /** Sets the value of "highlight" */
  void set highlight(var value);

  /** Gets the value of "hyphenate-character" */
  String get hyphenateCharacter();

  /** Sets the value of "hyphenate-character" */
  void set hyphenateCharacter(var value);

  /** Gets the value of "hyphenate-limit-after" */
  String get hyphenateLimitAfter();

  /** Sets the value of "hyphenate-limit-after" */
  void set hyphenateLimitAfter(var value);

  /** Gets the value of "hyphenate-limit-before" */
  String get hyphenateLimitBefore();

  /** Sets the value of "hyphenate-limit-before" */
  void set hyphenateLimitBefore(var value);

  /** Gets the value of "hyphenate-limit-lines" */
  String get hyphenateLimitLines();

  /** Sets the value of "hyphenate-limit-lines" */
  void set hyphenateLimitLines(var value);

  /** Gets the value of "hyphens" */
  String get hyphens();

  /** Sets the value of "hyphens" */
  void set hyphens(var value);

  /** Gets the value of "image-rendering" */
  String get imageRendering();

  /** Sets the value of "image-rendering" */
  void set imageRendering(var value);

  /** Gets the value of "left" */
  String get left();

  /** Sets the value of "left" */
  void set left(var value);

  /** Gets the value of "letter-spacing" */
  String get letterSpacing();

  /** Sets the value of "letter-spacing" */
  void set letterSpacing(var value);

  /** Gets the value of "line-box-contain" */
  String get lineBoxContain();

  /** Sets the value of "line-box-contain" */
  void set lineBoxContain(var value);

  /** Gets the value of "line-break" */
  String get lineBreak();

  /** Sets the value of "line-break" */
  void set lineBreak(var value);

  /** Gets the value of "line-clamp" */
  String get lineClamp();

  /** Sets the value of "line-clamp" */
  void set lineClamp(var value);

  /** Gets the value of "line-height" */
  String get lineHeight();

  /** Sets the value of "line-height" */
  void set lineHeight(var value);

  /** Gets the value of "list-style" */
  String get listStyle();

  /** Sets the value of "list-style" */
  void set listStyle(var value);

  /** Gets the value of "list-style-image" */
  String get listStyleImage();

  /** Sets the value of "list-style-image" */
  void set listStyleImage(var value);

  /** Gets the value of "list-style-position" */
  String get listStylePosition();

  /** Sets the value of "list-style-position" */
  void set listStylePosition(var value);

  /** Gets the value of "list-style-type" */
  String get listStyleType();

  /** Sets the value of "list-style-type" */
  void set listStyleType(var value);

  /** Gets the value of "locale" */
  String get locale();

  /** Sets the value of "locale" */
  void set locale(var value);

  /** Gets the value of "logical-height" */
  String get logicalHeight();

  /** Sets the value of "logical-height" */
  void set logicalHeight(var value);

  /** Gets the value of "logical-width" */
  String get logicalWidth();

  /** Sets the value of "logical-width" */
  void set logicalWidth(var value);

  /** Gets the value of "margin" */
  String get margin();

  /** Sets the value of "margin" */
  void set margin(var value);

  /** Gets the value of "margin-after" */
  String get marginAfter();

  /** Sets the value of "margin-after" */
  void set marginAfter(var value);

  /** Gets the value of "margin-after-collapse" */
  String get marginAfterCollapse();

  /** Sets the value of "margin-after-collapse" */
  void set marginAfterCollapse(var value);

  /** Gets the value of "margin-before" */
  String get marginBefore();

  /** Sets the value of "margin-before" */
  void set marginBefore(var value);

  /** Gets the value of "margin-before-collapse" */
  String get marginBeforeCollapse();

  /** Sets the value of "margin-before-collapse" */
  void set marginBeforeCollapse(var value);

  /** Gets the value of "margin-bottom" */
  String get marginBottom();

  /** Sets the value of "margin-bottom" */
  void set marginBottom(var value);

  /** Gets the value of "margin-bottom-collapse" */
  String get marginBottomCollapse();

  /** Sets the value of "margin-bottom-collapse" */
  void set marginBottomCollapse(var value);

  /** Gets the value of "margin-collapse" */
  String get marginCollapse();

  /** Sets the value of "margin-collapse" */
  void set marginCollapse(var value);

  /** Gets the value of "margin-end" */
  String get marginEnd();

  /** Sets the value of "margin-end" */
  void set marginEnd(var value);

  /** Gets the value of "margin-left" */
  String get marginLeft();

  /** Sets the value of "margin-left" */
  void set marginLeft(var value);

  /** Gets the value of "margin-right" */
  String get marginRight();

  /** Sets the value of "margin-right" */
  void set marginRight(var value);

  /** Gets the value of "margin-start" */
  String get marginStart();

  /** Sets the value of "margin-start" */
  void set marginStart(var value);

  /** Gets the value of "margin-top" */
  String get marginTop();

  /** Sets the value of "margin-top" */
  void set marginTop(var value);

  /** Gets the value of "margin-top-collapse" */
  String get marginTopCollapse();

  /** Sets the value of "margin-top-collapse" */
  void set marginTopCollapse(var value);

  /** Gets the value of "marquee" */
  String get marquee();

  /** Sets the value of "marquee" */
  void set marquee(var value);

  /** Gets the value of "marquee-direction" */
  String get marqueeDirection();

  /** Sets the value of "marquee-direction" */
  void set marqueeDirection(var value);

  /** Gets the value of "marquee-increment" */
  String get marqueeIncrement();

  /** Sets the value of "marquee-increment" */
  void set marqueeIncrement(var value);

  /** Gets the value of "marquee-repetition" */
  String get marqueeRepetition();

  /** Sets the value of "marquee-repetition" */
  void set marqueeRepetition(var value);

  /** Gets the value of "marquee-speed" */
  String get marqueeSpeed();

  /** Sets the value of "marquee-speed" */
  void set marqueeSpeed(var value);

  /** Gets the value of "marquee-style" */
  String get marqueeStyle();

  /** Sets the value of "marquee-style" */
  void set marqueeStyle(var value);

  /** Gets the value of "mask" */
  String get mask();

  /** Sets the value of "mask" */
  void set mask(var value);

  /** Gets the value of "mask-attachment" */
  String get maskAttachment();

  /** Sets the value of "mask-attachment" */
  void set maskAttachment(var value);

  /** Gets the value of "mask-box-image" */
  String get maskBoxImage();

  /** Sets the value of "mask-box-image" */
  void set maskBoxImage(var value);

  /** Gets the value of "mask-box-image-outset" */
  String get maskBoxImageOutset();

  /** Sets the value of "mask-box-image-outset" */
  void set maskBoxImageOutset(var value);

  /** Gets the value of "mask-box-image-repeat" */
  String get maskBoxImageRepeat();

  /** Sets the value of "mask-box-image-repeat" */
  void set maskBoxImageRepeat(var value);

  /** Gets the value of "mask-box-image-slice" */
  String get maskBoxImageSlice();

  /** Sets the value of "mask-box-image-slice" */
  void set maskBoxImageSlice(var value);

  /** Gets the value of "mask-box-image-source" */
  String get maskBoxImageSource();

  /** Sets the value of "mask-box-image-source" */
  void set maskBoxImageSource(var value);

  /** Gets the value of "mask-box-image-width" */
  String get maskBoxImageWidth();

  /** Sets the value of "mask-box-image-width" */
  void set maskBoxImageWidth(var value);

  /** Gets the value of "mask-clip" */
  String get maskClip();

  /** Sets the value of "mask-clip" */
  void set maskClip(var value);

  /** Gets the value of "mask-composite" */
  String get maskComposite();

  /** Sets the value of "mask-composite" */
  void set maskComposite(var value);

  /** Gets the value of "mask-image" */
  String get maskImage();

  /** Sets the value of "mask-image" */
  void set maskImage(var value);

  /** Gets the value of "mask-origin" */
  String get maskOrigin();

  /** Sets the value of "mask-origin" */
  void set maskOrigin(var value);

  /** Gets the value of "mask-position" */
  String get maskPosition();

  /** Sets the value of "mask-position" */
  void set maskPosition(var value);

  /** Gets the value of "mask-position-x" */
  String get maskPositionX();

  /** Sets the value of "mask-position-x" */
  void set maskPositionX(var value);

  /** Gets the value of "mask-position-y" */
  String get maskPositionY();

  /** Sets the value of "mask-position-y" */
  void set maskPositionY(var value);

  /** Gets the value of "mask-repeat" */
  String get maskRepeat();

  /** Sets the value of "mask-repeat" */
  void set maskRepeat(var value);

  /** Gets the value of "mask-repeat-x" */
  String get maskRepeatX();

  /** Sets the value of "mask-repeat-x" */
  void set maskRepeatX(var value);

  /** Gets the value of "mask-repeat-y" */
  String get maskRepeatY();

  /** Sets the value of "mask-repeat-y" */
  void set maskRepeatY(var value);

  /** Gets the value of "mask-size" */
  String get maskSize();

  /** Sets the value of "mask-size" */
  void set maskSize(var value);

  /** Gets the value of "match-nearest-mail-blockquote-color" */
  String get matchNearestMailBlockquoteColor();

  /** Sets the value of "match-nearest-mail-blockquote-color" */
  void set matchNearestMailBlockquoteColor(var value);

  /** Gets the value of "max-height" */
  String get maxHeight();

  /** Sets the value of "max-height" */
  void set maxHeight(var value);

  /** Gets the value of "max-logical-height" */
  String get maxLogicalHeight();

  /** Sets the value of "max-logical-height" */
  void set maxLogicalHeight(var value);

  /** Gets the value of "max-logical-width" */
  String get maxLogicalWidth();

  /** Sets the value of "max-logical-width" */
  void set maxLogicalWidth(var value);

  /** Gets the value of "max-width" */
  String get maxWidth();

  /** Sets the value of "max-width" */
  void set maxWidth(var value);

  /** Gets the value of "min-height" */
  String get minHeight();

  /** Sets the value of "min-height" */
  void set minHeight(var value);

  /** Gets the value of "min-logical-height" */
  String get minLogicalHeight();

  /** Sets the value of "min-logical-height" */
  void set minLogicalHeight(var value);

  /** Gets the value of "min-logical-width" */
  String get minLogicalWidth();

  /** Sets the value of "min-logical-width" */
  void set minLogicalWidth(var value);

  /** Gets the value of "min-width" */
  String get minWidth();

  /** Sets the value of "min-width" */
  void set minWidth(var value);

  /** Gets the value of "nbsp-mode" */
  String get nbspMode();

  /** Sets the value of "nbsp-mode" */
  void set nbspMode(var value);

  /** Gets the value of "opacity" */
  String get opacity();

  /** Sets the value of "opacity" */
  void set opacity(var value);

  /** Gets the value of "orphans" */
  String get orphans();

  /** Sets the value of "orphans" */
  void set orphans(var value);

  /** Gets the value of "outline" */
  String get outline();

  /** Sets the value of "outline" */
  void set outline(var value);

  /** Gets the value of "outline-color" */
  String get outlineColor();

  /** Sets the value of "outline-color" */
  void set outlineColor(var value);

  /** Gets the value of "outline-offset" */
  String get outlineOffset();

  /** Sets the value of "outline-offset" */
  void set outlineOffset(var value);

  /** Gets the value of "outline-style" */
  String get outlineStyle();

  /** Sets the value of "outline-style" */
  void set outlineStyle(var value);

  /** Gets the value of "outline-width" */
  String get outlineWidth();

  /** Sets the value of "outline-width" */
  void set outlineWidth(var value);

  /** Gets the value of "overflow" */
  String get overflow();

  /** Sets the value of "overflow" */
  void set overflow(var value);

  /** Gets the value of "overflow-x" */
  String get overflowX();

  /** Sets the value of "overflow-x" */
  void set overflowX(var value);

  /** Gets the value of "overflow-y" */
  String get overflowY();

  /** Sets the value of "overflow-y" */
  void set overflowY(var value);

  /** Gets the value of "padding" */
  String get padding();

  /** Sets the value of "padding" */
  void set padding(var value);

  /** Gets the value of "padding-after" */
  String get paddingAfter();

  /** Sets the value of "padding-after" */
  void set paddingAfter(var value);

  /** Gets the value of "padding-before" */
  String get paddingBefore();

  /** Sets the value of "padding-before" */
  void set paddingBefore(var value);

  /** Gets the value of "padding-bottom" */
  String get paddingBottom();

  /** Sets the value of "padding-bottom" */
  void set paddingBottom(var value);

  /** Gets the value of "padding-end" */
  String get paddingEnd();

  /** Sets the value of "padding-end" */
  void set paddingEnd(var value);

  /** Gets the value of "padding-left" */
  String get paddingLeft();

  /** Sets the value of "padding-left" */
  void set paddingLeft(var value);

  /** Gets the value of "padding-right" */
  String get paddingRight();

  /** Sets the value of "padding-right" */
  void set paddingRight(var value);

  /** Gets the value of "padding-start" */
  String get paddingStart();

  /** Sets the value of "padding-start" */
  void set paddingStart(var value);

  /** Gets the value of "padding-top" */
  String get paddingTop();

  /** Sets the value of "padding-top" */
  void set paddingTop(var value);

  /** Gets the value of "page" */
  String get page();

  /** Sets the value of "page" */
  void set page(var value);

  /** Gets the value of "page-break-after" */
  String get pageBreakAfter();

  /** Sets the value of "page-break-after" */
  void set pageBreakAfter(var value);

  /** Gets the value of "page-break-before" */
  String get pageBreakBefore();

  /** Sets the value of "page-break-before" */
  void set pageBreakBefore(var value);

  /** Gets the value of "page-break-inside" */
  String get pageBreakInside();

  /** Sets the value of "page-break-inside" */
  void set pageBreakInside(var value);

  /** Gets the value of "perspective" */
  String get perspective();

  /** Sets the value of "perspective" */
  void set perspective(var value);

  /** Gets the value of "perspective-origin" */
  String get perspectiveOrigin();

  /** Sets the value of "perspective-origin" */
  void set perspectiveOrigin(var value);

  /** Gets the value of "perspective-origin-x" */
  String get perspectiveOriginX();

  /** Sets the value of "perspective-origin-x" */
  void set perspectiveOriginX(var value);

  /** Gets the value of "perspective-origin-y" */
  String get perspectiveOriginY();

  /** Sets the value of "perspective-origin-y" */
  void set perspectiveOriginY(var value);

  /** Gets the value of "pointer-events" */
  String get pointerEvents();

  /** Sets the value of "pointer-events" */
  void set pointerEvents(var value);

  /** Gets the value of "position" */
  String get position();

  /** Sets the value of "position" */
  void set position(var value);

  /** Gets the value of "quotes" */
  String get quotes();

  /** Sets the value of "quotes" */
  void set quotes(var value);

  /** Gets the value of "region-break-after" */
  String get regionBreakAfter();

  /** Sets the value of "region-break-after" */
  void set regionBreakAfter(var value);

  /** Gets the value of "region-break-before" */
  String get regionBreakBefore();

  /** Sets the value of "region-break-before" */
  void set regionBreakBefore(var value);

  /** Gets the value of "region-break-inside" */
  String get regionBreakInside();

  /** Sets the value of "region-break-inside" */
  void set regionBreakInside(var value);

  /** Gets the value of "region-overflow" */
  String get regionOverflow();

  /** Sets the value of "region-overflow" */
  void set regionOverflow(var value);

  /** Gets the value of "resize" */
  String get resize();

  /** Sets the value of "resize" */
  void set resize(var value);

  /** Gets the value of "right" */
  String get right();

  /** Sets the value of "right" */
  void set right(var value);

  /** Gets the value of "rtl-ordering" */
  String get rtlOrdering();

  /** Sets the value of "rtl-ordering" */
  void set rtlOrdering(var value);

  /** Gets the value of "size" */
  String get size();

  /** Sets the value of "size" */
  void set size(var value);

  /** Gets the value of "speak" */
  String get speak();

  /** Sets the value of "speak" */
  void set speak(var value);

  /** Gets the value of "src" */
  String get src();

  /** Sets the value of "src" */
  void set src(var value);

  /** Gets the value of "table-layout" */
  String get tableLayout();

  /** Sets the value of "table-layout" */
  void set tableLayout(var value);

  /** Gets the value of "tap-highlight-color" */
  String get tapHighlightColor();

  /** Sets the value of "tap-highlight-color" */
  void set tapHighlightColor(var value);

  /** Gets the value of "text-align" */
  String get textAlign();

  /** Sets the value of "text-align" */
  void set textAlign(var value);

  /** Gets the value of "text-combine" */
  String get textCombine();

  /** Sets the value of "text-combine" */
  void set textCombine(var value);

  /** Gets the value of "text-decoration" */
  String get textDecoration();

  /** Sets the value of "text-decoration" */
  void set textDecoration(var value);

  /** Gets the value of "text-decorations-in-effect" */
  String get textDecorationsInEffect();

  /** Sets the value of "text-decorations-in-effect" */
  void set textDecorationsInEffect(var value);

  /** Gets the value of "text-emphasis" */
  String get textEmphasis();

  /** Sets the value of "text-emphasis" */
  void set textEmphasis(var value);

  /** Gets the value of "text-emphasis-color" */
  String get textEmphasisColor();

  /** Sets the value of "text-emphasis-color" */
  void set textEmphasisColor(var value);

  /** Gets the value of "text-emphasis-position" */
  String get textEmphasisPosition();

  /** Sets the value of "text-emphasis-position" */
  void set textEmphasisPosition(var value);

  /** Gets the value of "text-emphasis-style" */
  String get textEmphasisStyle();

  /** Sets the value of "text-emphasis-style" */
  void set textEmphasisStyle(var value);

  /** Gets the value of "text-fill-color" */
  String get textFillColor();

  /** Sets the value of "text-fill-color" */
  void set textFillColor(var value);

  /** Gets the value of "text-indent" */
  String get textIndent();

  /** Sets the value of "text-indent" */
  void set textIndent(var value);

  /** Gets the value of "text-line-through" */
  String get textLineThrough();

  /** Sets the value of "text-line-through" */
  void set textLineThrough(var value);

  /** Gets the value of "text-line-through-color" */
  String get textLineThroughColor();

  /** Sets the value of "text-line-through-color" */
  void set textLineThroughColor(var value);

  /** Gets the value of "text-line-through-mode" */
  String get textLineThroughMode();

  /** Sets the value of "text-line-through-mode" */
  void set textLineThroughMode(var value);

  /** Gets the value of "text-line-through-style" */
  String get textLineThroughStyle();

  /** Sets the value of "text-line-through-style" */
  void set textLineThroughStyle(var value);

  /** Gets the value of "text-line-through-width" */
  String get textLineThroughWidth();

  /** Sets the value of "text-line-through-width" */
  void set textLineThroughWidth(var value);

  /** Gets the value of "text-orientation" */
  String get textOrientation();

  /** Sets the value of "text-orientation" */
  void set textOrientation(var value);

  /** Gets the value of "text-overflow" */
  String get textOverflow();

  /** Sets the value of "text-overflow" */
  void set textOverflow(var value);

  /** Gets the value of "text-overline" */
  String get textOverline();

  /** Sets the value of "text-overline" */
  void set textOverline(var value);

  /** Gets the value of "text-overline-color" */
  String get textOverlineColor();

  /** Sets the value of "text-overline-color" */
  void set textOverlineColor(var value);

  /** Gets the value of "text-overline-mode" */
  String get textOverlineMode();

  /** Sets the value of "text-overline-mode" */
  void set textOverlineMode(var value);

  /** Gets the value of "text-overline-style" */
  String get textOverlineStyle();

  /** Sets the value of "text-overline-style" */
  void set textOverlineStyle(var value);

  /** Gets the value of "text-overline-width" */
  String get textOverlineWidth();

  /** Sets the value of "text-overline-width" */
  void set textOverlineWidth(var value);

  /** Gets the value of "text-rendering" */
  String get textRendering();

  /** Sets the value of "text-rendering" */
  void set textRendering(var value);

  /** Gets the value of "text-security" */
  String get textSecurity();

  /** Sets the value of "text-security" */
  void set textSecurity(var value);

  /** Gets the value of "text-shadow" */
  String get textShadow();

  /** Sets the value of "text-shadow" */
  void set textShadow(var value);

  /** Gets the value of "text-size-adjust" */
  String get textSizeAdjust();

  /** Sets the value of "text-size-adjust" */
  void set textSizeAdjust(var value);

  /** Gets the value of "text-stroke" */
  String get textStroke();

  /** Sets the value of "text-stroke" */
  void set textStroke(var value);

  /** Gets the value of "text-stroke-color" */
  String get textStrokeColor();

  /** Sets the value of "text-stroke-color" */
  void set textStrokeColor(var value);

  /** Gets the value of "text-stroke-width" */
  String get textStrokeWidth();

  /** Sets the value of "text-stroke-width" */
  void set textStrokeWidth(var value);

  /** Gets the value of "text-transform" */
  String get textTransform();

  /** Sets the value of "text-transform" */
  void set textTransform(var value);

  /** Gets the value of "text-underline" */
  String get textUnderline();

  /** Sets the value of "text-underline" */
  void set textUnderline(var value);

  /** Gets the value of "text-underline-color" */
  String get textUnderlineColor();

  /** Sets the value of "text-underline-color" */
  void set textUnderlineColor(var value);

  /** Gets the value of "text-underline-mode" */
  String get textUnderlineMode();

  /** Sets the value of "text-underline-mode" */
  void set textUnderlineMode(var value);

  /** Gets the value of "text-underline-style" */
  String get textUnderlineStyle();

  /** Sets the value of "text-underline-style" */
  void set textUnderlineStyle(var value);

  /** Gets the value of "text-underline-width" */
  String get textUnderlineWidth();

  /** Sets the value of "text-underline-width" */
  void set textUnderlineWidth(var value);

  /** Gets the value of "top" */
  String get top();

  /** Sets the value of "top" */
  void set top(var value);

  /** Gets the value of "transform" */
  String get transform();

  /** Sets the value of "transform" */
  void set transform(var value);

  /** Gets the value of "transform-origin" */
  String get transformOrigin();

  /** Sets the value of "transform-origin" */
  void set transformOrigin(var value);

  /** Gets the value of "transform-origin-x" */
  String get transformOriginX();

  /** Sets the value of "transform-origin-x" */
  void set transformOriginX(var value);

  /** Gets the value of "transform-origin-y" */
  String get transformOriginY();

  /** Sets the value of "transform-origin-y" */
  void set transformOriginY(var value);

  /** Gets the value of "transform-origin-z" */
  String get transformOriginZ();

  /** Sets the value of "transform-origin-z" */
  void set transformOriginZ(var value);

  /** Gets the value of "transform-style" */
  String get transformStyle();

  /** Sets the value of "transform-style" */
  void set transformStyle(var value);

  /** Gets the value of "transition" */
  String get transition();

  /** Sets the value of "transition" */
  void set transition(var value);

  /** Gets the value of "transition-delay" */
  String get transitionDelay();

  /** Sets the value of "transition-delay" */
  void set transitionDelay(var value);

  /** Gets the value of "transition-duration" */
  String get transitionDuration();

  /** Sets the value of "transition-duration" */
  void set transitionDuration(var value);

  /** Gets the value of "transition-property" */
  String get transitionProperty();

  /** Sets the value of "transition-property" */
  void set transitionProperty(var value);

  /** Gets the value of "transition-timing-function" */
  String get transitionTimingFunction();

  /** Sets the value of "transition-timing-function" */
  void set transitionTimingFunction(var value);

  /** Gets the value of "unicode-bidi" */
  String get unicodeBidi();

  /** Sets the value of "unicode-bidi" */
  void set unicodeBidi(var value);

  /** Gets the value of "unicode-range" */
  String get unicodeRange();

  /** Sets the value of "unicode-range" */
  void set unicodeRange(var value);

  /** Gets the value of "user-drag" */
  String get userDrag();

  /** Sets the value of "user-drag" */
  void set userDrag(var value);

  /** Gets the value of "user-modify" */
  String get userModify();

  /** Sets the value of "user-modify" */
  void set userModify(var value);

  /** Gets the value of "user-select" */
  String get userSelect();

  /** Sets the value of "user-select" */
  void set userSelect(var value);

  /** Gets the value of "vertical-align" */
  String get verticalAlign();

  /** Sets the value of "vertical-align" */
  void set verticalAlign(var value);

  /** Gets the value of "visibility" */
  String get visibility();

  /** Sets the value of "visibility" */
  void set visibility(var value);

  /** Gets the value of "white-space" */
  String get whiteSpace();

  /** Sets the value of "white-space" */
  void set whiteSpace(var value);

  /** Gets the value of "widows" */
  String get widows();

  /** Sets the value of "widows" */
  void set widows(var value);

  /** Gets the value of "width" */
  String get width();

  /** Sets the value of "width" */
  void set width(var value);

  /** Gets the value of "word-break" */
  String get wordBreak();

  /** Sets the value of "word-break" */
  void set wordBreak(var value);

  /** Gets the value of "word-spacing" */
  String get wordSpacing();

  /** Sets the value of "word-spacing" */
  void set wordSpacing(var value);

  /** Gets the value of "word-wrap" */
  String get wordWrap();

  /** Sets the value of "word-wrap" */
  void set wordWrap(var value);

  /** Gets the value of "wrap-shape" */
  String get wrapShape();

  /** Sets the value of "wrap-shape" */
  void set wrapShape(var value);

  /** Gets the value of "writing-mode" */
  String get writingMode();

  /** Sets the value of "writing-mode" */
  void set writingMode(var value);

  /** Gets the value of "z-index" */
  String get zIndex();

  /** Sets the value of "z-index" */
  void set zIndex(var value);

  /** Gets the value of "zoom" */
  String get zoom();

  /** Sets the value of "zoom" */
  void set zoom(var value);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSStyleRule
interface CSSStyleRule extends CSSRule {

  /** @domName CSSStyleRule.selectorText */
  String selectorText;

  /** @domName CSSStyleRule.style */
  final CSSStyleDeclaration style;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSStyleSheet
interface CSSStyleSheet extends StyleSheet {

  /** @domName CSSStyleSheet.cssRules */
  final CSSRuleList cssRules;

  /** @domName CSSStyleSheet.ownerRule */
  final CSSRule ownerRule;

  /** @domName CSSStyleSheet.rules */
  final CSSRuleList rules;

  /** @domName CSSStyleSheet.addRule */
  int addRule(String selector, String style, [int index]);

  /** @domName CSSStyleSheet.deleteRule */
  void deleteRule(int index);

  /** @domName CSSStyleSheet.insertRule */
  int insertRule(String rule, int index);

  /** @domName CSSStyleSheet.removeRule */
  void removeRule(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitCSSTransformValue
interface CSSTransformValue extends CSSValueList {

  static final int CSS_MATRIX = 11;

  static final int CSS_MATRIX3D = 21;

  static final int CSS_PERSPECTIVE = 20;

  static final int CSS_ROTATE = 4;

  static final int CSS_ROTATE3D = 17;

  static final int CSS_ROTATEX = 14;

  static final int CSS_ROTATEY = 15;

  static final int CSS_ROTATEZ = 16;

  static final int CSS_SCALE = 5;

  static final int CSS_SCALE3D = 19;

  static final int CSS_SCALEX = 6;

  static final int CSS_SCALEY = 7;

  static final int CSS_SCALEZ = 18;

  static final int CSS_SKEW = 8;

  static final int CSS_SKEWX = 9;

  static final int CSS_SKEWY = 10;

  static final int CSS_TRANSLATE = 1;

  static final int CSS_TRANSLATE3D = 13;

  static final int CSS_TRANSLATEX = 2;

  static final int CSS_TRANSLATEY = 3;

  static final int CSS_TRANSLATEZ = 12;

  /** @domName WebKitCSSTransformValue.operationType */
  final int operationType;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSUnknownRule
interface CSSUnknownRule extends CSSRule {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSValue
interface CSSValue {

  static final int CSS_CUSTOM = 3;

  static final int CSS_INHERIT = 0;

  static final int CSS_PRIMITIVE_VALUE = 1;

  static final int CSS_VALUE_LIST = 2;

  /** @domName CSSValue.cssText */
  String cssText;

  /** @domName CSSValue.cssValueType */
  final int cssValueType;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CSSValueList
interface CSSValueList extends CSSValue {

  /** @domName CSSValueList.length */
  final int length;

  /** @domName CSSValueList.item */
  CSSValue item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLCanvasElement
interface CanvasElement extends Element {

  /** @domName HTMLCanvasElement.height */
  int height;

  /** @domName HTMLCanvasElement.width */
  int width;

  /** @domName HTMLCanvasElement.getContext */
  Object getContext(String contextId);

  /** @domName HTMLCanvasElement.toDataURL */
  String toDataURL(String type);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CanvasGradient
interface CanvasGradient {

  /** @domName CanvasGradient.addColorStop */
  void addColorStop(num offset, String color);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CanvasPattern
interface CanvasPattern {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CanvasRenderingContext
interface CanvasRenderingContext {

  /** @domName CanvasRenderingContext.canvas */
  final CanvasElement canvas;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CanvasRenderingContext2D
interface CanvasRenderingContext2D extends CanvasRenderingContext {

  /** @domName CanvasRenderingContext2D.fillStyle */
  Dynamic fillStyle;

  /** @domName CanvasRenderingContext2D.font */
  String font;

  /** @domName CanvasRenderingContext2D.globalAlpha */
  num globalAlpha;

  /** @domName CanvasRenderingContext2D.globalCompositeOperation */
  String globalCompositeOperation;

  /** @domName CanvasRenderingContext2D.lineCap */
  String lineCap;

  /** @domName CanvasRenderingContext2D.lineJoin */
  String lineJoin;

  /** @domName CanvasRenderingContext2D.lineWidth */
  num lineWidth;

  /** @domName CanvasRenderingContext2D.miterLimit */
  num miterLimit;

  /** @domName CanvasRenderingContext2D.shadowBlur */
  num shadowBlur;

  /** @domName CanvasRenderingContext2D.shadowColor */
  String shadowColor;

  /** @domName CanvasRenderingContext2D.shadowOffsetX */
  num shadowOffsetX;

  /** @domName CanvasRenderingContext2D.shadowOffsetY */
  num shadowOffsetY;

  /** @domName CanvasRenderingContext2D.strokeStyle */
  Dynamic strokeStyle;

  /** @domName CanvasRenderingContext2D.textAlign */
  String textAlign;

  /** @domName CanvasRenderingContext2D.textBaseline */
  String textBaseline;

  /** @domName CanvasRenderingContext2D.webkitBackingStorePixelRatio */
  final num webkitBackingStorePixelRatio;

  /** @domName CanvasRenderingContext2D.webkitLineDash */
  List webkitLineDash;

  /** @domName CanvasRenderingContext2D.webkitLineDashOffset */
  num webkitLineDashOffset;

  /** @domName CanvasRenderingContext2D.arc */
  void arc(num x, num y, num radius, num startAngle, num endAngle, bool anticlockwise);

  /** @domName CanvasRenderingContext2D.arcTo */
  void arcTo(num x1, num y1, num x2, num y2, num radius);

  /** @domName CanvasRenderingContext2D.beginPath */
  void beginPath();

  /** @domName CanvasRenderingContext2D.bezierCurveTo */
  void bezierCurveTo(num cp1x, num cp1y, num cp2x, num cp2y, num x, num y);

  /** @domName CanvasRenderingContext2D.clearRect */
  void clearRect(num x, num y, num width, num height);

  /** @domName CanvasRenderingContext2D.clearShadow */
  void clearShadow();

  /** @domName CanvasRenderingContext2D.clip */
  void clip();

  /** @domName CanvasRenderingContext2D.closePath */
  void closePath();

  /** @domName CanvasRenderingContext2D.createImageData */
  ImageData createImageData(imagedata_OR_sw, [num sh]);

  /** @domName CanvasRenderingContext2D.createLinearGradient */
  CanvasGradient createLinearGradient(num x0, num y0, num x1, num y1);

  /** @domName CanvasRenderingContext2D.createPattern */
  CanvasPattern createPattern(canvas_OR_image, String repetitionType);

  /** @domName CanvasRenderingContext2D.createRadialGradient */
  CanvasGradient createRadialGradient(num x0, num y0, num r0, num x1, num y1, num r1);

  /** @domName CanvasRenderingContext2D.drawImage */
  void drawImage(canvas_OR_image_OR_video, num sx_OR_x, num sy_OR_y, [num sw_OR_width, num height_OR_sh, num dx, num dy, num dw, num dh]);

  /** @domName CanvasRenderingContext2D.drawImageFromRect */
  void drawImageFromRect(ImageElement image, [num sx, num sy, num sw, num sh, num dx, num dy, num dw, num dh, String compositeOperation]);

  /** @domName CanvasRenderingContext2D.fill */
  void fill();

  /** @domName CanvasRenderingContext2D.fillRect */
  void fillRect(num x, num y, num width, num height);

  /** @domName CanvasRenderingContext2D.fillText */
  void fillText(String text, num x, num y, [num maxWidth]);

  /** @domName CanvasRenderingContext2D.getImageData */
  ImageData getImageData(num sx, num sy, num sw, num sh);

  /** @domName CanvasRenderingContext2D.isPointInPath */
  bool isPointInPath(num x, num y);

  /** @domName CanvasRenderingContext2D.lineTo */
  void lineTo(num x, num y);

  /** @domName CanvasRenderingContext2D.measureText */
  TextMetrics measureText(String text);

  /** @domName CanvasRenderingContext2D.moveTo */
  void moveTo(num x, num y);

  /** @domName CanvasRenderingContext2D.putImageData */
  void putImageData(ImageData imagedata, num dx, num dy, [num dirtyX, num dirtyY, num dirtyWidth, num dirtyHeight]);

  /** @domName CanvasRenderingContext2D.quadraticCurveTo */
  void quadraticCurveTo(num cpx, num cpy, num x, num y);

  /** @domName CanvasRenderingContext2D.rect */
  void rect(num x, num y, num width, num height);

  /** @domName CanvasRenderingContext2D.restore */
  void restore();

  /** @domName CanvasRenderingContext2D.rotate */
  void rotate(num angle);

  /** @domName CanvasRenderingContext2D.save */
  void save();

  /** @domName CanvasRenderingContext2D.scale */
  void scale(num sx, num sy);

  /** @domName CanvasRenderingContext2D.setAlpha */
  void setAlpha(num alpha);

  /** @domName CanvasRenderingContext2D.setCompositeOperation */
  void setCompositeOperation(String compositeOperation);

  /** @domName CanvasRenderingContext2D.setFillColor */
  void setFillColor(c_OR_color_OR_grayLevel_OR_r, [num alpha_OR_g_OR_m, num b_OR_y, num a_OR_k, num a]);

  /** @domName CanvasRenderingContext2D.setLineCap */
  void setLineCap(String cap);

  /** @domName CanvasRenderingContext2D.setLineJoin */
  void setLineJoin(String join);

  /** @domName CanvasRenderingContext2D.setLineWidth */
  void setLineWidth(num width);

  /** @domName CanvasRenderingContext2D.setMiterLimit */
  void setMiterLimit(num limit);

  /** @domName CanvasRenderingContext2D.setShadow */
  void setShadow(num width, num height, num blur, [c_OR_color_OR_grayLevel_OR_r, num alpha_OR_g_OR_m, num b_OR_y, num a_OR_k, num a]);

  /** @domName CanvasRenderingContext2D.setStrokeColor */
  void setStrokeColor(c_OR_color_OR_grayLevel_OR_r, [num alpha_OR_g_OR_m, num b_OR_y, num a_OR_k, num a]);

  /** @domName CanvasRenderingContext2D.setTransform */
  void setTransform(num m11, num m12, num m21, num m22, num dx, num dy);

  /** @domName CanvasRenderingContext2D.stroke */
  void stroke();

  /** @domName CanvasRenderingContext2D.strokeRect */
  void strokeRect(num x, num y, num width, num height, [num lineWidth]);

  /** @domName CanvasRenderingContext2D.strokeText */
  void strokeText(String text, num x, num y, [num maxWidth]);

  /** @domName CanvasRenderingContext2D.transform */
  void transform(num m11, num m12, num m21, num m22, num dx, num dy);

  /** @domName CanvasRenderingContext2D.translate */
  void translate(num tx, num ty);

  /** @domName CanvasRenderingContext2D.webkitGetImageDataHD */
  ImageData webkitGetImageDataHD(num sx, num sy, num sw, num sh);

  /** @domName CanvasRenderingContext2D.webkitPutImageDataHD */
  void webkitPutImageDataHD(ImageData imagedata, num dx, num dy, [num dirtyX, num dirtyY, num dirtyWidth, num dirtyHeight]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CharacterData
interface CharacterData extends Node {

  /** @domName CharacterData.data */
  String data;

  /** @domName CharacterData.length */
  final int length;

  /** @domName CharacterData.appendData */
  void appendData(String data);

  /** @domName CharacterData.deleteData */
  void deleteData(int offset, int length);

  /** @domName CharacterData.insertData */
  void insertData(int offset, String data);

  /** @domName CharacterData.replaceData */
  void replaceData(int offset, int length, String data);

  /** @domName CharacterData.substringData */
  String substringData(int offset, int length);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ClientRect
interface ClientRect {

  /** @domName ClientRect.bottom */
  final num bottom;

  /** @domName ClientRect.height */
  final num height;

  /** @domName ClientRect.left */
  final num left;

  /** @domName ClientRect.right */
  final num right;

  /** @domName ClientRect.top */
  final num top;

  /** @domName ClientRect.width */
  final num width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ClientRectList
interface ClientRectList {

  /** @domName ClientRectList.length */
  final int length;

  /** @domName ClientRectList.item */
  ClientRect item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Clipboard
interface Clipboard {

  /** @domName Clipboard.dropEffect */
  String dropEffect;

  /** @domName Clipboard.effectAllowed */
  String effectAllowed;

  /** @domName Clipboard.files */
  final FileList files;

  /** @domName Clipboard.items */
  final DataTransferItemList items;

  /** @domName Clipboard.types */
  final List types;

  /** @domName Clipboard.clearData */
  void clearData([String type]);

  /** @domName Clipboard.getData */
  String getData(String type);

  /** @domName Clipboard.setData */
  bool setData(String type, String data);

  /** @domName Clipboard.setDragImage */
  void setDragImage(ImageElement image, int x, int y);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CloseEvent
interface CloseEvent extends Event {

  /** @domName CloseEvent.code */
  final int code;

  /** @domName CloseEvent.reason */
  final String reason;

  /** @domName CloseEvent.wasClean */
  final bool wasClean;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Comment
interface Comment extends CharacterData {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CompositionEvent
interface CompositionEvent extends UIEvent {

  /** @domName CompositionEvent.data */
  final String data;

  /** @domName CompositionEvent.initCompositionEvent */
  void initCompositionEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Window viewArg, String dataArg);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Console
interface Console {

  /** @domName Console.memory */
  final MemoryInfo memory;

  /** @domName Console.profiles */
  final List<ScriptProfile> profiles;

  /** @domName Console.assertCondition */
  void assertCondition(bool condition, Object arg);

  /** @domName Console.count */
  void count();

  /** @domName Console.debug */
  void debug(Object arg);

  /** @domName Console.dir */
  void dir();

  /** @domName Console.dirxml */
  void dirxml();

  /** @domName Console.error */
  void error(Object arg);

  /** @domName Console.group */
  void group(Object arg);

  /** @domName Console.groupCollapsed */
  void groupCollapsed(Object arg);

  /** @domName Console.groupEnd */
  void groupEnd();

  /** @domName Console.info */
  void info(Object arg);

  /** @domName Console.log */
  void log(Object arg);

  /** @domName Console.markTimeline */
  void markTimeline();

  /** @domName Console.profile */
  void profile(String title);

  /** @domName Console.profileEnd */
  void profileEnd(String title);

  /** @domName Console.time */
  void time(String title);

  /** @domName Console.timeEnd */
  void timeEnd(String title, Object arg);

  /** @domName Console.timeStamp */
  void timeStamp(Object arg);

  /** @domName Console.trace */
  void trace(Object arg);

  /** @domName Console.warn */
  void warn(Object arg);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLContentElement
interface ContentElement extends Element {

  /** @domName HTMLContentElement.select */
  String select;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ConvolverNode
interface ConvolverNode extends AudioNode {

  /** @domName ConvolverNode.buffer */
  AudioBuffer buffer;

  /** @domName ConvolverNode.normalize */
  bool normalize;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Coordinates
interface Coordinates {

  /** @domName Coordinates.accuracy */
  final num accuracy;

  /** @domName Coordinates.altitude */
  final num altitude;

  /** @domName Coordinates.altitudeAccuracy */
  final num altitudeAccuracy;

  /** @domName Coordinates.heading */
  final num heading;

  /** @domName Coordinates.latitude */
  final num latitude;

  /** @domName Coordinates.longitude */
  final num longitude;

  /** @domName Coordinates.speed */
  final num speed;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Counter
interface Counter {

  /** @domName Counter.identifier */
  final String identifier;

  /** @domName Counter.listStyle */
  final String listStyle;

  /** @domName Counter.separator */
  final String separator;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Crypto
interface Crypto {

  /** @domName Crypto.getRandomValues */
  void getRandomValues(ArrayBufferView array);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName CustomEvent
interface CustomEvent extends Event {

  /** @domName CustomEvent.detail */
  final Object detail;

  /** @domName CustomEvent.initCustomEvent */
  void initCustomEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object detailArg);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLDListElement
interface DListElement extends Element {

  /** @domName HTMLDListElement.compact */
  bool compact;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMApplicationCache
interface DOMApplicationCache extends EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  DOMApplicationCacheEvents get on();

  static final int CHECKING = 2;

  static final int DOWNLOADING = 3;

  static final int IDLE = 1;

  static final int OBSOLETE = 5;

  static final int UNCACHED = 0;

  static final int UPDATEREADY = 4;

  /** @domName DOMApplicationCache.status */
  final int status;

  /** @domName DOMApplicationCache.abort */
  void abort();

  /** @domName DOMApplicationCache.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName DOMApplicationCache.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName DOMApplicationCache.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName DOMApplicationCache.swapCache */
  void swapCache();

  /** @domName DOMApplicationCache.update */
  void update();
}

interface DOMApplicationCacheEvents extends Events {

  EventListenerList get cached();

  EventListenerList get checking();

  EventListenerList get downloading();

  EventListenerList get error();

  EventListenerList get noUpdate();

  EventListenerList get obsolete();

  EventListenerList get progress();

  EventListenerList get updateReady();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMException
interface DOMException {

  static final int ABORT_ERR = 20;

  static final int DATA_CLONE_ERR = 25;

  static final int DOMSTRING_SIZE_ERR = 2;

  static final int HIERARCHY_REQUEST_ERR = 3;

  static final int INDEX_SIZE_ERR = 1;

  static final int INUSE_ATTRIBUTE_ERR = 10;

  static final int INVALID_ACCESS_ERR = 15;

  static final int INVALID_CHARACTER_ERR = 5;

  static final int INVALID_MODIFICATION_ERR = 13;

  static final int INVALID_NODE_TYPE_ERR = 24;

  static final int INVALID_STATE_ERR = 11;

  static final int NAMESPACE_ERR = 14;

  static final int NETWORK_ERR = 19;

  static final int NOT_FOUND_ERR = 8;

  static final int NOT_SUPPORTED_ERR = 9;

  static final int NO_DATA_ALLOWED_ERR = 6;

  static final int NO_MODIFICATION_ALLOWED_ERR = 7;

  static final int QUOTA_EXCEEDED_ERR = 22;

  static final int SECURITY_ERR = 18;

  static final int SYNTAX_ERR = 12;

  static final int TIMEOUT_ERR = 23;

  static final int TYPE_MISMATCH_ERR = 17;

  static final int URL_MISMATCH_ERR = 21;

  static final int VALIDATION_ERR = 16;

  static final int WRONG_DOCUMENT_ERR = 4;

  /** @domName DOMException.code */
  final int code;

  /** @domName DOMException.message */
  final String message;

  /** @domName DOMException.name */
  final String name;

  /** @domName DOMException.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMFileSystem
interface DOMFileSystem {

  /** @domName DOMFileSystem.name */
  final String name;

  /** @domName DOMFileSystem.root */
  final DirectoryEntry root;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMFileSystemSync
interface DOMFileSystemSync {

  /** @domName DOMFileSystemSync.name */
  final String name;

  /** @domName DOMFileSystemSync.root */
  final DirectoryEntrySync root;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMFormData
interface DOMFormData {

  /** @domName DOMFormData.append */
  void append(String name, String value, String filename);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMImplementation
interface DOMImplementation {

  /** @domName DOMImplementation.createCSSStyleSheet */
  CSSStyleSheet createCSSStyleSheet(String title, String media);

  /** @domName DOMImplementation.createDocument */
  Document createDocument(String namespaceURI, String qualifiedName, DocumentType doctype);

  /** @domName DOMImplementation.createDocumentType */
  DocumentType createDocumentType(String qualifiedName, String publicId, String systemId);

  /** @domName DOMImplementation.createHTMLDocument */
  Document createHTMLDocument(String title);

  /** @domName DOMImplementation.hasFeature */
  bool hasFeature(String feature, String version);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMMimeType
interface DOMMimeType {

  /** @domName DOMMimeType.description */
  final String description;

  /** @domName DOMMimeType.enabledPlugin */
  final DOMPlugin enabledPlugin;

  /** @domName DOMMimeType.suffixes */
  final String suffixes;

  /** @domName DOMMimeType.type */
  final String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMMimeTypeArray
interface DOMMimeTypeArray {

  /** @domName DOMMimeTypeArray.length */
  final int length;

  /** @domName DOMMimeTypeArray.item */
  DOMMimeType item(int index);

  /** @domName DOMMimeTypeArray.namedItem */
  DOMMimeType namedItem(String name);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMParser
interface DOMParser default _DOMParserFactoryProvider {

  DOMParser();

  /** @domName DOMParser.parseFromString */
  Document parseFromString(String str, String contentType);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMPlugin
interface DOMPlugin {

  /** @domName DOMPlugin.description */
  final String description;

  /** @domName DOMPlugin.filename */
  final String filename;

  /** @domName DOMPlugin.length */
  final int length;

  /** @domName DOMPlugin.name */
  final String name;

  /** @domName DOMPlugin.item */
  DOMMimeType item(int index);

  /** @domName DOMPlugin.namedItem */
  DOMMimeType namedItem(String name);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMPluginArray
interface DOMPluginArray {

  /** @domName DOMPluginArray.length */
  final int length;

  /** @domName DOMPluginArray.item */
  DOMPlugin item(int index);

  /** @domName DOMPluginArray.namedItem */
  DOMPlugin namedItem(String name);

  /** @domName DOMPluginArray.refresh */
  void refresh(bool reload);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMSelection
interface DOMSelection {

  /** @domName DOMSelection.anchorNode */
  final Node anchorNode;

  /** @domName DOMSelection.anchorOffset */
  final int anchorOffset;

  /** @domName DOMSelection.baseNode */
  final Node baseNode;

  /** @domName DOMSelection.baseOffset */
  final int baseOffset;

  /** @domName DOMSelection.extentNode */
  final Node extentNode;

  /** @domName DOMSelection.extentOffset */
  final int extentOffset;

  /** @domName DOMSelection.focusNode */
  final Node focusNode;

  /** @domName DOMSelection.focusOffset */
  final int focusOffset;

  /** @domName DOMSelection.isCollapsed */
  final bool isCollapsed;

  /** @domName DOMSelection.rangeCount */
  final int rangeCount;

  /** @domName DOMSelection.type */
  final String type;

  /** @domName DOMSelection.addRange */
  void addRange(Range range);

  /** @domName DOMSelection.collapse */
  void collapse(Node node, int index);

  /** @domName DOMSelection.collapseToEnd */
  void collapseToEnd();

  /** @domName DOMSelection.collapseToStart */
  void collapseToStart();

  /** @domName DOMSelection.containsNode */
  bool containsNode(Node node, bool allowPartial);

  /** @domName DOMSelection.deleteFromDocument */
  void deleteFromDocument();

  /** @domName DOMSelection.empty */
  void empty();

  /** @domName DOMSelection.extend */
  void extend(Node node, int offset);

  /** @domName DOMSelection.getRangeAt */
  Range getRangeAt(int index);

  /** @domName DOMSelection.modify */
  void modify(String alter, String direction, String granularity);

  /** @domName DOMSelection.removeAllRanges */
  void removeAllRanges();

  /** @domName DOMSelection.selectAllChildren */
  void selectAllChildren(Node node);

  /** @domName DOMSelection.setBaseAndExtent */
  void setBaseAndExtent(Node baseNode, int baseOffset, Node extentNode, int extentOffset);

  /** @domName DOMSelection.setPosition */
  void setPosition(Node node, int offset);

  /** @domName DOMSelection.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMSettableTokenList
interface DOMSettableTokenList extends DOMTokenList {

  /** @domName DOMSettableTokenList.value */
  String value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMStringList
interface DOMStringList extends List<String> {

  /** @domName DOMStringList.length */
  final int length;

  /** @domName DOMStringList.contains */
  bool contains(String string);

  /** @domName DOMStringList.item */
  String item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMTokenList
interface DOMTokenList {

  /** @domName DOMTokenList.length */
  final int length;

  /** @domName DOMTokenList.add */
  void add(String token);

  /** @domName DOMTokenList.contains */
  bool contains(String token);

  /** @domName DOMTokenList.item */
  String item(int index);

  /** @domName DOMTokenList.remove */
  void remove(String token);

  /** @domName DOMTokenList.toString */
  String toString();

  /** @domName DOMTokenList.toggle */
  bool toggle(String token);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMURL
interface DOMURL default _DOMURLFactoryProvider {

  DOMURL();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DataTransferItem
interface DataTransferItem {

  /** @domName DataTransferItem.kind */
  final String kind;

  /** @domName DataTransferItem.type */
  final String type;

  /** @domName DataTransferItem.getAsFile */
  Blob getAsFile();

  /** @domName DataTransferItem.getAsString */
  void getAsString([StringCallback callback]);

  /** @domName DataTransferItem.webkitGetAsEntry */
  void webkitGetAsEntry([EntryCallback callback]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DataTransferItemList
interface DataTransferItemList {

  /** @domName DataTransferItemList.length */
  final int length;

  /** @domName DataTransferItemList.add */
  void add(data_OR_file, [String type]);

  /** @domName DataTransferItemList.clear */
  void clear();

  /** @domName DataTransferItemList.item */
  DataTransferItem item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DataView
interface DataView extends ArrayBufferView {

  /** @domName DataView.getFloat32 */
  num getFloat32(int byteOffset, [bool littleEndian]);

  /** @domName DataView.getFloat64 */
  num getFloat64(int byteOffset, [bool littleEndian]);

  /** @domName DataView.getInt16 */
  int getInt16(int byteOffset, [bool littleEndian]);

  /** @domName DataView.getInt32 */
  int getInt32(int byteOffset, [bool littleEndian]);

  /** @domName DataView.getInt8 */
  Object getInt8();

  /** @domName DataView.getUint16 */
  int getUint16(int byteOffset, [bool littleEndian]);

  /** @domName DataView.getUint32 */
  int getUint32(int byteOffset, [bool littleEndian]);

  /** @domName DataView.getUint8 */
  Object getUint8();

  /** @domName DataView.setFloat32 */
  void setFloat32(int byteOffset, num value, [bool littleEndian]);

  /** @domName DataView.setFloat64 */
  void setFloat64(int byteOffset, num value, [bool littleEndian]);

  /** @domName DataView.setInt16 */
  void setInt16(int byteOffset, int value, [bool littleEndian]);

  /** @domName DataView.setInt32 */
  void setInt32(int byteOffset, int value, [bool littleEndian]);

  /** @domName DataView.setInt8 */
  void setInt8();

  /** @domName DataView.setUint16 */
  void setUint16(int byteOffset, int value, [bool littleEndian]);

  /** @domName DataView.setUint32 */
  void setUint32(int byteOffset, int value, [bool littleEndian]);

  /** @domName DataView.setUint8 */
  void setUint8();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Database
interface Database {

  /** @domName Database.version */
  final String version;

  /** @domName Database.changeVersion */
  void changeVersion(String oldVersion, String newVersion, [SQLTransactionCallback callback, SQLTransactionErrorCallback errorCallback, VoidCallback successCallback]);

  /** @domName Database.readTransaction */
  void readTransaction(SQLTransactionCallback callback, [SQLTransactionErrorCallback errorCallback, VoidCallback successCallback]);

  /** @domName Database.transaction */
  void transaction(SQLTransactionCallback callback, [SQLTransactionErrorCallback errorCallback, VoidCallback successCallback]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool DatabaseCallback(database);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DatabaseSync
interface DatabaseSync {

  /** @domName DatabaseSync.lastErrorMessage */
  final String lastErrorMessage;

  /** @domName DatabaseSync.version */
  final String version;

  /** @domName DatabaseSync.changeVersion */
  void changeVersion(String oldVersion, String newVersion, [SQLTransactionSyncCallback callback]);

  /** @domName DatabaseSync.readTransaction */
  void readTransaction(SQLTransactionSyncCallback callback);

  /** @domName DatabaseSync.transaction */
  void transaction(SQLTransactionSyncCallback callback);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DedicatedWorkerContext
interface DedicatedWorkerContext extends WorkerContext {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  DedicatedWorkerContextEvents get on();

  /** @domName DedicatedWorkerContext.postMessage */
  void postMessage(Object message, [List messagePorts]);

  /** @domName DedicatedWorkerContext.webkitPostMessage */
  void webkitPostMessage(Object message, [List transferList]);
}

interface DedicatedWorkerContextEvents extends WorkerContextEvents {

  EventListenerList get message();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DelayNode
interface DelayNode extends AudioNode {

  /** @domName DelayNode.delayTime */
  final AudioParam delayTime;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DeprecatedPeerConnection
interface DeprecatedPeerConnection extends EventTarget default _DeprecatedPeerConnectionFactoryProvider {

  DeprecatedPeerConnection(String serverConfiguration, SignalingCallback signalingCallback);

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  DeprecatedPeerConnectionEvents get on();

  static final int ACTIVE = 2;

  static final int CLOSED = 3;

  static final int NEGOTIATING = 1;

  static final int NEW = 0;

  /** @domName DeprecatedPeerConnection.localStreams */
  final MediaStreamList localStreams;

  /** @domName DeprecatedPeerConnection.readyState */
  final int readyState;

  /** @domName DeprecatedPeerConnection.remoteStreams */
  final MediaStreamList remoteStreams;

  /** @domName DeprecatedPeerConnection.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName DeprecatedPeerConnection.addStream */
  void addStream(MediaStream stream);

  /** @domName DeprecatedPeerConnection.close */
  void close();

  /** @domName DeprecatedPeerConnection.dispatchEvent */
  bool $dom_dispatchEvent(Event event);

  /** @domName DeprecatedPeerConnection.processSignalingMessage */
  void processSignalingMessage(String message);

  /** @domName DeprecatedPeerConnection.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName DeprecatedPeerConnection.removeStream */
  void removeStream(MediaStream stream);

  /** @domName DeprecatedPeerConnection.send */
  void send(String text);
}

interface DeprecatedPeerConnectionEvents extends Events {

  EventListenerList get addStream();

  EventListenerList get connecting();

  EventListenerList get message();

  EventListenerList get open();

  EventListenerList get removeStream();

  EventListenerList get stateChange();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLDetailsElement
interface DetailsElement extends Element {

  /** @domName HTMLDetailsElement.open */
  bool open;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DeviceMotionEvent
interface DeviceMotionEvent extends Event {

  /** @domName DeviceMotionEvent.interval */
  final num interval;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DeviceOrientationEvent
interface DeviceOrientationEvent extends Event {

  /** @domName DeviceOrientationEvent.absolute */
  final bool absolute;

  /** @domName DeviceOrientationEvent.alpha */
  final num alpha;

  /** @domName DeviceOrientationEvent.beta */
  final num beta;

  /** @domName DeviceOrientationEvent.gamma */
  final num gamma;

  /** @domName DeviceOrientationEvent.initDeviceOrientationEvent */
  void initDeviceOrientationEvent(String type, bool bubbles, bool cancelable, num alpha, num beta, num gamma, bool absolute);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLDirectoryElement
interface DirectoryElement extends Element {

  /** @domName HTMLDirectoryElement.compact */
  bool compact;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DirectoryEntry
interface DirectoryEntry extends Entry {

  /** @domName DirectoryEntry.createReader */
  DirectoryReader createReader();

  /** @domName DirectoryEntry.getDirectory */
  void getDirectory(String path, [Object flags, EntryCallback successCallback, ErrorCallback errorCallback]);

  /** @domName DirectoryEntry.getFile */
  void getFile(String path, [Object flags, EntryCallback successCallback, ErrorCallback errorCallback]);

  /** @domName DirectoryEntry.removeRecursively */
  void removeRecursively(VoidCallback successCallback, [ErrorCallback errorCallback]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DirectoryEntrySync
interface DirectoryEntrySync extends EntrySync {

  /** @domName DirectoryEntrySync.createReader */
  DirectoryReaderSync createReader();

  /** @domName DirectoryEntrySync.getDirectory */
  DirectoryEntrySync getDirectory(String path, Object flags);

  /** @domName DirectoryEntrySync.getFile */
  FileEntrySync getFile(String path, Object flags);

  /** @domName DirectoryEntrySync.removeRecursively */
  void removeRecursively();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DirectoryReader
interface DirectoryReader {

  /** @domName DirectoryReader.readEntries */
  void readEntries(EntriesCallback successCallback, [ErrorCallback errorCallback]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DirectoryReaderSync
interface DirectoryReaderSync {

  /** @domName DirectoryReaderSync.readEntries */
  EntryArraySync readEntries();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLDivElement
interface DivElement extends Element {

  /** @domName HTMLDivElement.align */
  String align;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/// @domName Document
interface Document extends HtmlElement {


  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  DocumentEvents get on();

  /** @domName HTMLDocument.activeElement */
  final Element activeElement;

  /** @domName Document.body */
  Element body;

  /** @domName Document.charset */
  String charset;

  /** @domName Document.cookie */
  String cookie;

  /** @domName Document.defaultView */
  final Window window;

  /** @domName Document.documentElement */
  final Element documentElement;

  /** @domName Document.domain */
  final String domain;

  /** @domName Document.head */
  final HeadElement head;

  /** @domName Document.lastModified */
  final String lastModified;

  /** @domName Document.preferredStylesheetSet */
  final String preferredStylesheetSet;

  /** @domName Document.readyState */
  final String readyState;

  /** @domName Document.referrer */
  final String referrer;

  /** @domName Document.selectedStylesheetSet */
  String selectedStylesheetSet;

  /** @domName Document.styleSheets */
  final StyleSheetList styleSheets;

  /** @domName Document.title */
  String title;

  /** @domName Document.webkitCurrentFullScreenElement */
  final Element webkitCurrentFullScreenElement;

  /** @domName Document.webkitFullScreenKeyboardInputAllowed */
  final bool webkitFullScreenKeyboardInputAllowed;

  /** @domName Document.webkitFullscreenElement */
  final Element webkitFullscreenElement;

  /** @domName Document.webkitFullscreenEnabled */
  final bool webkitFullscreenEnabled;

  /** @domName Document.webkitHidden */
  final bool webkitHidden;

  /** @domName Document.webkitIsFullScreen */
  final bool webkitIsFullScreen;

  /** @domName Document.webkitVisibilityState */
  final String webkitVisibilityState;

  /** @domName Document.caretRangeFromPoint */
  Range caretRangeFromPoint(int x, int y);

  /** @domName Document.createCDATASection */
  CDATASection createCDATASection(String data);

  /** @domName Document.createDocumentFragment */
  DocumentFragment createDocumentFragment();

  /** @domName Document.createElement */
  Element $dom_createElement(String tagName);

  /** @domName Document.createElementNS */
  Element $dom_createElementNS(String namespaceURI, String qualifiedName);

  /** @domName Document.createEvent */
  Event $dom_createEvent(String eventType);

  /** @domName Document.createRange */
  Range createRange();

  /** @domName Document.createTextNode */
  Text $dom_createTextNode(String data);

  /** @domName Document.createTouch */
  Touch createTouch(Window window, EventTarget target, int identifier, int pageX, int pageY, int screenX, int screenY, int webkitRadiusX, int webkitRadiusY, num webkitRotationAngle, num webkitForce);

  /** @domName Document.createTouchList */
  TouchList $dom_createTouchList();

  /** @domName Document.elementFromPoint */
  Element elementFromPoint(int x, int y);

  /** @domName Document.execCommand */
  bool execCommand(String command, bool userInterface, String value);

  /** @domName Document.getCSSCanvasContext */
  CanvasRenderingContext getCSSCanvasContext(String contextId, String name, int width, int height);

  /** @domName Document.getElementById */
  Element $dom_getElementById(String elementId);

  /** @domName Document.getElementsByClassName */
  NodeList $dom_getElementsByClassName(String tagname);

  /** @domName Document.getElementsByName */
  NodeList $dom_getElementsByName(String elementName);

  /** @domName Document.getElementsByTagName */
  NodeList $dom_getElementsByTagName(String tagname);

  /** @domName Document.queryCommandEnabled */
  bool queryCommandEnabled(String command);

  /** @domName Document.queryCommandIndeterm */
  bool queryCommandIndeterm(String command);

  /** @domName Document.queryCommandState */
  bool queryCommandState(String command);

  /** @domName Document.queryCommandSupported */
  bool queryCommandSupported(String command);

  /** @domName Document.queryCommandValue */
  String queryCommandValue(String command);

  /** @domName Document.querySelector */
  Element query(String selectors);

  /** @domName Document.querySelectorAll */
  NodeList $dom_querySelectorAll(String selectors);

  /** @domName Document.webkitCancelFullScreen */
  void webkitCancelFullScreen();

  /** @domName Document.webkitExitFullscreen */
  void webkitExitFullscreen();

  /** @domName Document.webkitGetFlowByName */
  WebKitNamedFlow webkitGetFlowByName(String name);

}

interface DocumentEvents extends ElementEvents {

  EventListenerList get abort();

  EventListenerList get beforeCopy();

  EventListenerList get beforeCut();

  EventListenerList get beforePaste();

  EventListenerList get blur();

  EventListenerList get change();

  EventListenerList get click();

  EventListenerList get contextMenu();

  EventListenerList get copy();

  EventListenerList get cut();

  EventListenerList get doubleClick();

  EventListenerList get drag();

  EventListenerList get dragEnd();

  EventListenerList get dragEnter();

  EventListenerList get dragLeave();

  EventListenerList get dragOver();

  EventListenerList get dragStart();

  EventListenerList get drop();

  EventListenerList get error();

  EventListenerList get focus();

  EventListenerList get fullscreenChange();

  EventListenerList get fullscreenError();

  EventListenerList get input();

  EventListenerList get invalid();

  EventListenerList get keyDown();

  EventListenerList get keyPress();

  EventListenerList get keyUp();

  EventListenerList get load();

  EventListenerList get mouseDown();

  EventListenerList get mouseMove();

  EventListenerList get mouseOut();

  EventListenerList get mouseOver();

  EventListenerList get mouseUp();

  EventListenerList get mouseWheel();

  EventListenerList get paste();

  EventListenerList get readyStateChange();

  EventListenerList get reset();

  EventListenerList get scroll();

  EventListenerList get search();

  EventListenerList get select();

  EventListenerList get selectStart();

  EventListenerList get selectionChange();

  EventListenerList get submit();

  EventListenerList get touchCancel();

  EventListenerList get touchEnd();

  EventListenerList get touchMove();

  EventListenerList get touchStart();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/// @domName DocumentFragment
interface DocumentFragment extends Element default _DocumentFragmentFactoryProvider {

  DocumentFragment();

  DocumentFragment.html(String html);

  // TODO(nweiz): enable this when XML is ported
  // /** WARNING: Currently this doesn't work on Dartium (issue 649). */
  // DocumentFragment.xml(String xml);

  DocumentFragment.svg(String svg);

  DocumentFragment clone(bool deep);


  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  ElementEvents get on();

  /** @domName DocumentFragment.querySelector */
  Element query(String selectors);

  /** @domName DocumentFragment.querySelectorAll */
  NodeList $dom_querySelectorAll(String selectors);

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DocumentType
interface DocumentType extends Node {

  /** @domName DocumentType.entities */
  final NamedNodeMap entities;

  /** @domName DocumentType.internalSubset */
  final String internalSubset;

  /** @domName DocumentType.name */
  final String name;

  /** @domName DocumentType.notations */
  final NamedNodeMap notations;

  /** @domName DocumentType.publicId */
  final String publicId;

  /** @domName DocumentType.systemId */
  final String systemId;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DynamicsCompressorNode
interface DynamicsCompressorNode extends AudioNode {

  /** @domName DynamicsCompressorNode.attack */
  final AudioParam attack;

  /** @domName DynamicsCompressorNode.knee */
  final AudioParam knee;

  /** @domName DynamicsCompressorNode.ratio */
  final AudioParam ratio;

  /** @domName DynamicsCompressorNode.reduction */
  final AudioParam reduction;

  /** @domName DynamicsCompressorNode.release */
  final AudioParam release;

  /** @domName DynamicsCompressorNode.threshold */
  final AudioParam threshold;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName EXTTextureFilterAnisotropic
interface EXTTextureFilterAnisotropic {

  static final int MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84FF;

  static final int TEXTURE_MAX_ANISOTROPY_EXT = 0x84FE;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface ElementList extends List<Element> {
  // TODO(jacobr): add element batch manipulation methods.
  ElementList filter(bool f(Element element));

  ElementList getRange(int start, int length);

  Element get first();
  // TODO(jacobr): add insertAt
}

/**
 * All your attribute manipulation needs in one place.
 * Extends the regular Map interface by automatically coercing non-string
 * values to strings.
 */
interface AttributeMap extends Map<String, String> {
  void operator []=(String key, value);
}

/**
 * All your element measurement needs in one place
 */
interface ElementRect {
  // Relative to offsetParent
  ClientRect get client();
  ClientRect get offset();
  ClientRect get scroll();
  // In global coords
  ClientRect get bounding();
  // In global coords
  List<ClientRect> get clientRects();
}

/// @domName Element
interface Element extends Node, NodeSelector default _ElementFactoryProvider {
// TODO(jacobr): switch back to:
// interface Element extends Node, NodeSelector, ElementTraversal default _ElementImpl {
  Element.html(String html);
  Element.tag(String tag);

  AttributeMap get attributes();
  void set attributes(Map<String, String> value);

  /**
   * @domName querySelectorAll, getElementsByClassName, getElementsByTagName,
   *   getElementsByTagNameNS
   */
  ElementList queryAll(String selectors);

  /**
   * @domName childElementCount, firstElementChild, lastElementChild,
   *   children, Node.nodes.add
   */
  ElementList get elements();

  void set elements(Collection<Element> value);

  /** @domName className, classList */
  Set<String> get classes();

  void set classes(Collection<String> value);

  AttributeMap get dataAttributes();
  void set dataAttributes(Map<String, String> value);

  /**
   * @domName getClientRects, getBoundingClientRect, clientHeight, clientWidth,
   * clientTop, clientLeft, offsetHeight, offsetWidth, offsetTop, offsetLeft,
   * scrollHeight, scrollWidth, scrollTop, scrollLeft
   */
  Future<ElementRect> get rect();

  /** @domName Window.getComputedStyle */
  Future<CSSStyleDeclaration> get computedStyle();

  /** @domName Window.getComputedStyle */
  Future<CSSStyleDeclaration> getComputedStyle(String pseudoElement);

  Element clone(bool deep);

  Element get parent();


  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  ElementEvents get on();

  static final int ALLOW_KEYBOARD_INPUT = 1;

  /** @domName Element.childElementCount */
  final int $dom_childElementCount;

  /** @domName HTMLElement.children */
  final HTMLCollection $dom_children;

  /** @domName HTMLElement.className */
  String $dom_className;

  /** @domName Element.clientHeight */
  final int $dom_clientHeight;

  /** @domName Element.clientLeft */
  final int $dom_clientLeft;

  /** @domName Element.clientTop */
  final int $dom_clientTop;

  /** @domName Element.clientWidth */
  final int $dom_clientWidth;

  /** @domName HTMLElement.contentEditable */
  String contentEditable;

  /** @domName Element.dataset */
  final Map<String, String> dataset;

  /** @domName HTMLElement.dir */
  String dir;

  /** @domName HTMLElement.draggable */
  bool draggable;

  /** @domName Element.firstElementChild */
  final Element $dom_firstElementChild;

  /** @domName HTMLElement.hidden */
  bool hidden;

  /** @domName HTMLElement.id */
  String id;

  /** @domName HTMLElement.innerHTML */
  String innerHTML;

  /** @domName HTMLElement.isContentEditable */
  final bool isContentEditable;

  /** @domName HTMLElement.lang */
  String lang;

  /** @domName Element.lastElementChild */
  final Element $dom_lastElementChild;

  /** @domName Element.nextElementSibling */
  final Element nextElementSibling;

  /** @domName Element.offsetHeight */
  final int $dom_offsetHeight;

  /** @domName Element.offsetLeft */
  final int $dom_offsetLeft;

  /** @domName Element.offsetParent */
  final Element offsetParent;

  /** @domName Element.offsetTop */
  final int $dom_offsetTop;

  /** @domName Element.offsetWidth */
  final int $dom_offsetWidth;

  /** @domName HTMLElement.outerHTML */
  final String outerHTML;

  /** @domName Element.previousElementSibling */
  final Element previousElementSibling;

  /** @domName Element.scrollHeight */
  final int $dom_scrollHeight;

  /** @domName Element.scrollLeft */
  int $dom_scrollLeft;

  /** @domName Element.scrollTop */
  int $dom_scrollTop;

  /** @domName Element.scrollWidth */
  final int $dom_scrollWidth;

  /** @domName HTMLElement.spellcheck */
  bool spellcheck;

  /** @domName Element.style */
  final CSSStyleDeclaration style;

  /** @domName HTMLElement.tabIndex */
  int tabIndex;

  /** @domName Element.tagName */
  final String tagName;

  /** @domName HTMLElement.title */
  String title;

  /** @domName HTMLElement.translate */
  bool translate;

  /** @domName Element.webkitRegionOverflow */
  final String webkitRegionOverflow;

  /** @domName HTMLElement.webkitdropzone */
  String webkitdropzone;

  /** @domName Element.blur */
  void blur();

  /** @domName HTMLElement.click */
  void click();

  /** @domName Element.focus */
  void focus();

  /** @domName Element.getAttribute */
  String $dom_getAttribute(String name);

  /** @domName Element.getBoundingClientRect */
  ClientRect $dom_getBoundingClientRect();

  /** @domName Element.getClientRects */
  ClientRectList $dom_getClientRects();

  /** @domName Element.getElementsByClassName */
  NodeList $dom_getElementsByClassName(String name);

  /** @domName Element.getElementsByTagName */
  NodeList $dom_getElementsByTagName(String name);

  /** @domName Element.hasAttribute */
  bool $dom_hasAttribute(String name);

  /** @domName HTMLElement.insertAdjacentElement */
  Element insertAdjacentElement(String where, Element element);

  /** @domName HTMLElement.insertAdjacentHTML */
  void insertAdjacentHTML(String where, String html);

  /** @domName HTMLElement.insertAdjacentText */
  void insertAdjacentText(String where, String text);

  /** @domName Element.querySelector */
  Element query(String selectors);

  /** @domName Element.querySelectorAll */
  NodeList $dom_querySelectorAll(String selectors);

  /** @domName Element.removeAttribute */
  void $dom_removeAttribute(String name);

  /** @domName Element.scrollByLines */
  void scrollByLines(int lines);

  /** @domName Element.scrollByPages */
  void scrollByPages(int pages);

  /** @domName Element.scrollIntoViewIfNeeded */
  void scrollIntoView([bool centerIfNeeded]);

  /** @domName Element.setAttribute */
  void $dom_setAttribute(String name, String value);

  /** @domName Element.webkitMatchesSelector */
  bool matchesSelector(String selectors);

  /** @domName Element.webkitRequestFullScreen */
  void webkitRequestFullScreen(int flags);

  /** @domName Element.webkitRequestFullscreen */
  void webkitRequestFullscreen();

}

interface ElementEvents extends Events {

  EventListenerList get abort();

  EventListenerList get beforeCopy();

  EventListenerList get beforeCut();

  EventListenerList get beforePaste();

  EventListenerList get blur();

  EventListenerList get change();

  EventListenerList get click();

  EventListenerList get contextMenu();

  EventListenerList get copy();

  EventListenerList get cut();

  EventListenerList get doubleClick();

  EventListenerList get drag();

  EventListenerList get dragEnd();

  EventListenerList get dragEnter();

  EventListenerList get dragLeave();

  EventListenerList get dragOver();

  EventListenerList get dragStart();

  EventListenerList get drop();

  EventListenerList get error();

  EventListenerList get focus();

  EventListenerList get fullscreenChange();

  EventListenerList get fullscreenError();

  EventListenerList get input();

  EventListenerList get invalid();

  EventListenerList get keyDown();

  EventListenerList get keyPress();

  EventListenerList get keyUp();

  EventListenerList get load();

  EventListenerList get mouseDown();

  EventListenerList get mouseMove();

  EventListenerList get mouseOut();

  EventListenerList get mouseOver();

  EventListenerList get mouseUp();

  EventListenerList get mouseWheel();

  EventListenerList get paste();

  EventListenerList get reset();

  EventListenerList get scroll();

  EventListenerList get search();

  EventListenerList get select();

  EventListenerList get selectStart();

  EventListenerList get submit();

  EventListenerList get touchCancel();

  EventListenerList get touchEnd();

  EventListenerList get touchEnter();

  EventListenerList get touchLeave();

  EventListenerList get touchMove();

  EventListenerList get touchStart();

  EventListenerList get transitionEnd();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ElementTimeControl
interface ElementTimeControl {

  /** @domName ElementTimeControl.beginElement */
  void beginElement();

  /** @domName ElementTimeControl.beginElementAt */
  void beginElementAt(num offset);

  /** @domName ElementTimeControl.endElement */
  void endElement();

  /** @domName ElementTimeControl.endElementAt */
  void endElementAt(num offset);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ElementTraversal
interface ElementTraversal {

  /** @domName ElementTraversal.childElementCount */
  final int childElementCount;

  /** @domName ElementTraversal.firstElementChild */
  final Element firstElementChild;

  /** @domName ElementTraversal.lastElementChild */
  final Element lastElementChild;

  /** @domName ElementTraversal.nextElementSibling */
  final Element nextElementSibling;

  /** @domName ElementTraversal.previousElementSibling */
  final Element previousElementSibling;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLEmbedElement
interface EmbedElement extends Element {

  /** @domName HTMLEmbedElement.align */
  String align;

  /** @domName HTMLEmbedElement.height */
  String height;

  /** @domName HTMLEmbedElement.name */
  String name;

  /** @domName HTMLEmbedElement.src */
  String src;

  /** @domName HTMLEmbedElement.type */
  String type;

  /** @domName HTMLEmbedElement.width */
  String width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Entity
interface Entity extends Node {

  /** @domName Entity.notationName */
  final String notationName;

  /** @domName Entity.publicId */
  final String publicId;

  /** @domName Entity.systemId */
  final String systemId;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName EntityReference
interface EntityReference extends Node {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool EntriesCallback(EntryArray entries);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Entry
interface Entry {

  /** @domName Entry.filesystem */
  final DOMFileSystem filesystem;

  /** @domName Entry.fullPath */
  final String fullPath;

  /** @domName Entry.isDirectory */
  final bool isDirectory;

  /** @domName Entry.isFile */
  final bool isFile;

  /** @domName Entry.name */
  final String name;

  /** @domName Entry.copyTo */
  void copyTo(DirectoryEntry parent, [String name, EntryCallback successCallback, ErrorCallback errorCallback]);

  /** @domName Entry.getMetadata */
  void getMetadata(MetadataCallback successCallback, [ErrorCallback errorCallback]);

  /** @domName Entry.getParent */
  void getParent([EntryCallback successCallback, ErrorCallback errorCallback]);

  /** @domName Entry.moveTo */
  void moveTo(DirectoryEntry parent, [String name, EntryCallback successCallback, ErrorCallback errorCallback]);

  /** @domName Entry.remove */
  void remove(VoidCallback successCallback, [ErrorCallback errorCallback]);

  /** @domName Entry.toURL */
  String toURL();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName EntryArray
interface EntryArray {

  /** @domName EntryArray.length */
  final int length;

  /** @domName EntryArray.item */
  Entry item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName EntryArraySync
interface EntryArraySync {

  /** @domName EntryArraySync.length */
  final int length;

  /** @domName EntryArraySync.item */
  EntrySync item(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool EntryCallback(Entry entry);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName EntrySync
interface EntrySync {

  /** @domName EntrySync.filesystem */
  final DOMFileSystemSync filesystem;

  /** @domName EntrySync.fullPath */
  final String fullPath;

  /** @domName EntrySync.isDirectory */
  final bool isDirectory;

  /** @domName EntrySync.isFile */
  final bool isFile;

  /** @domName EntrySync.name */
  final String name;

  /** @domName EntrySync.copyTo */
  EntrySync copyTo(DirectoryEntrySync parent, String name);

  /** @domName EntrySync.getMetadata */
  Metadata getMetadata();

  /** @domName EntrySync.getParent */
  EntrySync getParent();

  /** @domName EntrySync.moveTo */
  EntrySync moveTo(DirectoryEntrySync parent, String name);

  /** @domName EntrySync.remove */
  void remove();

  /** @domName EntrySync.toURL */
  String toURL();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool ErrorCallback(FileError error);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ErrorEvent
interface ErrorEvent extends Event {

  /** @domName ErrorEvent.filename */
  final String filename;

  /** @domName ErrorEvent.lineno */
  final int lineno;

  /** @domName ErrorEvent.message */
  final String message;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Event
interface Event default _EventFactoryProvider {

  // In JS, canBubble and cancelable are technically required parameters to
  // init*Event. In practice, though, if they aren't provided they simply
  // default to false (since that's Boolean(undefined)).
  //
  // Contrary to JS, we default canBubble and cancelable to true, since that's
  // what people want most of the time anyway.
  Event(String type, [bool canBubble, bool cancelable]);

  static final int AT_TARGET = 2;

  static final int BLUR = 8192;

  static final int BUBBLING_PHASE = 3;

  static final int CAPTURING_PHASE = 1;

  static final int CHANGE = 32768;

  static final int CLICK = 64;

  static final int DBLCLICK = 128;

  static final int DRAGDROP = 2048;

  static final int FOCUS = 4096;

  static final int KEYDOWN = 256;

  static final int KEYPRESS = 1024;

  static final int KEYUP = 512;

  static final int MOUSEDOWN = 1;

  static final int MOUSEDRAG = 32;

  static final int MOUSEMOVE = 16;

  static final int MOUSEOUT = 8;

  static final int MOUSEOVER = 4;

  static final int MOUSEUP = 2;

  static final int SELECT = 16384;

  /** @domName Event.bubbles */
  final bool bubbles;

  /** @domName Event.cancelBubble */
  bool cancelBubble;

  /** @domName Event.cancelable */
  final bool cancelable;

  /** @domName Event.clipboardData */
  final Clipboard clipboardData;

  /** @domName Event.currentTarget */
  final EventTarget currentTarget;

  /** @domName Event.defaultPrevented */
  final bool defaultPrevented;

  /** @domName Event.eventPhase */
  final int eventPhase;

  /** @domName Event.returnValue */
  bool returnValue;

  /** @domName Event.srcElement */
  final EventTarget srcElement;

  /** @domName Event.target */
  final EventTarget target;

  /** @domName Event.timeStamp */
  final int timeStamp;

  /** @domName Event.type */
  final String type;

  /** @domName Event.initEvent */
  void $dom_initEvent(String eventTypeArg, bool canBubbleArg, bool cancelableArg);

  /** @domName Event.preventDefault */
  void preventDefault();

  /** @domName Event.stopImmediatePropagation */
  void stopImmediatePropagation();

  /** @domName Event.stopPropagation */
  void stopPropagation();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName EventException
interface EventException {

  static final int DISPATCH_REQUEST_ERR = 1;

  static final int UNSPECIFIED_EVENT_TYPE_ERR = 0;

  /** @domName EventException.code */
  final int code;

  /** @domName EventException.message */
  final String message;

  /** @domName EventException.name */
  final String name;

  /** @domName EventException.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName EventSource
interface EventSource extends EventTarget default _EventSourceFactoryProvider {

  EventSource(String scriptUrl);

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  EventSourceEvents get on();

  static final int CLOSED = 2;

  static final int CONNECTING = 0;

  static final int OPEN = 1;

  /** @domName EventSource.URL */
  final String URL;

  /** @domName EventSource.readyState */
  final int readyState;

  /** @domName EventSource.url */
  final String url;

  /** @domName EventSource.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName EventSource.close */
  void close();

  /** @domName EventSource.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName EventSource.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

interface EventSourceEvents extends Events {

  EventListenerList get error();

  EventListenerList get message();

  EventListenerList get open();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

interface EventListenerList {
  EventListenerList add(EventListener handler, [bool useCapture]);

  EventListenerList remove(EventListener handler, [bool useCapture]);

  bool dispatch(Event evt);
}

interface Events {
  EventListenerList operator [](String type);
}

/// @domName EventTarget
interface EventTarget {

  /** @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent */
  final Events on;

  /** @domName EventTarget.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName EventTarget.dispatchEvent */
  bool $dom_dispatchEvent(Event event);

  /** @domName EventTarget.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLFieldSetElement
interface FieldSetElement extends Element {

  /** @domName HTMLFieldSetElement.disabled */
  bool disabled;

  /** @domName HTMLFieldSetElement.form */
  final FormElement form;

  /** @domName HTMLFieldSetElement.name */
  String name;

  /** @domName HTMLFieldSetElement.type */
  final String type;

  /** @domName HTMLFieldSetElement.validationMessage */
  final String validationMessage;

  /** @domName HTMLFieldSetElement.validity */
  final ValidityState validity;

  /** @domName HTMLFieldSetElement.willValidate */
  final bool willValidate;

  /** @domName HTMLFieldSetElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLFieldSetElement.setCustomValidity */
  void setCustomValidity(String error);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName File
interface File extends Blob {

  /** @domName File.lastModifiedDate */
  final Date lastModifiedDate;

  /** @domName File.name */
  final String name;

  /** @domName File.webkitRelativePath */
  final String webkitRelativePath;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool FileCallback(File file);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FileEntry
interface FileEntry extends Entry {

  /** @domName FileEntry.createWriter */
  void createWriter(FileWriterCallback successCallback, [ErrorCallback errorCallback]);

  /** @domName FileEntry.file */
  void file(FileCallback successCallback, [ErrorCallback errorCallback]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FileEntrySync
interface FileEntrySync extends EntrySync {

  /** @domName FileEntrySync.createWriter */
  FileWriterSync createWriter();

  /** @domName FileEntrySync.file */
  File file();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FileError
interface FileError {

  static final int ABORT_ERR = 3;

  static final int ENCODING_ERR = 5;

  static final int INVALID_MODIFICATION_ERR = 9;

  static final int INVALID_STATE_ERR = 7;

  static final int NOT_FOUND_ERR = 1;

  static final int NOT_READABLE_ERR = 4;

  static final int NO_MODIFICATION_ALLOWED_ERR = 6;

  static final int PATH_EXISTS_ERR = 12;

  static final int QUOTA_EXCEEDED_ERR = 10;

  static final int SECURITY_ERR = 2;

  static final int SYNTAX_ERR = 8;

  static final int TYPE_MISMATCH_ERR = 11;

  /** @domName FileError.code */
  final int code;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FileException
interface FileException {

  static final int ABORT_ERR = 3;

  static final int ENCODING_ERR = 5;

  static final int INVALID_MODIFICATION_ERR = 9;

  static final int INVALID_STATE_ERR = 7;

  static final int NOT_FOUND_ERR = 1;

  static final int NOT_READABLE_ERR = 4;

  static final int NO_MODIFICATION_ALLOWED_ERR = 6;

  static final int PATH_EXISTS_ERR = 12;

  static final int QUOTA_EXCEEDED_ERR = 10;

  static final int SECURITY_ERR = 2;

  static final int SYNTAX_ERR = 8;

  static final int TYPE_MISMATCH_ERR = 11;

  /** @domName FileException.code */
  final int code;

  /** @domName FileException.message */
  final String message;

  /** @domName FileException.name */
  final String name;

  /** @domName FileException.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FileList
interface FileList extends List<File> {

  /** @domName FileList.length */
  final int length;

  /** @domName FileList.item */
  File item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FileReader
interface FileReader extends EventTarget default _FileReaderFactoryProvider {

  FileReader();

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  FileReaderEvents get on();

  static final int DONE = 2;

  static final int EMPTY = 0;

  static final int LOADING = 1;

  /** @domName FileReader.error */
  final FileError error;

  /** @domName FileReader.readyState */
  final int readyState;

  /** @domName FileReader.result */
  final Object result;

  /** @domName FileReader.abort */
  void abort();

  /** @domName FileReader.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName FileReader.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName FileReader.readAsArrayBuffer */
  void readAsArrayBuffer(Blob blob);

  /** @domName FileReader.readAsBinaryString */
  void readAsBinaryString(Blob blob);

  /** @domName FileReader.readAsDataURL */
  void readAsDataURL(Blob blob);

  /** @domName FileReader.readAsText */
  void readAsText(Blob blob, [String encoding]);

  /** @domName FileReader.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

interface FileReaderEvents extends Events {

  EventListenerList get abort();

  EventListenerList get error();

  EventListenerList get load();

  EventListenerList get loadEnd();

  EventListenerList get loadStart();

  EventListenerList get progress();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FileReaderSync
interface FileReaderSync default _FileReaderSyncFactoryProvider {

  FileReaderSync();

  /** @domName FileReaderSync.readAsArrayBuffer */
  ArrayBuffer readAsArrayBuffer(Blob blob);

  /** @domName FileReaderSync.readAsBinaryString */
  String readAsBinaryString(Blob blob);

  /** @domName FileReaderSync.readAsDataURL */
  String readAsDataURL(Blob blob);

  /** @domName FileReaderSync.readAsText */
  String readAsText(Blob blob, [String encoding]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool FileSystemCallback(DOMFileSystem fileSystem);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FileWriter
interface FileWriter extends EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  FileWriterEvents get on();

  static final int DONE = 2;

  static final int INIT = 0;

  static final int WRITING = 1;

  /** @domName FileWriter.error */
  final FileError error;

  /** @domName FileWriter.length */
  final int length;

  /** @domName FileWriter.position */
  final int position;

  /** @domName FileWriter.readyState */
  final int readyState;

  /** @domName FileWriter.abort */
  void abort();

  /** @domName FileWriter.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName FileWriter.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName FileWriter.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName FileWriter.seek */
  void seek(int position);

  /** @domName FileWriter.truncate */
  void truncate(int size);

  /** @domName FileWriter.write */
  void write(Blob data);
}

interface FileWriterEvents extends Events {

  EventListenerList get abort();

  EventListenerList get error();

  EventListenerList get progress();

  EventListenerList get write();

  EventListenerList get writeEnd();

  EventListenerList get writeStart();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool FileWriterCallback(FileWriter fileWriter);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName FileWriterSync
interface FileWriterSync {

  /** @domName FileWriterSync.length */
  final int length;

  /** @domName FileWriterSync.position */
  final int position;

  /** @domName FileWriterSync.seek */
  void seek(int position);

  /** @domName FileWriterSync.truncate */
  void truncate(int size);

  /** @domName FileWriterSync.write */
  void write(Blob data);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Float32Array
interface Float32Array extends ArrayBufferView, List<num> default _TypedArrayFactoryProvider {

  Float32Array(int length);

  Float32Array.fromList(List<num> list);

  Float32Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]);

  static final int BYTES_PER_ELEMENT = 4;

  /** @domName Float32Array.length */
  final int length;

  /** @domName Float32Array.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Float32Array.subarray */
  Float32Array subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Float64Array
interface Float64Array extends ArrayBufferView, List<num> default _TypedArrayFactoryProvider {

  Float64Array(int length);

  Float64Array.fromList(List<num> list);

  Float64Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]);

  static final int BYTES_PER_ELEMENT = 8;

  /** @domName Float64Array.length */
  final int length;

  /** @domName Float64Array.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Float64Array.subarray */
  Float64Array subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLFontElement
interface FontElement extends Element {

  /** @domName HTMLFontElement.color */
  String color;

  /** @domName HTMLFontElement.face */
  String face;

  /** @domName HTMLFontElement.size */
  String size;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLFormElement
interface FormElement extends Element {

  /** @domName HTMLFormElement.acceptCharset */
  String acceptCharset;

  /** @domName HTMLFormElement.action */
  String action;

  /** @domName HTMLFormElement.autocomplete */
  String autocomplete;

  /** @domName HTMLFormElement.encoding */
  String encoding;

  /** @domName HTMLFormElement.enctype */
  String enctype;

  /** @domName HTMLFormElement.length */
  final int length;

  /** @domName HTMLFormElement.method */
  String method;

  /** @domName HTMLFormElement.name */
  String name;

  /** @domName HTMLFormElement.noValidate */
  bool noValidate;

  /** @domName HTMLFormElement.target */
  String target;

  /** @domName HTMLFormElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLFormElement.reset */
  void reset();

  /** @domName HTMLFormElement.submit */
  void submit();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLFrameElement
interface FrameElement extends Element {

  /** @domName HTMLFrameElement.contentDocument */
  final Document contentDocument;

  /** @domName HTMLFrameElement.contentWindow */
  final Window contentWindow;

  /** @domName HTMLFrameElement.frameBorder */
  String frameBorder;

  /** @domName HTMLFrameElement.height */
  final int height;

  /** @domName HTMLFrameElement.location */
  String location;

  /** @domName HTMLFrameElement.longDesc */
  String longDesc;

  /** @domName HTMLFrameElement.marginHeight */
  String marginHeight;

  /** @domName HTMLFrameElement.marginWidth */
  String marginWidth;

  /** @domName HTMLFrameElement.name */
  String name;

  /** @domName HTMLFrameElement.noResize */
  bool noResize;

  /** @domName HTMLFrameElement.scrolling */
  String scrolling;

  /** @domName HTMLFrameElement.src */
  String src;

  /** @domName HTMLFrameElement.width */
  final int width;

  /** @domName HTMLFrameElement.getSVGDocument */
  SVGDocument getSVGDocument();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLFrameSetElement
interface FrameSetElement extends Element {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  FrameSetElementEvents get on();

  /** @domName HTMLFrameSetElement.cols */
  String cols;

  /** @domName HTMLFrameSetElement.rows */
  String rows;
}

interface FrameSetElementEvents extends ElementEvents {

  EventListenerList get beforeUnload();

  EventListenerList get blur();

  EventListenerList get error();

  EventListenerList get focus();

  EventListenerList get hashChange();

  EventListenerList get load();

  EventListenerList get message();

  EventListenerList get offline();

  EventListenerList get online();

  EventListenerList get popState();

  EventListenerList get resize();

  EventListenerList get storage();

  EventListenerList get unload();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Geolocation
interface Geolocation {

  /** @domName Geolocation.clearWatch */
  void clearWatch(int watchId);

  /** @domName Geolocation.getCurrentPosition */
  void getCurrentPosition(PositionCallback successCallback, [PositionErrorCallback errorCallback]);

  /** @domName Geolocation.watchPosition */
  int watchPosition(PositionCallback successCallback, [PositionErrorCallback errorCallback]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Geoposition
interface Geoposition {

  /** @domName Geoposition.coords */
  final Coordinates coords;

  /** @domName Geoposition.timestamp */
  final int timestamp;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLHRElement
interface HRElement extends Element {

  /** @domName HTMLHRElement.align */
  String align;

  /** @domName HTMLHRElement.noShade */
  bool noShade;

  /** @domName HTMLHRElement.size */
  String size;

  /** @domName HTMLHRElement.width */
  String width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLAllCollection
interface HTMLAllCollection {

  /** @domName HTMLAllCollection.length */
  final int length;

  /** @domName HTMLAllCollection.item */
  Node item(int index);

  /** @domName HTMLAllCollection.namedItem */
  Node namedItem(String name);

  /** @domName HTMLAllCollection.tags */
  NodeList tags(String name);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLCollection
interface HTMLCollection extends List<Node> {

  /** @domName HTMLCollection.length */
  final int length;

  /** @domName HTMLCollection.item */
  Node item(int index);

  /** @domName HTMLCollection.namedItem */
  Node namedItem(String name);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLOptionsCollection
interface HTMLOptionsCollection extends HTMLCollection {

  /** @domName HTMLOptionsCollection.length */
  int length;

  /** @domName HTMLOptionsCollection.selectedIndex */
  int selectedIndex;

  /** @domName HTMLOptionsCollection.remove */
  void remove(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HashChangeEvent
interface HashChangeEvent extends Event {

  /** @domName HashChangeEvent.newURL */
  final String newURL;

  /** @domName HashChangeEvent.oldURL */
  final String oldURL;

  /** @domName HashChangeEvent.initHashChangeEvent */
  void initHashChangeEvent(String type, bool canBubble, bool cancelable, String oldURL, String newURL);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLHeadElement
interface HeadElement extends Element {

  /** @domName HTMLHeadElement.profile */
  String profile;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLHeadingElement
interface HeadingElement extends Element {

  /** @domName HTMLHeadingElement.align */
  String align;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName History
interface History {

  /** @domName History.length */
  final int length;

  /** @domName History.state */
  final Dynamic state;

  /** @domName History.back */
  void back();

  /** @domName History.forward */
  void forward();

  /** @domName History.go */
  void go(int distance);

  /** @domName History.pushState */
  void pushState(Object data, String title, [String url]);

  /** @domName History.replaceState */
  void replaceState(Object data, String title, [String url]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLHtmlElement
interface HtmlElement extends Element {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBAny
interface IDBAny {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBCursor
interface IDBCursor {

  static final int NEXT = 0;

  static final int NEXT_NO_DUPLICATE = 1;

  static final int PREV = 2;

  static final int PREV_NO_DUPLICATE = 3;

  /** @domName IDBCursor.direction */
  final int direction;

  /** @domName IDBCursor.key */
  final Dynamic key;

  /** @domName IDBCursor.primaryKey */
  final Dynamic primaryKey;

  /** @domName IDBCursor.source */
  final Dynamic source;

  /** @domName IDBCursor.advance */
  void advance(int count);

  /** @domName IDBCursor.continueFunction */
  void continueFunction([/*IDBKey*/ key]);

  /** @domName IDBCursor.delete */
  IDBRequest delete();

  /** @domName IDBCursor.update */
  IDBRequest update(/*SerializedScriptValue*/ value);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBCursorWithValue
interface IDBCursorWithValue extends IDBCursor {

  /** @domName IDBCursorWithValue.value */
  final Dynamic value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBDatabase
interface IDBDatabase extends EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  IDBDatabaseEvents get on();

  /** @domName IDBDatabase.name */
  final String name;

  /** @domName IDBDatabase.objectStoreNames */
  final List<String> objectStoreNames;

  /** @domName IDBDatabase.version */
  final String version;

  /** @domName IDBDatabase.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName IDBDatabase.close */
  void close();

  /** @domName IDBDatabase.createObjectStore */
  IDBObjectStore createObjectStore(String name, [Map options]);

  /** @domName IDBDatabase.deleteObjectStore */
  void deleteObjectStore(String name);

  /** @domName IDBDatabase.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName IDBDatabase.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName IDBDatabase.setVersion */
  IDBVersionChangeRequest setVersion(String version);

  /** @domName IDBDatabase.transaction */
  IDBTransaction transaction(storeName_OR_storeNames, [int mode]);
}

interface IDBDatabaseEvents extends Events {

  EventListenerList get abort();

  EventListenerList get error();

  EventListenerList get versionChange();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBDatabaseException
interface IDBDatabaseException {

  static final int ABORT_ERR = 8;

  static final int CONSTRAINT_ERR = 4;

  static final int DATA_ERR = 5;

  static final int NON_TRANSIENT_ERR = 2;

  static final int NOT_ALLOWED_ERR = 6;

  static final int NOT_FOUND_ERR = 3;

  static final int NO_ERR = 0;

  static final int QUOTA_ERR = 11;

  static final int READ_ONLY_ERR = 9;

  static final int TIMEOUT_ERR = 10;

  static final int TRANSACTION_INACTIVE_ERR = 7;

  static final int UNKNOWN_ERR = 1;

  static final int VER_ERR = 12;

  /** @domName IDBDatabaseException.code */
  final int code;

  /** @domName IDBDatabaseException.message */
  final String message;

  /** @domName IDBDatabaseException.name */
  final String name;

  /** @domName IDBDatabaseException.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBFactory
interface IDBFactory {

  /** @domName IDBFactory.cmp */
  int cmp(/*IDBKey*/ first, /*IDBKey*/ second);

  /** @domName IDBFactory.deleteDatabase */
  IDBVersionChangeRequest deleteDatabase(String name);

  /** @domName IDBFactory.getDatabaseNames */
  IDBRequest getDatabaseNames();

  /** @domName IDBFactory.open */
  IDBRequest open(String name);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBIndex
interface IDBIndex {

  /** @domName IDBIndex.keyPath */
  final String keyPath;

  /** @domName IDBIndex.multiEntry */
  final bool multiEntry;

  /** @domName IDBIndex.name */
  final String name;

  /** @domName IDBIndex.objectStore */
  final IDBObjectStore objectStore;

  /** @domName IDBIndex.unique */
  final bool unique;

  /** @domName IDBIndex.count */
  IDBRequest count([key_OR_range]);

  /** @domName IDBIndex.get */
  IDBRequest get(key);

  /** @domName IDBIndex.getKey */
  IDBRequest getKey(key);

  /** @domName IDBIndex.openCursor */
  IDBRequest openCursor([key_OR_range, int direction]);

  /** @domName IDBIndex.openKeyCursor */
  IDBRequest openKeyCursor([key_OR_range, int direction]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBKey
interface IDBKey {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBKeyRange
interface IDBKeyRange default _IDBKeyRangeFactoryProvider {

  /**
   * @domName IDBKeyRange.only
   */
  IDBKeyRange.only(/*IDBKey*/ value);

  /**
   * @domName IDBKeyRange.lowerBound
   */
  IDBKeyRange.lowerBound(/*IDBKey*/ bound, [bool open]);

  /**
   * @domName IDBKeyRange.upperBound
   */
  IDBKeyRange.upperBound(/*IDBKey*/ bound, [bool open]);

  /**
   * @domName IDBKeyRange.bound
   */
  IDBKeyRange.bound(/*IDBKey*/ lower, /*IDBKey*/ upper,
                    [bool lowerOpen, bool upperOpen]);


  /** @domName IDBKeyRange.lower */
  final Dynamic lower;

  /** @domName IDBKeyRange.lowerOpen */
  final bool lowerOpen;

  /** @domName IDBKeyRange.upper */
  final Dynamic upper;

  /** @domName IDBKeyRange.upperOpen */
  final bool upperOpen;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBObjectStore
interface IDBObjectStore {

  /** @domName IDBObjectStore.indexNames */
  final List<String> indexNames;

  /** @domName IDBObjectStore.keyPath */
  final String keyPath;

  /** @domName IDBObjectStore.name */
  final String name;

  /** @domName IDBObjectStore.transaction */
  final IDBTransaction transaction;

  /** @domName IDBObjectStore.add */
  IDBRequest add(/*SerializedScriptValue*/ value, [/*IDBKey*/ key]);

  /** @domName IDBObjectStore.clear */
  IDBRequest clear();

  /** @domName IDBObjectStore.count */
  IDBRequest count([key_OR_range]);

  /** @domName IDBObjectStore.createIndex */
  IDBIndex createIndex(String name, String keyPath, [Map options]);

  /** @domName IDBObjectStore.delete */
  IDBRequest delete(key_OR_keyRange);

  /** @domName IDBObjectStore.deleteIndex */
  void deleteIndex(String name);

  /** @domName IDBObjectStore.getObject */
  IDBRequest getObject(key);

  /** @domName IDBObjectStore.index */
  IDBIndex index(String name);

  /** @domName IDBObjectStore.openCursor */
  IDBRequest openCursor([key_OR_range, int direction]);

  /** @domName IDBObjectStore.put */
  IDBRequest put(/*SerializedScriptValue*/ value, [/*IDBKey*/ key]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBRequest
interface IDBRequest extends EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  IDBRequestEvents get on();

  static final int DONE = 2;

  static final int LOADING = 1;

  /** @domName IDBRequest.errorCode */
  final int errorCode;

  /** @domName IDBRequest.readyState */
  final int readyState;

  /** @domName IDBRequest.result */
  final Dynamic result;

  /** @domName IDBRequest.source */
  final Dynamic source;

  /** @domName IDBRequest.transaction */
  final IDBTransaction transaction;

  /** @domName IDBRequest.webkitErrorMessage */
  final String webkitErrorMessage;

  /** @domName IDBRequest.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName IDBRequest.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName IDBRequest.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

interface IDBRequestEvents extends Events {

  EventListenerList get error();

  EventListenerList get success();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBTransaction
interface IDBTransaction extends EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  IDBTransactionEvents get on();

  static final int READ_ONLY = 0;

  static final int READ_WRITE = 1;

  static final int VERSION_CHANGE = 2;

  /** @domName IDBTransaction.db */
  final IDBDatabase db;

  /** @domName IDBTransaction.mode */
  final int mode;

  /** @domName IDBTransaction.abort */
  void abort();

  /** @domName IDBTransaction.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName IDBTransaction.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName IDBTransaction.objectStore */
  IDBObjectStore objectStore(String name);

  /** @domName IDBTransaction.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

interface IDBTransactionEvents extends Events {

  EventListenerList get abort();

  EventListenerList get complete();

  EventListenerList get error();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBVersionChangeEvent
interface IDBVersionChangeEvent extends Event {

  /** @domName IDBVersionChangeEvent.version */
  final String version;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IDBVersionChangeRequest
interface IDBVersionChangeRequest extends IDBRequest, EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  IDBVersionChangeRequestEvents get on();
}

interface IDBVersionChangeRequestEvents extends IDBRequestEvents {

  EventListenerList get blocked();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLIFrameElement
interface IFrameElement extends Element {

  /** @domName HTMLIFrameElement.align */
  String align;

  /** @domName HTMLIFrameElement.frameBorder */
  String frameBorder;

  /** @domName HTMLIFrameElement.height */
  String height;

  /** @domName HTMLIFrameElement.longDesc */
  String longDesc;

  /** @domName HTMLIFrameElement.marginHeight */
  String marginHeight;

  /** @domName HTMLIFrameElement.marginWidth */
  String marginWidth;

  /** @domName HTMLIFrameElement.name */
  String name;

  /** @domName HTMLIFrameElement.sandbox */
  String sandbox;

  /** @domName HTMLIFrameElement.scrolling */
  String scrolling;

  /** @domName HTMLIFrameElement.src */
  String src;

  /** @domName HTMLIFrameElement.srcdoc */
  String srcdoc;

  /** @domName HTMLIFrameElement.width */
  String width;

  /** @domName HTMLIFrameElement.getSVGDocument */
  SVGDocument getSVGDocument();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool IceCallback(IceCandidate candidate, bool moreToFollow, PeerConnection00 source);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName IceCandidate
interface IceCandidate default _IceCandidateFactoryProvider {

  IceCandidate(String label, String candidateLine);

  /** @domName IceCandidate.label */
  final String label;

  /** @domName IceCandidate.toSdp */
  String toSdp();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ImageData
interface ImageData {

  /** @domName ImageData.data */
  final Uint8ClampedArray data;

  /** @domName ImageData.height */
  final int height;

  /** @domName ImageData.width */
  final int width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLImageElement
interface ImageElement extends Element {

  /** @domName HTMLImageElement.align */
  String align;

  /** @domName HTMLImageElement.alt */
  String alt;

  /** @domName HTMLImageElement.border */
  String border;

  /** @domName HTMLImageElement.complete */
  final bool complete;

  /** @domName HTMLImageElement.crossOrigin */
  String crossOrigin;

  /** @domName HTMLImageElement.height */
  int height;

  /** @domName HTMLImageElement.hspace */
  int hspace;

  /** @domName HTMLImageElement.isMap */
  bool isMap;

  /** @domName HTMLImageElement.longDesc */
  String longDesc;

  /** @domName HTMLImageElement.lowsrc */
  String lowsrc;

  /** @domName HTMLImageElement.name */
  String name;

  /** @domName HTMLImageElement.naturalHeight */
  final int naturalHeight;

  /** @domName HTMLImageElement.naturalWidth */
  final int naturalWidth;

  /** @domName HTMLImageElement.src */
  String src;

  /** @domName HTMLImageElement.useMap */
  String useMap;

  /** @domName HTMLImageElement.vspace */
  int vspace;

  /** @domName HTMLImageElement.width */
  int width;

  /** @domName HTMLImageElement.x */
  final int x;

  /** @domName HTMLImageElement.y */
  final int y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLInputElement
interface InputElement extends Element {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  InputElementEvents get on();

  /** @domName HTMLInputElement.accept */
  String accept;

  /** @domName HTMLInputElement.align */
  String align;

  /** @domName HTMLInputElement.alt */
  String alt;

  /** @domName HTMLInputElement.autocomplete */
  String autocomplete;

  /** @domName HTMLInputElement.autofocus */
  bool autofocus;

  /** @domName HTMLInputElement.checked */
  bool checked;

  /** @domName HTMLInputElement.defaultChecked */
  bool defaultChecked;

  /** @domName HTMLInputElement.defaultValue */
  String defaultValue;

  /** @domName HTMLInputElement.disabled */
  bool disabled;

  /** @domName HTMLInputElement.files */
  final FileList files;

  /** @domName HTMLInputElement.form */
  final FormElement form;

  /** @domName HTMLInputElement.formAction */
  String formAction;

  /** @domName HTMLInputElement.formEnctype */
  String formEnctype;

  /** @domName HTMLInputElement.formMethod */
  String formMethod;

  /** @domName HTMLInputElement.formNoValidate */
  bool formNoValidate;

  /** @domName HTMLInputElement.formTarget */
  String formTarget;

  /** @domName HTMLInputElement.incremental */
  bool incremental;

  /** @domName HTMLInputElement.indeterminate */
  bool indeterminate;

  /** @domName HTMLInputElement.labels */
  final NodeList labels;

  /** @domName HTMLInputElement.max */
  String max;

  /** @domName HTMLInputElement.maxLength */
  int maxLength;

  /** @domName HTMLInputElement.min */
  String min;

  /** @domName HTMLInputElement.multiple */
  bool multiple;

  /** @domName HTMLInputElement.name */
  String name;

  /** @domName HTMLInputElement.pattern */
  String pattern;

  /** @domName HTMLInputElement.placeholder */
  String placeholder;

  /** @domName HTMLInputElement.readOnly */
  bool readOnly;

  /** @domName HTMLInputElement.required */
  bool required;

  /** @domName HTMLInputElement.selectionDirection */
  String selectionDirection;

  /** @domName HTMLInputElement.selectionEnd */
  int selectionEnd;

  /** @domName HTMLInputElement.selectionStart */
  int selectionStart;

  /** @domName HTMLInputElement.size */
  int size;

  /** @domName HTMLInputElement.src */
  String src;

  /** @domName HTMLInputElement.step */
  String step;

  /** @domName HTMLInputElement.type */
  String type;

  /** @domName HTMLInputElement.useMap */
  String useMap;

  /** @domName HTMLInputElement.validationMessage */
  final String validationMessage;

  /** @domName HTMLInputElement.validity */
  final ValidityState validity;

  /** @domName HTMLInputElement.value */
  String value;

  /** @domName HTMLInputElement.valueAsDate */
  Date valueAsDate;

  /** @domName HTMLInputElement.valueAsNumber */
  num valueAsNumber;

  /** @domName HTMLInputElement.webkitGrammar */
  bool webkitGrammar;

  /** @domName HTMLInputElement.webkitSpeech */
  bool webkitSpeech;

  /** @domName HTMLInputElement.webkitdirectory */
  bool webkitdirectory;

  /** @domName HTMLInputElement.willValidate */
  final bool willValidate;

  /** @domName HTMLInputElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLInputElement.select */
  void select();

  /** @domName HTMLInputElement.setCustomValidity */
  void setCustomValidity(String error);

  /** @domName HTMLInputElement.setSelectionRange */
  void setSelectionRange(int start, int end, [String direction]);

  /** @domName HTMLInputElement.stepDown */
  void stepDown([int n]);

  /** @domName HTMLInputElement.stepUp */
  void stepUp([int n]);
}

interface InputElementEvents extends ElementEvents {

  EventListenerList get speechChange();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Int16Array
interface Int16Array extends ArrayBufferView, List<int> default _TypedArrayFactoryProvider {

  Int16Array(int length);

  Int16Array.fromList(List<int> list);

  Int16Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]);

  static final int BYTES_PER_ELEMENT = 2;

  /** @domName Int16Array.length */
  final int length;

  /** @domName Int16Array.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Int16Array.subarray */
  Int16Array subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Int32Array
interface Int32Array extends ArrayBufferView, List<int> default _TypedArrayFactoryProvider {

  Int32Array(int length);

  Int32Array.fromList(List<int> list);

  Int32Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]);

  static final int BYTES_PER_ELEMENT = 4;

  /** @domName Int32Array.length */
  final int length;

  /** @domName Int32Array.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Int32Array.subarray */
  Int32Array subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Int8Array
interface Int8Array extends ArrayBufferView, List<int> default _TypedArrayFactoryProvider {

  Int8Array(int length);

  Int8Array.fromList(List<int> list);

  Int8Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]);

  static final int BYTES_PER_ELEMENT = 1;

  /** @domName Int8Array.length */
  final int length;

  /** @domName Int8Array.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Int8Array.subarray */
  Int8Array subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName JavaScriptAudioNode
interface JavaScriptAudioNode extends AudioNode, EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  JavaScriptAudioNodeEvents get on();

  /** @domName JavaScriptAudioNode.bufferSize */
  final int bufferSize;
}

interface JavaScriptAudioNodeEvents extends Events {

  EventListenerList get audioProcess();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName JavaScriptCallFrame
interface JavaScriptCallFrame {

  static final int CATCH_SCOPE = 4;

  static final int CLOSURE_SCOPE = 3;

  static final int GLOBAL_SCOPE = 0;

  static final int LOCAL_SCOPE = 1;

  static final int WITH_SCOPE = 2;

  /** @domName JavaScriptCallFrame.caller */
  final JavaScriptCallFrame caller;

  /** @domName JavaScriptCallFrame.column */
  final int column;

  /** @domName JavaScriptCallFrame.functionName */
  final String functionName;

  /** @domName JavaScriptCallFrame.line */
  final int line;

  /** @domName JavaScriptCallFrame.scopeChain */
  final List scopeChain;

  /** @domName JavaScriptCallFrame.sourceID */
  final int sourceID;

  /** @domName JavaScriptCallFrame.thisObject */
  final Object thisObject;

  /** @domName JavaScriptCallFrame.type */
  final String type;

  /** @domName JavaScriptCallFrame.evaluate */
  void evaluate(String script);

  /** @domName JavaScriptCallFrame.scopeType */
  int scopeType(int scopeIndex);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName KeyboardEvent
interface KeyboardEvent extends UIEvent {

  /** @domName KeyboardEvent.altGraphKey */
  final bool altGraphKey;

  /** @domName KeyboardEvent.altKey */
  final bool altKey;

  /** @domName KeyboardEvent.ctrlKey */
  final bool ctrlKey;

  /** @domName KeyboardEvent.keyIdentifier */
  final String keyIdentifier;

  /** @domName KeyboardEvent.keyLocation */
  final int keyLocation;

  /** @domName KeyboardEvent.metaKey */
  final bool metaKey;

  /** @domName KeyboardEvent.shiftKey */
  final bool shiftKey;

  /** @domName KeyboardEvent.initKeyboardEvent */
  void initKeyboardEvent(String type, bool canBubble, bool cancelable, Window view, String keyIdentifier, int keyLocation, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, bool altGraphKey);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLKeygenElement
interface KeygenElement extends Element {

  /** @domName HTMLKeygenElement.autofocus */
  bool autofocus;

  /** @domName HTMLKeygenElement.challenge */
  String challenge;

  /** @domName HTMLKeygenElement.disabled */
  bool disabled;

  /** @domName HTMLKeygenElement.form */
  final FormElement form;

  /** @domName HTMLKeygenElement.keytype */
  String keytype;

  /** @domName HTMLKeygenElement.labels */
  final NodeList labels;

  /** @domName HTMLKeygenElement.name */
  String name;

  /** @domName HTMLKeygenElement.type */
  final String type;

  /** @domName HTMLKeygenElement.validationMessage */
  final String validationMessage;

  /** @domName HTMLKeygenElement.validity */
  final ValidityState validity;

  /** @domName HTMLKeygenElement.willValidate */
  final bool willValidate;

  /** @domName HTMLKeygenElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLKeygenElement.setCustomValidity */
  void setCustomValidity(String error);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLLIElement
interface LIElement extends Element {

  /** @domName HTMLLIElement.type */
  String type;

  /** @domName HTMLLIElement.value */
  int value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLLabelElement
interface LabelElement extends Element {

  /** @domName HTMLLabelElement.control */
  final Element control;

  /** @domName HTMLLabelElement.form */
  final FormElement form;

  /** @domName HTMLLabelElement.htmlFor */
  String htmlFor;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLLegendElement
interface LegendElement extends Element {

  /** @domName HTMLLegendElement.align */
  String align;

  /** @domName HTMLLegendElement.form */
  final FormElement form;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLLinkElement
interface LinkElement extends Element {

  /** @domName HTMLLinkElement.charset */
  String charset;

  /** @domName HTMLLinkElement.disabled */
  bool disabled;

  /** @domName HTMLLinkElement.href */
  String href;

  /** @domName HTMLLinkElement.hreflang */
  String hreflang;

  /** @domName HTMLLinkElement.media */
  String media;

  /** @domName HTMLLinkElement.rel */
  String rel;

  /** @domName HTMLLinkElement.rev */
  String rev;

  /** @domName HTMLLinkElement.sheet */
  final StyleSheet sheet;

  /** @domName HTMLLinkElement.sizes */
  DOMSettableTokenList sizes;

  /** @domName HTMLLinkElement.target */
  String target;

  /** @domName HTMLLinkElement.type */
  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName LocalMediaStream
interface LocalMediaStream extends MediaStream {

  /** @domName LocalMediaStream.stop */
  void stop();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Location
interface Location {

  /** @domName Location.ancestorOrigins */
  final List<String> ancestorOrigins;

  /** @domName Location.hash */
  String hash;

  /** @domName Location.host */
  String host;

  /** @domName Location.hostname */
  String hostname;

  /** @domName Location.href */
  String href;

  /** @domName Location.origin */
  final String origin;

  /** @domName Location.pathname */
  String pathname;

  /** @domName Location.port */
  String port;

  /** @domName Location.protocol */
  String protocol;

  /** @domName Location.search */
  String search;

  /** @domName Location.assign */
  void assign(String url);

  /** @domName Location.reload */
  void reload();

  /** @domName Location.replace */
  void replace(String url);

  /** @domName Location.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLMapElement
interface MapElement extends Element {

  /** @domName HTMLMapElement.areas */
  final HTMLCollection areas;

  /** @domName HTMLMapElement.name */
  String name;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLMarqueeElement
interface MarqueeElement extends Element {

  /** @domName HTMLMarqueeElement.behavior */
  String behavior;

  /** @domName HTMLMarqueeElement.bgColor */
  String bgColor;

  /** @domName HTMLMarqueeElement.direction */
  String direction;

  /** @domName HTMLMarqueeElement.height */
  String height;

  /** @domName HTMLMarqueeElement.hspace */
  int hspace;

  /** @domName HTMLMarqueeElement.loop */
  int loop;

  /** @domName HTMLMarqueeElement.scrollAmount */
  int scrollAmount;

  /** @domName HTMLMarqueeElement.scrollDelay */
  int scrollDelay;

  /** @domName HTMLMarqueeElement.trueSpeed */
  bool trueSpeed;

  /** @domName HTMLMarqueeElement.vspace */
  int vspace;

  /** @domName HTMLMarqueeElement.width */
  String width;

  /** @domName HTMLMarqueeElement.start */
  void start();

  /** @domName HTMLMarqueeElement.stop */
  void stop();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaController
interface MediaController extends EventTarget default _MediaControllerFactoryProvider {

  MediaController();

  /** @domName MediaController.buffered */
  final TimeRanges buffered;

  /** @domName MediaController.currentTime */
  num currentTime;

  /** @domName MediaController.defaultPlaybackRate */
  num defaultPlaybackRate;

  /** @domName MediaController.duration */
  final num duration;

  /** @domName MediaController.muted */
  bool muted;

  /** @domName MediaController.paused */
  final bool paused;

  /** @domName MediaController.playbackRate */
  num playbackRate;

  /** @domName MediaController.played */
  final TimeRanges played;

  /** @domName MediaController.seekable */
  final TimeRanges seekable;

  /** @domName MediaController.volume */
  num volume;

  /** @domName MediaController.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName MediaController.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName MediaController.pause */
  void pause();

  /** @domName MediaController.play */
  void play();

  /** @domName MediaController.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLMediaElement
interface MediaElement extends Element {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  MediaElementEvents get on();

  static final int EOS_DECODE_ERR = 2;

  static final int EOS_NETWORK_ERR = 1;

  static final int EOS_NO_ERROR = 0;

  static final int HAVE_CURRENT_DATA = 2;

  static final int HAVE_ENOUGH_DATA = 4;

  static final int HAVE_FUTURE_DATA = 3;

  static final int HAVE_METADATA = 1;

  static final int HAVE_NOTHING = 0;

  static final int NETWORK_EMPTY = 0;

  static final int NETWORK_IDLE = 1;

  static final int NETWORK_LOADING = 2;

  static final int NETWORK_NO_SOURCE = 3;

  static final int SOURCE_CLOSED = 0;

  static final int SOURCE_ENDED = 2;

  static final int SOURCE_OPEN = 1;

  /** @domName HTMLMediaElement.autoplay */
  bool autoplay;

  /** @domName HTMLMediaElement.buffered */
  final TimeRanges buffered;

  /** @domName HTMLMediaElement.controller */
  MediaController controller;

  /** @domName HTMLMediaElement.controls */
  bool controls;

  /** @domName HTMLMediaElement.currentSrc */
  final String currentSrc;

  /** @domName HTMLMediaElement.currentTime */
  num currentTime;

  /** @domName HTMLMediaElement.defaultMuted */
  bool defaultMuted;

  /** @domName HTMLMediaElement.defaultPlaybackRate */
  num defaultPlaybackRate;

  /** @domName HTMLMediaElement.duration */
  final num duration;

  /** @domName HTMLMediaElement.ended */
  final bool ended;

  /** @domName HTMLMediaElement.error */
  final MediaError error;

  /** @domName HTMLMediaElement.initialTime */
  final num initialTime;

  /** @domName HTMLMediaElement.loop */
  bool loop;

  /** @domName HTMLMediaElement.mediaGroup */
  String mediaGroup;

  /** @domName HTMLMediaElement.muted */
  bool muted;

  /** @domName HTMLMediaElement.networkState */
  final int networkState;

  /** @domName HTMLMediaElement.paused */
  final bool paused;

  /** @domName HTMLMediaElement.playbackRate */
  num playbackRate;

  /** @domName HTMLMediaElement.played */
  final TimeRanges played;

  /** @domName HTMLMediaElement.preload */
  String preload;

  /** @domName HTMLMediaElement.readyState */
  final int readyState;

  /** @domName HTMLMediaElement.seekable */
  final TimeRanges seekable;

  /** @domName HTMLMediaElement.seeking */
  final bool seeking;

  /** @domName HTMLMediaElement.src */
  String src;

  /** @domName HTMLMediaElement.startTime */
  final num startTime;

  /** @domName HTMLMediaElement.textTracks */
  final TextTrackList textTracks;

  /** @domName HTMLMediaElement.volume */
  num volume;

  /** @domName HTMLMediaElement.webkitAudioDecodedByteCount */
  final int webkitAudioDecodedByteCount;

  /** @domName HTMLMediaElement.webkitClosedCaptionsVisible */
  bool webkitClosedCaptionsVisible;

  /** @domName HTMLMediaElement.webkitHasClosedCaptions */
  final bool webkitHasClosedCaptions;

  /** @domName HTMLMediaElement.webkitMediaSourceURL */
  final String webkitMediaSourceURL;

  /** @domName HTMLMediaElement.webkitPreservesPitch */
  bool webkitPreservesPitch;

  /** @domName HTMLMediaElement.webkitSourceState */
  final int webkitSourceState;

  /** @domName HTMLMediaElement.webkitVideoDecodedByteCount */
  final int webkitVideoDecodedByteCount;

  /** @domName HTMLMediaElement.addTextTrack */
  TextTrack addTextTrack(String kind, [String label, String language]);

  /** @domName HTMLMediaElement.canPlayType */
  String canPlayType(String type, String keySystem);

  /** @domName HTMLMediaElement.load */
  void load();

  /** @domName HTMLMediaElement.pause */
  void pause();

  /** @domName HTMLMediaElement.play */
  void play();

  /** @domName HTMLMediaElement.webkitAddKey */
  void webkitAddKey(String keySystem, Uint8Array key, [Uint8Array initData, String sessionId]);

  /** @domName HTMLMediaElement.webkitCancelKeyRequest */
  void webkitCancelKeyRequest(String keySystem, String sessionId);

  /** @domName HTMLMediaElement.webkitGenerateKeyRequest */
  void webkitGenerateKeyRequest(String keySystem, [Uint8Array initData]);

  /** @domName HTMLMediaElement.webkitSourceAppend */
  void webkitSourceAppend(Uint8Array data);

  /** @domName HTMLMediaElement.webkitSourceEndOfStream */
  void webkitSourceEndOfStream(int status);
}

interface MediaElementEvents extends ElementEvents {

  EventListenerList get keyAdded();

  EventListenerList get keyError();

  EventListenerList get keyMessage();

  EventListenerList get needKey();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaElementAudioSourceNode
interface MediaElementAudioSourceNode extends AudioSourceNode {

  /** @domName MediaElementAudioSourceNode.mediaElement */
  final MediaElement mediaElement;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaError
interface MediaError {

  static final int MEDIA_ERR_ABORTED = 1;

  static final int MEDIA_ERR_DECODE = 3;

  static final int MEDIA_ERR_ENCRYPTED = 5;

  static final int MEDIA_ERR_NETWORK = 2;

  static final int MEDIA_ERR_SRC_NOT_SUPPORTED = 4;

  /** @domName MediaError.code */
  final int code;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaKeyError
interface MediaKeyError {

  static final int MEDIA_KEYERR_CLIENT = 2;

  static final int MEDIA_KEYERR_DOMAIN = 6;

  static final int MEDIA_KEYERR_HARDWARECHANGE = 5;

  static final int MEDIA_KEYERR_OUTPUT = 4;

  static final int MEDIA_KEYERR_SERVICE = 3;

  static final int MEDIA_KEYERR_UNKNOWN = 1;

  /** @domName MediaKeyError.code */
  final int code;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaKeyEvent
interface MediaKeyEvent extends Event {

  /** @domName MediaKeyEvent.defaultURL */
  final String defaultURL;

  /** @domName MediaKeyEvent.errorCode */
  final MediaKeyError errorCode;

  /** @domName MediaKeyEvent.initData */
  final Uint8Array initData;

  /** @domName MediaKeyEvent.keySystem */
  final String keySystem;

  /** @domName MediaKeyEvent.message */
  final Uint8Array message;

  /** @domName MediaKeyEvent.sessionId */
  final String sessionId;

  /** @domName MediaKeyEvent.systemCode */
  final int systemCode;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaList
interface MediaList extends List<String> {

  /** @domName MediaList.length */
  final int length;

  /** @domName MediaList.mediaText */
  String mediaText;

  /** @domName MediaList.appendMedium */
  void appendMedium(String newMedium);

  /** @domName MediaList.deleteMedium */
  void deleteMedium(String oldMedium);

  /** @domName MediaList.item */
  String item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaQueryList
interface MediaQueryList {

  /** @domName MediaQueryList.matches */
  final bool matches;

  /** @domName MediaQueryList.media */
  final String media;

  /** @domName MediaQueryList.addListener */
  void addListener(MediaQueryListListener listener);

  /** @domName MediaQueryList.removeListener */
  void removeListener(MediaQueryListListener listener);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaQueryListListener
interface MediaQueryListListener {

  /** @domName MediaQueryListListener.queryChanged */
  void queryChanged(MediaQueryList list);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaStream
interface MediaStream extends EventTarget default _MediaStreamFactoryProvider {

  MediaStream(MediaStreamTrackList audioTracks, MediaStreamTrackList videoTracks);

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  MediaStreamEvents get on();

  static final int ENDED = 2;

  static final int LIVE = 1;

  /** @domName MediaStream.audioTracks */
  final MediaStreamTrackList audioTracks;

  /** @domName MediaStream.label */
  final String label;

  /** @domName MediaStream.readyState */
  final int readyState;

  /** @domName MediaStream.videoTracks */
  final MediaStreamTrackList videoTracks;

  /** @domName MediaStream.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName MediaStream.dispatchEvent */
  bool $dom_dispatchEvent(Event event);

  /** @domName MediaStream.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

interface MediaStreamEvents extends Events {

  EventListenerList get ended();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaStreamEvent
interface MediaStreamEvent extends Event {

  /** @domName MediaStreamEvent.stream */
  final MediaStream stream;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaStreamList
interface MediaStreamList {

  /** @domName MediaStreamList.length */
  final int length;

  /** @domName MediaStreamList.item */
  MediaStream item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaStreamTrack
interface MediaStreamTrack {

  /** @domName MediaStreamTrack.enabled */
  bool enabled;

  /** @domName MediaStreamTrack.kind */
  final String kind;

  /** @domName MediaStreamTrack.label */
  final String label;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MediaStreamTrackList
interface MediaStreamTrackList {

  /** @domName MediaStreamTrackList.length */
  final int length;

  /** @domName MediaStreamTrackList.item */
  MediaStreamTrack item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MemoryInfo
interface MemoryInfo {

  /** @domName MemoryInfo.jsHeapSizeLimit */
  final int jsHeapSizeLimit;

  /** @domName MemoryInfo.totalJSHeapSize */
  final int totalJSHeapSize;

  /** @domName MemoryInfo.usedJSHeapSize */
  final int usedJSHeapSize;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLMenuElement
interface MenuElement extends Element {

  /** @domName HTMLMenuElement.compact */
  bool compact;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MessageChannel
interface MessageChannel default _MessageChannelFactoryProvider {

  MessageChannel();

  /** @domName MessageChannel.port1 */
  final MessagePort port1;

  /** @domName MessageChannel.port2 */
  final MessagePort port2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MessageEvent
interface MessageEvent extends Event {

  /** @domName MessageEvent.data */
  final Object data;

  /** @domName MessageEvent.lastEventId */
  final String lastEventId;

  /** @domName MessageEvent.origin */
  final String origin;

  /** @domName MessageEvent.ports */
  final List ports;

  /** @domName MessageEvent.source */
  final Window source;

  /** @domName MessageEvent.initMessageEvent */
  void initMessageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object dataArg, String originArg, String lastEventIdArg, Window sourceArg, List messagePorts);

  /** @domName MessageEvent.webkitInitMessageEvent */
  void webkitInitMessageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Object dataArg, String originArg, String lastEventIdArg, Window sourceArg, List transferables);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MessagePort
interface MessagePort extends EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  MessagePortEvents get on();

  /** @domName MessagePort.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName MessagePort.close */
  void close();

  /** @domName MessagePort.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName MessagePort.postMessage */
  void postMessage(String message, [List messagePorts]);

  /** @domName MessagePort.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName MessagePort.start */
  void start();

  /** @domName MessagePort.webkitPostMessage */
  void webkitPostMessage(String message, [List transfer]);
}

interface MessagePortEvents extends Events {

  EventListenerList get message();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLMetaElement
interface MetaElement extends Element {

  /** @domName HTMLMetaElement.content */
  String content;

  /** @domName HTMLMetaElement.httpEquiv */
  String httpEquiv;

  /** @domName HTMLMetaElement.name */
  String name;

  /** @domName HTMLMetaElement.scheme */
  String scheme;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Metadata
interface Metadata {

  /** @domName Metadata.modificationTime */
  final Date modificationTime;

  /** @domName Metadata.size */
  final int size;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool MetadataCallback(Metadata metadata);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLMeterElement
interface MeterElement extends Element {

  /** @domName HTMLMeterElement.high */
  num high;

  /** @domName HTMLMeterElement.labels */
  final NodeList labels;

  /** @domName HTMLMeterElement.low */
  num low;

  /** @domName HTMLMeterElement.max */
  num max;

  /** @domName HTMLMeterElement.min */
  num min;

  /** @domName HTMLMeterElement.optimum */
  num optimum;

  /** @domName HTMLMeterElement.value */
  num value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLModElement
interface ModElement extends Element {

  /** @domName HTMLModElement.cite */
  String cite;

  /** @domName HTMLModElement.dateTime */
  String dateTime;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MouseEvent
interface MouseEvent extends UIEvent default _MouseEventFactoryProvider {

  MouseEvent(String type, Window view, int detail, int screenX, int screenY,
      int clientX, int clientY, int button, [bool canBubble, bool cancelable,
      bool ctrlKey, bool altKey, bool shiftKey, bool metaKey,
      EventTarget relatedTarget]);


  /** @domName MouseEvent.altKey */
  final bool altKey;

  /** @domName MouseEvent.button */
  final int button;

  /** @domName MouseEvent.clientX */
  final int clientX;

  /** @domName MouseEvent.clientY */
  final int clientY;

  /** @domName MouseEvent.ctrlKey */
  final bool ctrlKey;

  /** @domName MouseEvent.dataTransfer */
  final Clipboard dataTransfer;

  /** @domName MouseEvent.fromElement */
  final Node fromElement;

  /** @domName MouseEvent.metaKey */
  final bool metaKey;

  /** @domName MouseEvent.offsetX */
  final int offsetX;

  /** @domName MouseEvent.offsetY */
  final int offsetY;

  /** @domName MouseEvent.relatedTarget */
  final EventTarget relatedTarget;

  /** @domName MouseEvent.screenX */
  final int screenX;

  /** @domName MouseEvent.screenY */
  final int screenY;

  /** @domName MouseEvent.shiftKey */
  final bool shiftKey;

  /** @domName MouseEvent.toElement */
  final Node toElement;

  /** @domName MouseEvent.webkitMovementX */
  final int webkitMovementX;

  /** @domName MouseEvent.webkitMovementY */
  final int webkitMovementY;

  /** @domName MouseEvent.x */
  final int x;

  /** @domName MouseEvent.y */
  final int y;

  /** @domName MouseEvent.initMouseEvent */
  void $dom_initMouseEvent(String type, bool canBubble, bool cancelable, Window view, int detail, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey, int button, EventTarget relatedTarget);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MutationCallback
interface MutationCallback {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MutationEvent
interface MutationEvent extends Event {

  static final int ADDITION = 2;

  static final int MODIFICATION = 1;

  static final int REMOVAL = 3;

  /** @domName MutationEvent.attrChange */
  final int attrChange;

  /** @domName MutationEvent.attrName */
  final String attrName;

  /** @domName MutationEvent.newValue */
  final String newValue;

  /** @domName MutationEvent.prevValue */
  final String prevValue;

  /** @domName MutationEvent.relatedNode */
  final Node relatedNode;

  /** @domName MutationEvent.initMutationEvent */
  void initMutationEvent(String type, bool canBubble, bool cancelable, Node relatedNode, String prevValue, String newValue, String attrName, int attrChange);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName MutationRecord
interface MutationRecord {

  /** @domName MutationRecord.addedNodes */
  final NodeList addedNodes;

  /** @domName MutationRecord.attributeName */
  final String attributeName;

  /** @domName MutationRecord.attributeNamespace */
  final String attributeNamespace;

  /** @domName MutationRecord.nextSibling */
  final Node nextSibling;

  /** @domName MutationRecord.oldValue */
  final String oldValue;

  /** @domName MutationRecord.previousSibling */
  final Node previousSibling;

  /** @domName MutationRecord.removedNodes */
  final NodeList removedNodes;

  /** @domName MutationRecord.target */
  final Node target;

  /** @domName MutationRecord.type */
  final String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName NamedNodeMap
interface NamedNodeMap extends List<Node> {

  /** @domName NamedNodeMap.length */
  final int length;

  /** @domName NamedNodeMap.getNamedItem */
  Node getNamedItem(String name);

  /** @domName NamedNodeMap.getNamedItemNS */
  Node getNamedItemNS(String namespaceURI, String localName);

  /** @domName NamedNodeMap.item */
  Node item(int index);

  /** @domName NamedNodeMap.removeNamedItem */
  Node removeNamedItem(String name);

  /** @domName NamedNodeMap.removeNamedItemNS */
  Node removeNamedItemNS(String namespaceURI, String localName);

  /** @domName NamedNodeMap.setNamedItem */
  Node setNamedItem(Node node);

  /** @domName NamedNodeMap.setNamedItemNS */
  Node setNamedItemNS(Node node);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Navigator
interface Navigator {

  /** @domName Navigator.appCodeName */
  final String appCodeName;

  /** @domName Navigator.appName */
  final String appName;

  /** @domName Navigator.appVersion */
  final String appVersion;

  /** @domName Navigator.cookieEnabled */
  final bool cookieEnabled;

  /** @domName Navigator.geolocation */
  final Geolocation geolocation;

  /** @domName Navigator.language */
  final String language;

  /** @domName Navigator.mimeTypes */
  final DOMMimeTypeArray mimeTypes;

  /** @domName Navigator.onLine */
  final bool onLine;

  /** @domName Navigator.platform */
  final String platform;

  /** @domName Navigator.plugins */
  final DOMPluginArray plugins;

  /** @domName Navigator.product */
  final String product;

  /** @domName Navigator.productSub */
  final String productSub;

  /** @domName Navigator.userAgent */
  final String userAgent;

  /** @domName Navigator.vendor */
  final String vendor;

  /** @domName Navigator.vendorSub */
  final String vendorSub;

  /** @domName Navigator.webkitBattery */
  final BatteryManager webkitBattery;

  /** @domName Navigator.webkitPointer */
  final PointerLock webkitPointer;

  /** @domName Navigator.getStorageUpdates */
  void getStorageUpdates();

  /** @domName Navigator.javaEnabled */
  bool javaEnabled();

  /** @domName Navigator.registerProtocolHandler */
  void registerProtocolHandler(String scheme, String url, String title);

  /** @domName Navigator.webkitGetUserMedia */
  void webkitGetUserMedia(Map options, NavigatorUserMediaSuccessCallback successCallback, [NavigatorUserMediaErrorCallback errorCallback]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName NavigatorUserMediaError
interface NavigatorUserMediaError {

  static final int PERMISSION_DENIED = 1;

  /** @domName NavigatorUserMediaError.code */
  final int code;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool NavigatorUserMediaErrorCallback(NavigatorUserMediaError error);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool NavigatorUserMediaSuccessCallback(LocalMediaStream stream);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Node
interface Node extends EventTarget {
  NodeList get nodes();

  void set nodes(Collection<Node> value);

  /**
   * Replaces this node with another node.
   * @domName Node.replaceChild
   */
  Node replaceWith(Node otherNode);

  /**
   * Removes this node from the DOM.
   * @domName Node.removeChild
   */
  Node remove();


  static final int ATTRIBUTE_NODE = 2;

  static final int CDATA_SECTION_NODE = 4;

  static final int COMMENT_NODE = 8;

  static final int DOCUMENT_FRAGMENT_NODE = 11;

  static final int DOCUMENT_NODE = 9;

  static final int DOCUMENT_POSITION_CONTAINED_BY = 0x10;

  static final int DOCUMENT_POSITION_CONTAINS = 0x08;

  static final int DOCUMENT_POSITION_DISCONNECTED = 0x01;

  static final int DOCUMENT_POSITION_FOLLOWING = 0x04;

  static final int DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;

  static final int DOCUMENT_POSITION_PRECEDING = 0x02;

  static final int DOCUMENT_TYPE_NODE = 10;

  static final int ELEMENT_NODE = 1;

  static final int ENTITY_NODE = 6;

  static final int ENTITY_REFERENCE_NODE = 5;

  static final int NOTATION_NODE = 12;

  static final int PROCESSING_INSTRUCTION_NODE = 7;

  static final int TEXT_NODE = 3;

  /** @domName Node.attributes */
  final NamedNodeMap $dom_attributes;

  /** @domName Node.childNodes */
  final NodeList $dom_childNodes;

  /** @domName Node.firstChild */
  final Node $dom_firstChild;

  /** @domName Node.lastChild */
  final Node $dom_lastChild;

  /** @domName Node.nextSibling */
  final Node nextNode;

  /** @domName Node.nodeType */
  final int $dom_nodeType;

  /** @domName Node.ownerDocument */
  final Document document;

  /** @domName Node.parentNode */
  final Node parent;

  /** @domName Node.previousSibling */
  final Node previousNode;

  /** @domName Node.textContent */
  String text;

  /** @domName Node.appendChild */
  Node $dom_appendChild(Node newChild);

  /** @domName Node.cloneNode */
  Node clone(bool deep);

  /** @domName Node.contains */
  bool contains(Node other);

  /** @domName Node.hasChildNodes */
  bool hasChildNodes();

  /** @domName Node.insertBefore */
  Node insertBefore(Node newChild, Node refChild);

  /** @domName Node.removeChild */
  Node $dom_removeChild(Node oldChild);

  /** @domName Node.replaceChild */
  Node $dom_replaceChild(Node newChild, Node oldChild);

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName NodeFilter
interface NodeFilter {

  static final int FILTER_ACCEPT = 1;

  static final int FILTER_REJECT = 2;

  static final int FILTER_SKIP = 3;

  static final int SHOW_ALL = 0xFFFFFFFF;

  static final int SHOW_ATTRIBUTE = 0x00000002;

  static final int SHOW_CDATA_SECTION = 0x00000008;

  static final int SHOW_COMMENT = 0x00000080;

  static final int SHOW_DOCUMENT = 0x00000100;

  static final int SHOW_DOCUMENT_FRAGMENT = 0x00000400;

  static final int SHOW_DOCUMENT_TYPE = 0x00000200;

  static final int SHOW_ELEMENT = 0x00000001;

  static final int SHOW_ENTITY = 0x00000020;

  static final int SHOW_ENTITY_REFERENCE = 0x00000010;

  static final int SHOW_NOTATION = 0x00000800;

  static final int SHOW_PROCESSING_INSTRUCTION = 0x00000040;

  static final int SHOW_TEXT = 0x00000004;

  /** @domName NodeFilter.acceptNode */
  int acceptNode(Node n);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName NodeIterator
interface NodeIterator {

  /** @domName NodeIterator.expandEntityReferences */
  final bool expandEntityReferences;

  /** @domName NodeIterator.filter */
  final NodeFilter filter;

  /** @domName NodeIterator.pointerBeforeReferenceNode */
  final bool pointerBeforeReferenceNode;

  /** @domName NodeIterator.referenceNode */
  final Node referenceNode;

  /** @domName NodeIterator.root */
  final Node root;

  /** @domName NodeIterator.whatToShow */
  final int whatToShow;

  /** @domName NodeIterator.detach */
  void detach();

  /** @domName NodeIterator.nextNode */
  Node nextNode();

  /** @domName NodeIterator.previousNode */
  Node previousNode();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName NodeList
interface NodeList extends List<Node> {

  NodeList filter(bool f(Node element));

  NodeList getRange(int start, int length);

  Node get first();


  /** @domName NodeList.length */
  final int length;

}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName NodeSelector
interface NodeSelector {

  // TODO(nweiz): add this back once DocumentFragment is ported.
  // ElementList queryAll(String selectors);


  /** @domName NodeSelector.querySelector */
  Element query(String selectors);

  /** @domName NodeSelector.querySelectorAll */
  NodeList $dom_querySelectorAll(String selectors);

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Notation
interface Notation extends Node {

  /** @domName Notation.publicId */
  final String publicId;

  /** @domName Notation.systemId */
  final String systemId;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Notification
interface Notification extends EventTarget default _NotificationFactoryProvider {

  Notification(String title, [Map options]);

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  NotificationEvents get on();

  /** @domName Notification.dir */
  String dir;

  /** @domName Notification.replaceId */
  String replaceId;

  /** @domName Notification.tag */
  String tag;

  /** @domName Notification.cancel */
  void cancel();

  /** @domName Notification.close */
  void close();

  /** @domName Notification.show */
  void show();
}

interface NotificationEvents extends Events {

  EventListenerList get click();

  EventListenerList get close();

  EventListenerList get display();

  EventListenerList get error();

  EventListenerList get show();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName NotificationCenter
interface NotificationCenter {

  /** @domName NotificationCenter.checkPermission */
  int checkPermission();

  /** @domName NotificationCenter.createHTMLNotification */
  Notification createHTMLNotification(String url);

  /** @domName NotificationCenter.createNotification */
  Notification createNotification(String iconUrl, String title, String body);

  /** @domName NotificationCenter.requestPermission */
  void requestPermission(VoidCallback callback);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName OESStandardDerivatives
interface OESStandardDerivatives {

  static final int FRAGMENT_SHADER_DERIVATIVE_HINT_OES = 0x8B8B;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName OESTextureFloat
interface OESTextureFloat {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName OESVertexArrayObject
interface OESVertexArrayObject {

  static final int VERTEX_ARRAY_BINDING_OES = 0x85B5;

  /** @domName OESVertexArrayObject.bindVertexArrayOES */
  void bindVertexArrayOES(WebGLVertexArrayObjectOES arrayObject);

  /** @domName OESVertexArrayObject.createVertexArrayOES */
  WebGLVertexArrayObjectOES createVertexArrayOES();

  /** @domName OESVertexArrayObject.deleteVertexArrayOES */
  void deleteVertexArrayOES(WebGLVertexArrayObjectOES arrayObject);

  /** @domName OESVertexArrayObject.isVertexArrayOES */
  bool isVertexArrayOES(WebGLVertexArrayObjectOES arrayObject);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLOListElement
interface OListElement extends Element {

  /** @domName HTMLOListElement.compact */
  bool compact;

  /** @domName HTMLOListElement.reversed */
  bool reversed;

  /** @domName HTMLOListElement.start */
  int start;

  /** @domName HTMLOListElement.type */
  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLObjectElement
interface ObjectElement extends Element {

  /** @domName HTMLObjectElement.align */
  String align;

  /** @domName HTMLObjectElement.archive */
  String archive;

  /** @domName HTMLObjectElement.border */
  String border;

  /** @domName HTMLObjectElement.code */
  String code;

  /** @domName HTMLObjectElement.codeBase */
  String codeBase;

  /** @domName HTMLObjectElement.codeType */
  String codeType;

  /** @domName HTMLObjectElement.contentDocument */
  final Document contentDocument;

  /** @domName HTMLObjectElement.data */
  String data;

  /** @domName HTMLObjectElement.declare */
  bool declare;

  /** @domName HTMLObjectElement.form */
  final FormElement form;

  /** @domName HTMLObjectElement.height */
  String height;

  /** @domName HTMLObjectElement.hspace */
  int hspace;

  /** @domName HTMLObjectElement.name */
  String name;

  /** @domName HTMLObjectElement.standby */
  String standby;

  /** @domName HTMLObjectElement.type */
  String type;

  /** @domName HTMLObjectElement.useMap */
  String useMap;

  /** @domName HTMLObjectElement.validationMessage */
  final String validationMessage;

  /** @domName HTMLObjectElement.validity */
  final ValidityState validity;

  /** @domName HTMLObjectElement.vspace */
  int vspace;

  /** @domName HTMLObjectElement.width */
  String width;

  /** @domName HTMLObjectElement.willValidate */
  final bool willValidate;

  /** @domName HTMLObjectElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLObjectElement.setCustomValidity */
  void setCustomValidity(String error);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName OfflineAudioCompletionEvent
interface OfflineAudioCompletionEvent extends Event {

  /** @domName OfflineAudioCompletionEvent.renderedBuffer */
  final AudioBuffer renderedBuffer;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName OperationNotAllowedException
interface OperationNotAllowedException {

  static final int NOT_ALLOWED_ERR = 1;

  /** @domName OperationNotAllowedException.code */
  final int code;

  /** @domName OperationNotAllowedException.message */
  final String message;

  /** @domName OperationNotAllowedException.name */
  final String name;

  /** @domName OperationNotAllowedException.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLOptGroupElement
interface OptGroupElement extends Element {

  /** @domName HTMLOptGroupElement.disabled */
  bool disabled;

  /** @domName HTMLOptGroupElement.label */
  String label;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLOptionElement
interface OptionElement extends Element default _OptionElementFactoryProvider {

  OptionElement([String data, String value, bool defaultSelected, bool selected]);

  /** @domName HTMLOptionElement.defaultSelected */
  bool defaultSelected;

  /** @domName HTMLOptionElement.disabled */
  bool disabled;

  /** @domName HTMLOptionElement.form */
  final FormElement form;

  /** @domName HTMLOptionElement.index */
  final int index;

  /** @domName HTMLOptionElement.label */
  String label;

  /** @domName HTMLOptionElement.selected */
  bool selected;

  /** @domName HTMLOptionElement.value */
  String value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Oscillator
interface Oscillator extends AudioSourceNode {

  static final int CUSTOM = 4;

  static final int SAWTOOTH = 2;

  static final int SINE = 0;

  static final int SQUARE = 1;

  static final int TRIANGLE = 3;

  /** @domName Oscillator.detune */
  final AudioParam detune;

  /** @domName Oscillator.frequency */
  final AudioParam frequency;

  /** @domName Oscillator.type */
  int type;

  /** @domName Oscillator.setWaveTable */
  void setWaveTable(WaveTable waveTable);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLOutputElement
interface OutputElement extends Element {

  /** @domName HTMLOutputElement.defaultValue */
  String defaultValue;

  /** @domName HTMLOutputElement.form */
  final FormElement form;

  /** @domName HTMLOutputElement.htmlFor */
  DOMSettableTokenList htmlFor;

  /** @domName HTMLOutputElement.labels */
  final NodeList labels;

  /** @domName HTMLOutputElement.name */
  String name;

  /** @domName HTMLOutputElement.type */
  final String type;

  /** @domName HTMLOutputElement.validationMessage */
  final String validationMessage;

  /** @domName HTMLOutputElement.validity */
  final ValidityState validity;

  /** @domName HTMLOutputElement.value */
  String value;

  /** @domName HTMLOutputElement.willValidate */
  final bool willValidate;

  /** @domName HTMLOutputElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLOutputElement.setCustomValidity */
  void setCustomValidity(String error);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName OverflowEvent
interface OverflowEvent extends Event {

  static final int BOTH = 2;

  static final int HORIZONTAL = 0;

  static final int VERTICAL = 1;

  /** @domName OverflowEvent.horizontalOverflow */
  final bool horizontalOverflow;

  /** @domName OverflowEvent.orient */
  final int orient;

  /** @domName OverflowEvent.verticalOverflow */
  final bool verticalOverflow;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName PageTransitionEvent
interface PageTransitionEvent extends Event {

  /** @domName PageTransitionEvent.persisted */
  final bool persisted;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLParagraphElement
interface ParagraphElement extends Element {

  /** @domName HTMLParagraphElement.align */
  String align;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLParamElement
interface ParamElement extends Element {

  /** @domName HTMLParamElement.name */
  String name;

  /** @domName HTMLParamElement.type */
  String type;

  /** @domName HTMLParamElement.value */
  String value;

  /** @domName HTMLParamElement.valueType */
  String valueType;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName PeerConnection00
interface PeerConnection00 extends EventTarget default _PeerConnection00FactoryProvider {

  PeerConnection00(String serverConfiguration, IceCallback iceCallback);

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  PeerConnection00Events get on();

  static final int ACTIVE = 2;

  static final int CLOSED = 3;

  static final int ICE_CHECKING = 0x300;

  static final int ICE_CLOSED = 0x700;

  static final int ICE_COMPLETED = 0x500;

  static final int ICE_CONNECTED = 0x400;

  static final int ICE_FAILED = 0x600;

  static final int ICE_GATHERING = 0x100;

  static final int ICE_WAITING = 0x200;

  static final int NEGOTIATING = 1;

  static final int NEW = 0;

  static final int SDP_ANSWER = 0x300;

  static final int SDP_OFFER = 0x100;

  static final int SDP_PRANSWER = 0x200;

  /** @domName PeerConnection00.iceState */
  final int iceState;

  /** @domName PeerConnection00.localDescription */
  final SessionDescription localDescription;

  /** @domName PeerConnection00.localStreams */
  final MediaStreamList localStreams;

  /** @domName PeerConnection00.readyState */
  final int readyState;

  /** @domName PeerConnection00.remoteDescription */
  final SessionDescription remoteDescription;

  /** @domName PeerConnection00.remoteStreams */
  final MediaStreamList remoteStreams;

  /** @domName PeerConnection00.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName PeerConnection00.addStream */
  void addStream(MediaStream stream, [String mediaStreamHints]);

  /** @domName PeerConnection00.close */
  void close();

  /** @domName PeerConnection00.createAnswer */
  SessionDescription createAnswer(String offer, [String mediaHints]);

  /** @domName PeerConnection00.createOffer */
  SessionDescription createOffer([String mediaHints]);

  /** @domName PeerConnection00.dispatchEvent */
  bool $dom_dispatchEvent(Event event);

  /** @domName PeerConnection00.processIceMessage */
  void processIceMessage(IceCandidate candidate);

  /** @domName PeerConnection00.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName PeerConnection00.removeStream */
  void removeStream(MediaStream stream);

  /** @domName PeerConnection00.setLocalDescription */
  void setLocalDescription(int action, SessionDescription desc);

  /** @domName PeerConnection00.setRemoteDescription */
  void setRemoteDescription(int action, SessionDescription desc);

  /** @domName PeerConnection00.startIce */
  void startIce([String iceOptions]);
}

interface PeerConnection00Events extends Events {

  EventListenerList get addStream();

  EventListenerList get connecting();

  EventListenerList get open();

  EventListenerList get removeStream();

  EventListenerList get stateChange();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Performance
interface Performance {

  /** @domName Performance.memory */
  final MemoryInfo memory;

  /** @domName Performance.navigation */
  final PerformanceNavigation navigation;

  /** @domName Performance.timing */
  final PerformanceTiming timing;

  /** @domName Performance.webkitNow */
  num webkitNow();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName PerformanceNavigation
interface PerformanceNavigation {

  static final int TYPE_BACK_FORWARD = 2;

  static final int TYPE_NAVIGATE = 0;

  static final int TYPE_RELOAD = 1;

  static final int TYPE_RESERVED = 255;

  /** @domName PerformanceNavigation.redirectCount */
  final int redirectCount;

  /** @domName PerformanceNavigation.type */
  final int type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName PerformanceTiming
interface PerformanceTiming {

  /** @domName PerformanceTiming.connectEnd */
  final int connectEnd;

  /** @domName PerformanceTiming.connectStart */
  final int connectStart;

  /** @domName PerformanceTiming.domComplete */
  final int domComplete;

  /** @domName PerformanceTiming.domContentLoadedEventEnd */
  final int domContentLoadedEventEnd;

  /** @domName PerformanceTiming.domContentLoadedEventStart */
  final int domContentLoadedEventStart;

  /** @domName PerformanceTiming.domInteractive */
  final int domInteractive;

  /** @domName PerformanceTiming.domLoading */
  final int domLoading;

  /** @domName PerformanceTiming.domainLookupEnd */
  final int domainLookupEnd;

  /** @domName PerformanceTiming.domainLookupStart */
  final int domainLookupStart;

  /** @domName PerformanceTiming.fetchStart */
  final int fetchStart;

  /** @domName PerformanceTiming.loadEventEnd */
  final int loadEventEnd;

  /** @domName PerformanceTiming.loadEventStart */
  final int loadEventStart;

  /** @domName PerformanceTiming.navigationStart */
  final int navigationStart;

  /** @domName PerformanceTiming.redirectEnd */
  final int redirectEnd;

  /** @domName PerformanceTiming.redirectStart */
  final int redirectStart;

  /** @domName PerformanceTiming.requestStart */
  final int requestStart;

  /** @domName PerformanceTiming.responseEnd */
  final int responseEnd;

  /** @domName PerformanceTiming.responseStart */
  final int responseStart;

  /** @domName PerformanceTiming.secureConnectionStart */
  final int secureConnectionStart;

  /** @domName PerformanceTiming.unloadEventEnd */
  final int unloadEventEnd;

  /** @domName PerformanceTiming.unloadEventStart */
  final int unloadEventStart;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitPoint
interface Point default _PointFactoryProvider {

  Point(num x, num y);

  /** @domName WebKitPoint.x */
  num x;

  /** @domName WebKitPoint.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName PointerLock
interface PointerLock {

  /** @domName PointerLock.isLocked */
  final bool isLocked;

  /** @domName PointerLock.lock */
  void lock(Element target, [VoidCallback successCallback, VoidCallback failureCallback]);

  /** @domName PointerLock.unlock */
  void unlock();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName PopStateEvent
interface PopStateEvent extends Event {

  /** @domName PopStateEvent.state */
  final Object state;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool PositionCallback(Geoposition position);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName PositionError
interface PositionError {

  static final int PERMISSION_DENIED = 1;

  static final int POSITION_UNAVAILABLE = 2;

  static final int TIMEOUT = 3;

  /** @domName PositionError.code */
  final int code;

  /** @domName PositionError.message */
  final String message;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool PositionErrorCallback(PositionError error);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLPreElement
interface PreElement extends Element {

  /** @domName HTMLPreElement.width */
  int width;

  /** @domName HTMLPreElement.wrap */
  bool wrap;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ProcessingInstruction
interface ProcessingInstruction extends Node {

  /** @domName ProcessingInstruction.data */
  String data;

  /** @domName ProcessingInstruction.sheet */
  final StyleSheet sheet;

  /** @domName ProcessingInstruction.target */
  final String target;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLProgressElement
interface ProgressElement extends Element {

  /** @domName HTMLProgressElement.labels */
  final NodeList labels;

  /** @domName HTMLProgressElement.max */
  num max;

  /** @domName HTMLProgressElement.position */
  final num position;

  /** @domName HTMLProgressElement.value */
  num value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ProgressEvent
interface ProgressEvent extends Event {

  /** @domName ProgressEvent.lengthComputable */
  final bool lengthComputable;

  /** @domName ProgressEvent.loaded */
  final int loaded;

  /** @domName ProgressEvent.total */
  final int total;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLQuoteElement
interface QuoteElement extends Element {

  /** @domName HTMLQuoteElement.cite */
  String cite;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName RGBColor
interface RGBColor {

  /** @domName RGBColor.blue */
  final CSSPrimitiveValue blue;

  /** @domName RGBColor.green */
  final CSSPrimitiveValue green;

  /** @domName RGBColor.red */
  final CSSPrimitiveValue red;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Range
interface Range {

  static final int END_TO_END = 2;

  static final int END_TO_START = 3;

  static final int NODE_AFTER = 1;

  static final int NODE_BEFORE = 0;

  static final int NODE_BEFORE_AND_AFTER = 2;

  static final int NODE_INSIDE = 3;

  static final int START_TO_END = 1;

  static final int START_TO_START = 0;

  /** @domName Range.collapsed */
  final bool collapsed;

  /** @domName Range.commonAncestorContainer */
  final Node commonAncestorContainer;

  /** @domName Range.endContainer */
  final Node endContainer;

  /** @domName Range.endOffset */
  final int endOffset;

  /** @domName Range.startContainer */
  final Node startContainer;

  /** @domName Range.startOffset */
  final int startOffset;

  /** @domName Range.cloneContents */
  DocumentFragment cloneContents();

  /** @domName Range.cloneRange */
  Range cloneRange();

  /** @domName Range.collapse */
  void collapse(bool toStart);

  /** @domName Range.compareNode */
  int compareNode(Node refNode);

  /** @domName Range.comparePoint */
  int comparePoint(Node refNode, int offset);

  /** @domName Range.createContextualFragment */
  DocumentFragment createContextualFragment(String html);

  /** @domName Range.deleteContents */
  void deleteContents();

  /** @domName Range.detach */
  void detach();

  /** @domName Range.expand */
  void expand(String unit);

  /** @domName Range.extractContents */
  DocumentFragment extractContents();

  /** @domName Range.getBoundingClientRect */
  ClientRect getBoundingClientRect();

  /** @domName Range.getClientRects */
  ClientRectList getClientRects();

  /** @domName Range.insertNode */
  void insertNode(Node newNode);

  /** @domName Range.intersectsNode */
  bool intersectsNode(Node refNode);

  /** @domName Range.isPointInRange */
  bool isPointInRange(Node refNode, int offset);

  /** @domName Range.selectNode */
  void selectNode(Node refNode);

  /** @domName Range.selectNodeContents */
  void selectNodeContents(Node refNode);

  /** @domName Range.setEnd */
  void setEnd(Node refNode, int offset);

  /** @domName Range.setEndAfter */
  void setEndAfter(Node refNode);

  /** @domName Range.setEndBefore */
  void setEndBefore(Node refNode);

  /** @domName Range.setStart */
  void setStart(Node refNode, int offset);

  /** @domName Range.setStartAfter */
  void setStartAfter(Node refNode);

  /** @domName Range.setStartBefore */
  void setStartBefore(Node refNode);

  /** @domName Range.surroundContents */
  void surroundContents(Node newParent);

  /** @domName Range.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName RangeException
interface RangeException {

  static final int BAD_BOUNDARYPOINTS_ERR = 1;

  static final int INVALID_NODE_TYPE_ERR = 2;

  /** @domName RangeException.code */
  final int code;

  /** @domName RangeException.message */
  final String message;

  /** @domName RangeException.name */
  final String name;

  /** @domName RangeException.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName RealtimeAnalyserNode
interface RealtimeAnalyserNode extends AudioNode {

  /** @domName RealtimeAnalyserNode.fftSize */
  int fftSize;

  /** @domName RealtimeAnalyserNode.frequencyBinCount */
  final int frequencyBinCount;

  /** @domName RealtimeAnalyserNode.maxDecibels */
  num maxDecibels;

  /** @domName RealtimeAnalyserNode.minDecibels */
  num minDecibels;

  /** @domName RealtimeAnalyserNode.smoothingTimeConstant */
  num smoothingTimeConstant;

  /** @domName RealtimeAnalyserNode.getByteFrequencyData */
  void getByteFrequencyData(Uint8Array array);

  /** @domName RealtimeAnalyserNode.getByteTimeDomainData */
  void getByteTimeDomainData(Uint8Array array);

  /** @domName RealtimeAnalyserNode.getFloatFrequencyData */
  void getFloatFrequencyData(Float32Array array);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Rect
interface Rect {

  /** @domName Rect.bottom */
  final CSSPrimitiveValue bottom;

  /** @domName Rect.left */
  final CSSPrimitiveValue left;

  /** @domName Rect.right */
  final CSSPrimitiveValue right;

  /** @domName Rect.top */
  final CSSPrimitiveValue top;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool RequestAnimationFrameCallback(num highResTime);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SQLError
interface SQLError {

  static final int CONSTRAINT_ERR = 6;

  static final int DATABASE_ERR = 1;

  static final int QUOTA_ERR = 4;

  static final int SYNTAX_ERR = 5;

  static final int TIMEOUT_ERR = 7;

  static final int TOO_LARGE_ERR = 3;

  static final int UNKNOWN_ERR = 0;

  static final int VERSION_ERR = 2;

  /** @domName SQLError.code */
  final int code;

  /** @domName SQLError.message */
  final String message;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SQLException
interface SQLException {

  static final int CONSTRAINT_ERR = 6;

  static final int DATABASE_ERR = 1;

  static final int QUOTA_ERR = 4;

  static final int SYNTAX_ERR = 5;

  static final int TIMEOUT_ERR = 7;

  static final int TOO_LARGE_ERR = 3;

  static final int UNKNOWN_ERR = 0;

  static final int VERSION_ERR = 2;

  /** @domName SQLException.code */
  final int code;

  /** @domName SQLException.message */
  final String message;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SQLResultSet
interface SQLResultSet {

  /** @domName SQLResultSet.insertId */
  final int insertId;

  /** @domName SQLResultSet.rows */
  final SQLResultSetRowList rows;

  /** @domName SQLResultSet.rowsAffected */
  final int rowsAffected;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SQLResultSetRowList
interface SQLResultSetRowList {

  /** @domName SQLResultSetRowList.length */
  final int length;

  /** @domName SQLResultSetRowList.item */
  Object item(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool SQLStatementCallback(SQLTransaction transaction, SQLResultSet resultSet);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool SQLStatementErrorCallback(SQLTransaction transaction, SQLError error);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SQLTransaction
interface SQLTransaction {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool SQLTransactionCallback(SQLTransaction transaction);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool SQLTransactionErrorCallback(SQLError error);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SQLTransactionSync
interface SQLTransactionSync {
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool SQLTransactionSyncCallback(SQLTransactionSync transaction);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAElement
interface SVGAElement extends SVGElement, SVGURIReference, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGAElement.target */
  final SVGAnimatedString target;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAltGlyphDefElement
interface SVGAltGlyphDefElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAltGlyphElement
interface SVGAltGlyphElement extends SVGTextPositioningElement, SVGURIReference {

  /** @domName SVGAltGlyphElement.format */
  String format;

  /** @domName SVGAltGlyphElement.glyphRef */
  String glyphRef;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAltGlyphItemElement
interface SVGAltGlyphItemElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAngle
interface SVGAngle {

  static final int SVG_ANGLETYPE_DEG = 2;

  static final int SVG_ANGLETYPE_GRAD = 4;

  static final int SVG_ANGLETYPE_RAD = 3;

  static final int SVG_ANGLETYPE_UNKNOWN = 0;

  static final int SVG_ANGLETYPE_UNSPECIFIED = 1;

  /** @domName SVGAngle.unitType */
  final int unitType;

  /** @domName SVGAngle.value */
  num value;

  /** @domName SVGAngle.valueAsString */
  String valueAsString;

  /** @domName SVGAngle.valueInSpecifiedUnits */
  num valueInSpecifiedUnits;

  /** @domName SVGAngle.convertToSpecifiedUnits */
  void convertToSpecifiedUnits(int unitType);

  /** @domName SVGAngle.newValueSpecifiedUnits */
  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimateColorElement
interface SVGAnimateColorElement extends SVGAnimationElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimateElement
interface SVGAnimateElement extends SVGAnimationElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimateMotionElement
interface SVGAnimateMotionElement extends SVGAnimationElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimateTransformElement
interface SVGAnimateTransformElement extends SVGAnimationElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedAngle
interface SVGAnimatedAngle {

  /** @domName SVGAnimatedAngle.animVal */
  final SVGAngle animVal;

  /** @domName SVGAnimatedAngle.baseVal */
  final SVGAngle baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedBoolean
interface SVGAnimatedBoolean {

  /** @domName SVGAnimatedBoolean.animVal */
  final bool animVal;

  /** @domName SVGAnimatedBoolean.baseVal */
  bool baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedEnumeration
interface SVGAnimatedEnumeration {

  /** @domName SVGAnimatedEnumeration.animVal */
  final int animVal;

  /** @domName SVGAnimatedEnumeration.baseVal */
  int baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedInteger
interface SVGAnimatedInteger {

  /** @domName SVGAnimatedInteger.animVal */
  final int animVal;

  /** @domName SVGAnimatedInteger.baseVal */
  int baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedLength
interface SVGAnimatedLength {

  /** @domName SVGAnimatedLength.animVal */
  final SVGLength animVal;

  /** @domName SVGAnimatedLength.baseVal */
  final SVGLength baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedLengthList
interface SVGAnimatedLengthList {

  /** @domName SVGAnimatedLengthList.animVal */
  final SVGLengthList animVal;

  /** @domName SVGAnimatedLengthList.baseVal */
  final SVGLengthList baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedNumber
interface SVGAnimatedNumber {

  /** @domName SVGAnimatedNumber.animVal */
  final num animVal;

  /** @domName SVGAnimatedNumber.baseVal */
  num baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedNumberList
interface SVGAnimatedNumberList {

  /** @domName SVGAnimatedNumberList.animVal */
  final SVGNumberList animVal;

  /** @domName SVGAnimatedNumberList.baseVal */
  final SVGNumberList baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedPreserveAspectRatio
interface SVGAnimatedPreserveAspectRatio {

  /** @domName SVGAnimatedPreserveAspectRatio.animVal */
  final SVGPreserveAspectRatio animVal;

  /** @domName SVGAnimatedPreserveAspectRatio.baseVal */
  final SVGPreserveAspectRatio baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedRect
interface SVGAnimatedRect {

  /** @domName SVGAnimatedRect.animVal */
  final SVGRect animVal;

  /** @domName SVGAnimatedRect.baseVal */
  final SVGRect baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedString
interface SVGAnimatedString {

  /** @domName SVGAnimatedString.animVal */
  final String animVal;

  /** @domName SVGAnimatedString.baseVal */
  String baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimatedTransformList
interface SVGAnimatedTransformList {

  /** @domName SVGAnimatedTransformList.animVal */
  final SVGTransformList animVal;

  /** @domName SVGAnimatedTransformList.baseVal */
  final SVGTransformList baseVal;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGAnimationElement
interface SVGAnimationElement extends SVGElement, SVGTests, SVGExternalResourcesRequired, ElementTimeControl {

  /** @domName SVGAnimationElement.targetElement */
  final SVGElement targetElement;

  /** @domName SVGAnimationElement.getCurrentTime */
  num getCurrentTime();

  /** @domName SVGAnimationElement.getSimpleDuration */
  num getSimpleDuration();

  /** @domName SVGAnimationElement.getStartTime */
  num getStartTime();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGCircleElement
interface SVGCircleElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGCircleElement.cx */
  final SVGAnimatedLength cx;

  /** @domName SVGCircleElement.cy */
  final SVGAnimatedLength cy;

  /** @domName SVGCircleElement.r */
  final SVGAnimatedLength r;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGClipPathElement
interface SVGClipPathElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGClipPathElement.clipPathUnits */
  final SVGAnimatedEnumeration clipPathUnits;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGColor
interface SVGColor extends CSSValue {

  static final int SVG_COLORTYPE_CURRENTCOLOR = 3;

  static final int SVG_COLORTYPE_RGBCOLOR = 1;

  static final int SVG_COLORTYPE_RGBCOLOR_ICCCOLOR = 2;

  static final int SVG_COLORTYPE_UNKNOWN = 0;

  /** @domName SVGColor.colorType */
  final int colorType;

  /** @domName SVGColor.rgbColor */
  final RGBColor rgbColor;

  /** @domName SVGColor.setColor */
  void setColor(int colorType, String rgbColor, String iccColor);

  /** @domName SVGColor.setRGBColor */
  void setRGBColor(String rgbColor);

  /** @domName SVGColor.setRGBColorICCColor */
  void setRGBColorICCColor(String rgbColor, String iccColor);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGComponentTransferFunctionElement
interface SVGComponentTransferFunctionElement extends SVGElement {

  static final int SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE = 3;

  static final int SVG_FECOMPONENTTRANSFER_TYPE_GAMMA = 5;

  static final int SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY = 1;

  static final int SVG_FECOMPONENTTRANSFER_TYPE_LINEAR = 4;

  static final int SVG_FECOMPONENTTRANSFER_TYPE_TABLE = 2;

  static final int SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN = 0;

  /** @domName SVGComponentTransferFunctionElement.amplitude */
  final SVGAnimatedNumber amplitude;

  /** @domName SVGComponentTransferFunctionElement.exponent */
  final SVGAnimatedNumber exponent;

  /** @domName SVGComponentTransferFunctionElement.intercept */
  final SVGAnimatedNumber intercept;

  /** @domName SVGComponentTransferFunctionElement.offset */
  final SVGAnimatedNumber offset;

  /** @domName SVGComponentTransferFunctionElement.slope */
  final SVGAnimatedNumber slope;

  /** @domName SVGComponentTransferFunctionElement.tableValues */
  final SVGAnimatedNumberList tableValues;

  /** @domName SVGComponentTransferFunctionElement.type */
  final SVGAnimatedEnumeration type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGCursorElement
interface SVGCursorElement extends SVGElement, SVGURIReference, SVGTests, SVGExternalResourcesRequired {

  /** @domName SVGCursorElement.x */
  final SVGAnimatedLength x;

  /** @domName SVGCursorElement.y */
  final SVGAnimatedLength y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGDefsElement
interface SVGDefsElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGDescElement
interface SVGDescElement extends SVGElement, SVGLangSpace, SVGStylable {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGDocument
interface SVGDocument extends Document {

  /** @domName SVGDocument.rootElement */
  final SVGSVGElement rootElement;

  /** @domName SVGDocument.createEvent */
  Event $dom_createEvent(String eventType);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/// @domName SVGElement
interface SVGElement extends Element default _SVGElementFactoryProvider {

  SVGElement.tag(String tag);
  SVGElement.svg(String svg);

  SVGElement clone(bool deep);


  /** @domName SVGElement.id */
  String id;

  /** @domName SVGElement.ownerSVGElement */
  final SVGSVGElement ownerSVGElement;

  /** @domName SVGElement.viewportElement */
  final SVGElement viewportElement;

  /** @domName SVGElement.xmlbase */
  String xmlbase;

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGElementInstance
interface SVGElementInstance {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  SVGElementInstanceEvents get on();

  /** @domName SVGElementInstance.childNodes */
  final SVGElementInstanceList childNodes;

  /** @domName SVGElementInstance.correspondingElement */
  final SVGElement correspondingElement;

  /** @domName SVGElementInstance.correspondingUseElement */
  final SVGUseElement correspondingUseElement;

  /** @domName SVGElementInstance.firstChild */
  final SVGElementInstance firstChild;

  /** @domName SVGElementInstance.lastChild */
  final SVGElementInstance lastChild;

  /** @domName SVGElementInstance.nextSibling */
  final SVGElementInstance nextSibling;

  /** @domName SVGElementInstance.parentNode */
  final SVGElementInstance parentNode;

  /** @domName SVGElementInstance.previousSibling */
  final SVGElementInstance previousSibling;

  /** @domName SVGElementInstance.addEventListener */
  void addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName SVGElementInstance.dispatchEvent */
  bool dispatchEvent(Event event);

  /** @domName SVGElementInstance.removeEventListener */
  void removeEventListener(String type, EventListener listener, [bool useCapture]);
}

interface SVGElementInstanceEvents extends Events {

  EventListenerList get abort();

  EventListenerList get beforeCopy();

  EventListenerList get beforeCut();

  EventListenerList get beforePaste();

  EventListenerList get blur();

  EventListenerList get change();

  EventListenerList get click();

  EventListenerList get contextMenu();

  EventListenerList get copy();

  EventListenerList get cut();

  EventListenerList get doubleClick();

  EventListenerList get drag();

  EventListenerList get dragEnd();

  EventListenerList get dragEnter();

  EventListenerList get dragLeave();

  EventListenerList get dragOver();

  EventListenerList get dragStart();

  EventListenerList get drop();

  EventListenerList get error();

  EventListenerList get focus();

  EventListenerList get input();

  EventListenerList get keyDown();

  EventListenerList get keyPress();

  EventListenerList get keyUp();

  EventListenerList get load();

  EventListenerList get mouseDown();

  EventListenerList get mouseMove();

  EventListenerList get mouseOut();

  EventListenerList get mouseOver();

  EventListenerList get mouseUp();

  EventListenerList get mouseWheel();

  EventListenerList get paste();

  EventListenerList get reset();

  EventListenerList get resize();

  EventListenerList get scroll();

  EventListenerList get search();

  EventListenerList get select();

  EventListenerList get selectStart();

  EventListenerList get submit();

  EventListenerList get unload();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGElementInstanceList
interface SVGElementInstanceList {

  /** @domName SVGElementInstanceList.length */
  final int length;

  /** @domName SVGElementInstanceList.item */
  SVGElementInstance item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGEllipseElement
interface SVGEllipseElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGEllipseElement.cx */
  final SVGAnimatedLength cx;

  /** @domName SVGEllipseElement.cy */
  final SVGAnimatedLength cy;

  /** @domName SVGEllipseElement.rx */
  final SVGAnimatedLength rx;

  /** @domName SVGEllipseElement.ry */
  final SVGAnimatedLength ry;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGException
interface SVGException {

  static final int SVG_INVALID_VALUE_ERR = 1;

  static final int SVG_MATRIX_NOT_INVERTABLE = 2;

  static final int SVG_WRONG_TYPE_ERR = 0;

  /** @domName SVGException.code */
  final int code;

  /** @domName SVGException.message */
  final String message;

  /** @domName SVGException.name */
  final String name;

  /** @domName SVGException.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGExternalResourcesRequired
interface SVGExternalResourcesRequired {

  /** @domName SVGExternalResourcesRequired.externalResourcesRequired */
  final SVGAnimatedBoolean externalResourcesRequired;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEBlendElement
interface SVGFEBlendElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  static final int SVG_FEBLEND_MODE_DARKEN = 4;

  static final int SVG_FEBLEND_MODE_LIGHTEN = 5;

  static final int SVG_FEBLEND_MODE_MULTIPLY = 2;

  static final int SVG_FEBLEND_MODE_NORMAL = 1;

  static final int SVG_FEBLEND_MODE_SCREEN = 3;

  static final int SVG_FEBLEND_MODE_UNKNOWN = 0;

  /** @domName SVGFEBlendElement.in1 */
  final SVGAnimatedString in1;

  /** @domName SVGFEBlendElement.in2 */
  final SVGAnimatedString in2;

  /** @domName SVGFEBlendElement.mode */
  final SVGAnimatedEnumeration mode;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEColorMatrixElement
interface SVGFEColorMatrixElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  static final int SVG_FECOLORMATRIX_TYPE_HUEROTATE = 3;

  static final int SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA = 4;

  static final int SVG_FECOLORMATRIX_TYPE_MATRIX = 1;

  static final int SVG_FECOLORMATRIX_TYPE_SATURATE = 2;

  static final int SVG_FECOLORMATRIX_TYPE_UNKNOWN = 0;

  /** @domName SVGFEColorMatrixElement.in1 */
  final SVGAnimatedString in1;

  /** @domName SVGFEColorMatrixElement.type */
  final SVGAnimatedEnumeration type;

  /** @domName SVGFEColorMatrixElement.values */
  final SVGAnimatedNumberList values;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEComponentTransferElement
interface SVGFEComponentTransferElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  /** @domName SVGFEComponentTransferElement.in1 */
  final SVGAnimatedString in1;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFECompositeElement
interface SVGFECompositeElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  static final int SVG_FECOMPOSITE_OPERATOR_ARITHMETIC = 6;

  static final int SVG_FECOMPOSITE_OPERATOR_ATOP = 4;

  static final int SVG_FECOMPOSITE_OPERATOR_IN = 2;

  static final int SVG_FECOMPOSITE_OPERATOR_OUT = 3;

  static final int SVG_FECOMPOSITE_OPERATOR_OVER = 1;

  static final int SVG_FECOMPOSITE_OPERATOR_UNKNOWN = 0;

  static final int SVG_FECOMPOSITE_OPERATOR_XOR = 5;

  /** @domName SVGFECompositeElement.in1 */
  final SVGAnimatedString in1;

  /** @domName SVGFECompositeElement.in2 */
  final SVGAnimatedString in2;

  /** @domName SVGFECompositeElement.k1 */
  final SVGAnimatedNumber k1;

  /** @domName SVGFECompositeElement.k2 */
  final SVGAnimatedNumber k2;

  /** @domName SVGFECompositeElement.k3 */
  final SVGAnimatedNumber k3;

  /** @domName SVGFECompositeElement.k4 */
  final SVGAnimatedNumber k4;

  /** @domName SVGFECompositeElement.operator */
  final SVGAnimatedEnumeration operator;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEConvolveMatrixElement
interface SVGFEConvolveMatrixElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  static final int SVG_EDGEMODE_DUPLICATE = 1;

  static final int SVG_EDGEMODE_NONE = 3;

  static final int SVG_EDGEMODE_UNKNOWN = 0;

  static final int SVG_EDGEMODE_WRAP = 2;

  /** @domName SVGFEConvolveMatrixElement.bias */
  final SVGAnimatedNumber bias;

  /** @domName SVGFEConvolveMatrixElement.divisor */
  final SVGAnimatedNumber divisor;

  /** @domName SVGFEConvolveMatrixElement.edgeMode */
  final SVGAnimatedEnumeration edgeMode;

  /** @domName SVGFEConvolveMatrixElement.in1 */
  final SVGAnimatedString in1;

  /** @domName SVGFEConvolveMatrixElement.kernelMatrix */
  final SVGAnimatedNumberList kernelMatrix;

  /** @domName SVGFEConvolveMatrixElement.kernelUnitLengthX */
  final SVGAnimatedNumber kernelUnitLengthX;

  /** @domName SVGFEConvolveMatrixElement.kernelUnitLengthY */
  final SVGAnimatedNumber kernelUnitLengthY;

  /** @domName SVGFEConvolveMatrixElement.orderX */
  final SVGAnimatedInteger orderX;

  /** @domName SVGFEConvolveMatrixElement.orderY */
  final SVGAnimatedInteger orderY;

  /** @domName SVGFEConvolveMatrixElement.preserveAlpha */
  final SVGAnimatedBoolean preserveAlpha;

  /** @domName SVGFEConvolveMatrixElement.targetX */
  final SVGAnimatedInteger targetX;

  /** @domName SVGFEConvolveMatrixElement.targetY */
  final SVGAnimatedInteger targetY;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEDiffuseLightingElement
interface SVGFEDiffuseLightingElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  /** @domName SVGFEDiffuseLightingElement.diffuseConstant */
  final SVGAnimatedNumber diffuseConstant;

  /** @domName SVGFEDiffuseLightingElement.in1 */
  final SVGAnimatedString in1;

  /** @domName SVGFEDiffuseLightingElement.kernelUnitLengthX */
  final SVGAnimatedNumber kernelUnitLengthX;

  /** @domName SVGFEDiffuseLightingElement.kernelUnitLengthY */
  final SVGAnimatedNumber kernelUnitLengthY;

  /** @domName SVGFEDiffuseLightingElement.surfaceScale */
  final SVGAnimatedNumber surfaceScale;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEDisplacementMapElement
interface SVGFEDisplacementMapElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  static final int SVG_CHANNEL_A = 4;

  static final int SVG_CHANNEL_B = 3;

  static final int SVG_CHANNEL_G = 2;

  static final int SVG_CHANNEL_R = 1;

  static final int SVG_CHANNEL_UNKNOWN = 0;

  /** @domName SVGFEDisplacementMapElement.in1 */
  final SVGAnimatedString in1;

  /** @domName SVGFEDisplacementMapElement.in2 */
  final SVGAnimatedString in2;

  /** @domName SVGFEDisplacementMapElement.scale */
  final SVGAnimatedNumber scale;

  /** @domName SVGFEDisplacementMapElement.xChannelSelector */
  final SVGAnimatedEnumeration xChannelSelector;

  /** @domName SVGFEDisplacementMapElement.yChannelSelector */
  final SVGAnimatedEnumeration yChannelSelector;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEDistantLightElement
interface SVGFEDistantLightElement extends SVGElement {

  /** @domName SVGFEDistantLightElement.azimuth */
  final SVGAnimatedNumber azimuth;

  /** @domName SVGFEDistantLightElement.elevation */
  final SVGAnimatedNumber elevation;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEDropShadowElement
interface SVGFEDropShadowElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  /** @domName SVGFEDropShadowElement.dx */
  final SVGAnimatedNumber dx;

  /** @domName SVGFEDropShadowElement.dy */
  final SVGAnimatedNumber dy;

  /** @domName SVGFEDropShadowElement.in1 */
  final SVGAnimatedString in1;

  /** @domName SVGFEDropShadowElement.stdDeviationX */
  final SVGAnimatedNumber stdDeviationX;

  /** @domName SVGFEDropShadowElement.stdDeviationY */
  final SVGAnimatedNumber stdDeviationY;

  /** @domName SVGFEDropShadowElement.setStdDeviation */
  void setStdDeviation(num stdDeviationX, num stdDeviationY);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEFloodElement
interface SVGFEFloodElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEFuncAElement
interface SVGFEFuncAElement extends SVGComponentTransferFunctionElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEFuncBElement
interface SVGFEFuncBElement extends SVGComponentTransferFunctionElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEFuncGElement
interface SVGFEFuncGElement extends SVGComponentTransferFunctionElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEFuncRElement
interface SVGFEFuncRElement extends SVGComponentTransferFunctionElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEGaussianBlurElement
interface SVGFEGaussianBlurElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  /** @domName SVGFEGaussianBlurElement.in1 */
  final SVGAnimatedString in1;

  /** @domName SVGFEGaussianBlurElement.stdDeviationX */
  final SVGAnimatedNumber stdDeviationX;

  /** @domName SVGFEGaussianBlurElement.stdDeviationY */
  final SVGAnimatedNumber stdDeviationY;

  /** @domName SVGFEGaussianBlurElement.setStdDeviation */
  void setStdDeviation(num stdDeviationX, num stdDeviationY);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEImageElement
interface SVGFEImageElement extends SVGElement, SVGURIReference, SVGLangSpace, SVGExternalResourcesRequired, SVGFilterPrimitiveStandardAttributes {

  /** @domName SVGFEImageElement.preserveAspectRatio */
  final SVGAnimatedPreserveAspectRatio preserveAspectRatio;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEMergeElement
interface SVGFEMergeElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEMergeNodeElement
interface SVGFEMergeNodeElement extends SVGElement {

  /** @domName SVGFEMergeNodeElement.in1 */
  final SVGAnimatedString in1;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEMorphologyElement
interface SVGFEMorphologyElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  static final int SVG_MORPHOLOGY_OPERATOR_DILATE = 2;

  static final int SVG_MORPHOLOGY_OPERATOR_ERODE = 1;

  static final int SVG_MORPHOLOGY_OPERATOR_UNKNOWN = 0;

  /** @domName SVGFEMorphologyElement.in1 */
  final SVGAnimatedString in1;

  /** @domName SVGFEMorphologyElement.operator */
  final SVGAnimatedEnumeration operator;

  /** @domName SVGFEMorphologyElement.radiusX */
  final SVGAnimatedNumber radiusX;

  /** @domName SVGFEMorphologyElement.radiusY */
  final SVGAnimatedNumber radiusY;

  /** @domName SVGFEMorphologyElement.setRadius */
  void setRadius(num radiusX, num radiusY);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEOffsetElement
interface SVGFEOffsetElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  /** @domName SVGFEOffsetElement.dx */
  final SVGAnimatedNumber dx;

  /** @domName SVGFEOffsetElement.dy */
  final SVGAnimatedNumber dy;

  /** @domName SVGFEOffsetElement.in1 */
  final SVGAnimatedString in1;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFEPointLightElement
interface SVGFEPointLightElement extends SVGElement {

  /** @domName SVGFEPointLightElement.x */
  final SVGAnimatedNumber x;

  /** @domName SVGFEPointLightElement.y */
  final SVGAnimatedNumber y;

  /** @domName SVGFEPointLightElement.z */
  final SVGAnimatedNumber z;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFESpecularLightingElement
interface SVGFESpecularLightingElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  /** @domName SVGFESpecularLightingElement.in1 */
  final SVGAnimatedString in1;

  /** @domName SVGFESpecularLightingElement.specularConstant */
  final SVGAnimatedNumber specularConstant;

  /** @domName SVGFESpecularLightingElement.specularExponent */
  final SVGAnimatedNumber specularExponent;

  /** @domName SVGFESpecularLightingElement.surfaceScale */
  final SVGAnimatedNumber surfaceScale;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFESpotLightElement
interface SVGFESpotLightElement extends SVGElement {

  /** @domName SVGFESpotLightElement.limitingConeAngle */
  final SVGAnimatedNumber limitingConeAngle;

  /** @domName SVGFESpotLightElement.pointsAtX */
  final SVGAnimatedNumber pointsAtX;

  /** @domName SVGFESpotLightElement.pointsAtY */
  final SVGAnimatedNumber pointsAtY;

  /** @domName SVGFESpotLightElement.pointsAtZ */
  final SVGAnimatedNumber pointsAtZ;

  /** @domName SVGFESpotLightElement.specularExponent */
  final SVGAnimatedNumber specularExponent;

  /** @domName SVGFESpotLightElement.x */
  final SVGAnimatedNumber x;

  /** @domName SVGFESpotLightElement.y */
  final SVGAnimatedNumber y;

  /** @domName SVGFESpotLightElement.z */
  final SVGAnimatedNumber z;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFETileElement
interface SVGFETileElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  /** @domName SVGFETileElement.in1 */
  final SVGAnimatedString in1;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFETurbulenceElement
interface SVGFETurbulenceElement extends SVGElement, SVGFilterPrimitiveStandardAttributes {

  static final int SVG_STITCHTYPE_NOSTITCH = 2;

  static final int SVG_STITCHTYPE_STITCH = 1;

  static final int SVG_STITCHTYPE_UNKNOWN = 0;

  static final int SVG_TURBULENCE_TYPE_FRACTALNOISE = 1;

  static final int SVG_TURBULENCE_TYPE_TURBULENCE = 2;

  static final int SVG_TURBULENCE_TYPE_UNKNOWN = 0;

  /** @domName SVGFETurbulenceElement.baseFrequencyX */
  final SVGAnimatedNumber baseFrequencyX;

  /** @domName SVGFETurbulenceElement.baseFrequencyY */
  final SVGAnimatedNumber baseFrequencyY;

  /** @domName SVGFETurbulenceElement.numOctaves */
  final SVGAnimatedInteger numOctaves;

  /** @domName SVGFETurbulenceElement.seed */
  final SVGAnimatedNumber seed;

  /** @domName SVGFETurbulenceElement.stitchTiles */
  final SVGAnimatedEnumeration stitchTiles;

  /** @domName SVGFETurbulenceElement.type */
  final SVGAnimatedEnumeration type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFilterElement
interface SVGFilterElement extends SVGElement, SVGURIReference, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable {

  /** @domName SVGFilterElement.filterResX */
  final SVGAnimatedInteger filterResX;

  /** @domName SVGFilterElement.filterResY */
  final SVGAnimatedInteger filterResY;

  /** @domName SVGFilterElement.filterUnits */
  final SVGAnimatedEnumeration filterUnits;

  /** @domName SVGFilterElement.height */
  final SVGAnimatedLength height;

  /** @domName SVGFilterElement.primitiveUnits */
  final SVGAnimatedEnumeration primitiveUnits;

  /** @domName SVGFilterElement.width */
  final SVGAnimatedLength width;

  /** @domName SVGFilterElement.x */
  final SVGAnimatedLength x;

  /** @domName SVGFilterElement.y */
  final SVGAnimatedLength y;

  /** @domName SVGFilterElement.setFilterRes */
  void setFilterRes(int filterResX, int filterResY);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFilterPrimitiveStandardAttributes
interface SVGFilterPrimitiveStandardAttributes extends SVGStylable {

  /** @domName SVGFilterPrimitiveStandardAttributes.height */
  final SVGAnimatedLength height;

  /** @domName SVGFilterPrimitiveStandardAttributes.result */
  final SVGAnimatedString result;

  /** @domName SVGFilterPrimitiveStandardAttributes.width */
  final SVGAnimatedLength width;

  /** @domName SVGFilterPrimitiveStandardAttributes.x */
  final SVGAnimatedLength x;

  /** @domName SVGFilterPrimitiveStandardAttributes.y */
  final SVGAnimatedLength y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFitToViewBox
interface SVGFitToViewBox {

  /** @domName SVGFitToViewBox.preserveAspectRatio */
  final SVGAnimatedPreserveAspectRatio preserveAspectRatio;

  /** @domName SVGFitToViewBox.viewBox */
  final SVGAnimatedRect viewBox;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFontElement
interface SVGFontElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFontFaceElement
interface SVGFontFaceElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFontFaceFormatElement
interface SVGFontFaceFormatElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFontFaceNameElement
interface SVGFontFaceNameElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFontFaceSrcElement
interface SVGFontFaceSrcElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGFontFaceUriElement
interface SVGFontFaceUriElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGForeignObjectElement
interface SVGForeignObjectElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGForeignObjectElement.height */
  final SVGAnimatedLength height;

  /** @domName SVGForeignObjectElement.width */
  final SVGAnimatedLength width;

  /** @domName SVGForeignObjectElement.x */
  final SVGAnimatedLength x;

  /** @domName SVGForeignObjectElement.y */
  final SVGAnimatedLength y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGGElement
interface SVGGElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGGlyphElement
interface SVGGlyphElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGGlyphRefElement
interface SVGGlyphRefElement extends SVGElement, SVGURIReference, SVGStylable {

  /** @domName SVGGlyphRefElement.dx */
  num dx;

  /** @domName SVGGlyphRefElement.dy */
  num dy;

  /** @domName SVGGlyphRefElement.format */
  String format;

  /** @domName SVGGlyphRefElement.glyphRef */
  String glyphRef;

  /** @domName SVGGlyphRefElement.x */
  num x;

  /** @domName SVGGlyphRefElement.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGGradientElement
interface SVGGradientElement extends SVGElement, SVGURIReference, SVGExternalResourcesRequired, SVGStylable {

  static final int SVG_SPREADMETHOD_PAD = 1;

  static final int SVG_SPREADMETHOD_REFLECT = 2;

  static final int SVG_SPREADMETHOD_REPEAT = 3;

  static final int SVG_SPREADMETHOD_UNKNOWN = 0;

  /** @domName SVGGradientElement.gradientTransform */
  final SVGAnimatedTransformList gradientTransform;

  /** @domName SVGGradientElement.gradientUnits */
  final SVGAnimatedEnumeration gradientUnits;

  /** @domName SVGGradientElement.spreadMethod */
  final SVGAnimatedEnumeration spreadMethod;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGHKernElement
interface SVGHKernElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGImageElement
interface SVGImageElement extends SVGElement, SVGURIReference, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGImageElement.height */
  final SVGAnimatedLength height;

  /** @domName SVGImageElement.preserveAspectRatio */
  final SVGAnimatedPreserveAspectRatio preserveAspectRatio;

  /** @domName SVGImageElement.width */
  final SVGAnimatedLength width;

  /** @domName SVGImageElement.x */
  final SVGAnimatedLength x;

  /** @domName SVGImageElement.y */
  final SVGAnimatedLength y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGLangSpace
interface SVGLangSpace {

  /** @domName SVGLangSpace.xmllang */
  String xmllang;

  /** @domName SVGLangSpace.xmlspace */
  String xmlspace;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGLength
interface SVGLength {

  static final int SVG_LENGTHTYPE_CM = 6;

  static final int SVG_LENGTHTYPE_EMS = 3;

  static final int SVG_LENGTHTYPE_EXS = 4;

  static final int SVG_LENGTHTYPE_IN = 8;

  static final int SVG_LENGTHTYPE_MM = 7;

  static final int SVG_LENGTHTYPE_NUMBER = 1;

  static final int SVG_LENGTHTYPE_PC = 10;

  static final int SVG_LENGTHTYPE_PERCENTAGE = 2;

  static final int SVG_LENGTHTYPE_PT = 9;

  static final int SVG_LENGTHTYPE_PX = 5;

  static final int SVG_LENGTHTYPE_UNKNOWN = 0;

  /** @domName SVGLength.unitType */
  final int unitType;

  /** @domName SVGLength.value */
  num value;

  /** @domName SVGLength.valueAsString */
  String valueAsString;

  /** @domName SVGLength.valueInSpecifiedUnits */
  num valueInSpecifiedUnits;

  /** @domName SVGLength.convertToSpecifiedUnits */
  void convertToSpecifiedUnits(int unitType);

  /** @domName SVGLength.newValueSpecifiedUnits */
  void newValueSpecifiedUnits(int unitType, num valueInSpecifiedUnits);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGLengthList
interface SVGLengthList {

  /** @domName SVGLengthList.numberOfItems */
  final int numberOfItems;

  /** @domName SVGLengthList.appendItem */
  SVGLength appendItem(SVGLength item);

  /** @domName SVGLengthList.clear */
  void clear();

  /** @domName SVGLengthList.getItem */
  SVGLength getItem(int index);

  /** @domName SVGLengthList.initialize */
  SVGLength initialize(SVGLength item);

  /** @domName SVGLengthList.insertItemBefore */
  SVGLength insertItemBefore(SVGLength item, int index);

  /** @domName SVGLengthList.removeItem */
  SVGLength removeItem(int index);

  /** @domName SVGLengthList.replaceItem */
  SVGLength replaceItem(SVGLength item, int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGLineElement
interface SVGLineElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGLineElement.x1 */
  final SVGAnimatedLength x1;

  /** @domName SVGLineElement.x2 */
  final SVGAnimatedLength x2;

  /** @domName SVGLineElement.y1 */
  final SVGAnimatedLength y1;

  /** @domName SVGLineElement.y2 */
  final SVGAnimatedLength y2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGLinearGradientElement
interface SVGLinearGradientElement extends SVGGradientElement {

  /** @domName SVGLinearGradientElement.x1 */
  final SVGAnimatedLength x1;

  /** @domName SVGLinearGradientElement.x2 */
  final SVGAnimatedLength x2;

  /** @domName SVGLinearGradientElement.y1 */
  final SVGAnimatedLength y1;

  /** @domName SVGLinearGradientElement.y2 */
  final SVGAnimatedLength y2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGLocatable
interface SVGLocatable {

  /** @domName SVGLocatable.farthestViewportElement */
  final SVGElement farthestViewportElement;

  /** @domName SVGLocatable.nearestViewportElement */
  final SVGElement nearestViewportElement;

  /** @domName SVGLocatable.getBBox */
  SVGRect getBBox();

  /** @domName SVGLocatable.getCTM */
  SVGMatrix getCTM();

  /** @domName SVGLocatable.getScreenCTM */
  SVGMatrix getScreenCTM();

  /** @domName SVGLocatable.getTransformToElement */
  SVGMatrix getTransformToElement(SVGElement element);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGMPathElement
interface SVGMPathElement extends SVGElement, SVGURIReference, SVGExternalResourcesRequired {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGMarkerElement
interface SVGMarkerElement extends SVGElement, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGFitToViewBox {

  static final int SVG_MARKERUNITS_STROKEWIDTH = 2;

  static final int SVG_MARKERUNITS_UNKNOWN = 0;

  static final int SVG_MARKERUNITS_USERSPACEONUSE = 1;

  static final int SVG_MARKER_ORIENT_ANGLE = 2;

  static final int SVG_MARKER_ORIENT_AUTO = 1;

  static final int SVG_MARKER_ORIENT_UNKNOWN = 0;

  /** @domName SVGMarkerElement.markerHeight */
  final SVGAnimatedLength markerHeight;

  /** @domName SVGMarkerElement.markerUnits */
  final SVGAnimatedEnumeration markerUnits;

  /** @domName SVGMarkerElement.markerWidth */
  final SVGAnimatedLength markerWidth;

  /** @domName SVGMarkerElement.orientAngle */
  final SVGAnimatedAngle orientAngle;

  /** @domName SVGMarkerElement.orientType */
  final SVGAnimatedEnumeration orientType;

  /** @domName SVGMarkerElement.refX */
  final SVGAnimatedLength refX;

  /** @domName SVGMarkerElement.refY */
  final SVGAnimatedLength refY;

  /** @domName SVGMarkerElement.setOrientToAngle */
  void setOrientToAngle(SVGAngle angle);

  /** @domName SVGMarkerElement.setOrientToAuto */
  void setOrientToAuto();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGMaskElement
interface SVGMaskElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable {

  /** @domName SVGMaskElement.height */
  final SVGAnimatedLength height;

  /** @domName SVGMaskElement.maskContentUnits */
  final SVGAnimatedEnumeration maskContentUnits;

  /** @domName SVGMaskElement.maskUnits */
  final SVGAnimatedEnumeration maskUnits;

  /** @domName SVGMaskElement.width */
  final SVGAnimatedLength width;

  /** @domName SVGMaskElement.x */
  final SVGAnimatedLength x;

  /** @domName SVGMaskElement.y */
  final SVGAnimatedLength y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGMatrix
interface SVGMatrix {

  /** @domName SVGMatrix.a */
  num a;

  /** @domName SVGMatrix.b */
  num b;

  /** @domName SVGMatrix.c */
  num c;

  /** @domName SVGMatrix.d */
  num d;

  /** @domName SVGMatrix.e */
  num e;

  /** @domName SVGMatrix.f */
  num f;

  /** @domName SVGMatrix.flipX */
  SVGMatrix flipX();

  /** @domName SVGMatrix.flipY */
  SVGMatrix flipY();

  /** @domName SVGMatrix.inverse */
  SVGMatrix inverse();

  /** @domName SVGMatrix.multiply */
  SVGMatrix multiply(SVGMatrix secondMatrix);

  /** @domName SVGMatrix.rotate */
  SVGMatrix rotate(num angle);

  /** @domName SVGMatrix.rotateFromVector */
  SVGMatrix rotateFromVector(num x, num y);

  /** @domName SVGMatrix.scale */
  SVGMatrix scale(num scaleFactor);

  /** @domName SVGMatrix.scaleNonUniform */
  SVGMatrix scaleNonUniform(num scaleFactorX, num scaleFactorY);

  /** @domName SVGMatrix.skewX */
  SVGMatrix skewX(num angle);

  /** @domName SVGMatrix.skewY */
  SVGMatrix skewY(num angle);

  /** @domName SVGMatrix.translate */
  SVGMatrix translate(num x, num y);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGMetadataElement
interface SVGMetadataElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGMissingGlyphElement
interface SVGMissingGlyphElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGNumber
interface SVGNumber {

  /** @domName SVGNumber.value */
  num value;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGNumberList
interface SVGNumberList {

  /** @domName SVGNumberList.numberOfItems */
  final int numberOfItems;

  /** @domName SVGNumberList.appendItem */
  SVGNumber appendItem(SVGNumber item);

  /** @domName SVGNumberList.clear */
  void clear();

  /** @domName SVGNumberList.getItem */
  SVGNumber getItem(int index);

  /** @domName SVGNumberList.initialize */
  SVGNumber initialize(SVGNumber item);

  /** @domName SVGNumberList.insertItemBefore */
  SVGNumber insertItemBefore(SVGNumber item, int index);

  /** @domName SVGNumberList.removeItem */
  SVGNumber removeItem(int index);

  /** @domName SVGNumberList.replaceItem */
  SVGNumber replaceItem(SVGNumber item, int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPaint
interface SVGPaint extends SVGColor {

  static final int SVG_PAINTTYPE_CURRENTCOLOR = 102;

  static final int SVG_PAINTTYPE_NONE = 101;

  static final int SVG_PAINTTYPE_RGBCOLOR = 1;

  static final int SVG_PAINTTYPE_RGBCOLOR_ICCCOLOR = 2;

  static final int SVG_PAINTTYPE_UNKNOWN = 0;

  static final int SVG_PAINTTYPE_URI = 107;

  static final int SVG_PAINTTYPE_URI_CURRENTCOLOR = 104;

  static final int SVG_PAINTTYPE_URI_NONE = 103;

  static final int SVG_PAINTTYPE_URI_RGBCOLOR = 105;

  static final int SVG_PAINTTYPE_URI_RGBCOLOR_ICCCOLOR = 106;

  /** @domName SVGPaint.paintType */
  final int paintType;

  /** @domName SVGPaint.uri */
  final String uri;

  /** @domName SVGPaint.setPaint */
  void setPaint(int paintType, String uri, String rgbColor, String iccColor);

  /** @domName SVGPaint.setUri */
  void setUri(String uri);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathElement
interface SVGPathElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGPathElement.animatedNormalizedPathSegList */
  final SVGPathSegList animatedNormalizedPathSegList;

  /** @domName SVGPathElement.animatedPathSegList */
  final SVGPathSegList animatedPathSegList;

  /** @domName SVGPathElement.normalizedPathSegList */
  final SVGPathSegList normalizedPathSegList;

  /** @domName SVGPathElement.pathLength */
  final SVGAnimatedNumber pathLength;

  /** @domName SVGPathElement.pathSegList */
  final SVGPathSegList pathSegList;

  /** @domName SVGPathElement.createSVGPathSegArcAbs */
  SVGPathSegArcAbs createSVGPathSegArcAbs(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag);

  /** @domName SVGPathElement.createSVGPathSegArcRel */
  SVGPathSegArcRel createSVGPathSegArcRel(num x, num y, num r1, num r2, num angle, bool largeArcFlag, bool sweepFlag);

  /** @domName SVGPathElement.createSVGPathSegClosePath */
  SVGPathSegClosePath createSVGPathSegClosePath();

  /** @domName SVGPathElement.createSVGPathSegCurvetoCubicAbs */
  SVGPathSegCurvetoCubicAbs createSVGPathSegCurvetoCubicAbs(num x, num y, num x1, num y1, num x2, num y2);

  /** @domName SVGPathElement.createSVGPathSegCurvetoCubicRel */
  SVGPathSegCurvetoCubicRel createSVGPathSegCurvetoCubicRel(num x, num y, num x1, num y1, num x2, num y2);

  /** @domName SVGPathElement.createSVGPathSegCurvetoCubicSmoothAbs */
  SVGPathSegCurvetoCubicSmoothAbs createSVGPathSegCurvetoCubicSmoothAbs(num x, num y, num x2, num y2);

  /** @domName SVGPathElement.createSVGPathSegCurvetoCubicSmoothRel */
  SVGPathSegCurvetoCubicSmoothRel createSVGPathSegCurvetoCubicSmoothRel(num x, num y, num x2, num y2);

  /** @domName SVGPathElement.createSVGPathSegCurvetoQuadraticAbs */
  SVGPathSegCurvetoQuadraticAbs createSVGPathSegCurvetoQuadraticAbs(num x, num y, num x1, num y1);

  /** @domName SVGPathElement.createSVGPathSegCurvetoQuadraticRel */
  SVGPathSegCurvetoQuadraticRel createSVGPathSegCurvetoQuadraticRel(num x, num y, num x1, num y1);

  /** @domName SVGPathElement.createSVGPathSegCurvetoQuadraticSmoothAbs */
  SVGPathSegCurvetoQuadraticSmoothAbs createSVGPathSegCurvetoQuadraticSmoothAbs(num x, num y);

  /** @domName SVGPathElement.createSVGPathSegCurvetoQuadraticSmoothRel */
  SVGPathSegCurvetoQuadraticSmoothRel createSVGPathSegCurvetoQuadraticSmoothRel(num x, num y);

  /** @domName SVGPathElement.createSVGPathSegLinetoAbs */
  SVGPathSegLinetoAbs createSVGPathSegLinetoAbs(num x, num y);

  /** @domName SVGPathElement.createSVGPathSegLinetoHorizontalAbs */
  SVGPathSegLinetoHorizontalAbs createSVGPathSegLinetoHorizontalAbs(num x);

  /** @domName SVGPathElement.createSVGPathSegLinetoHorizontalRel */
  SVGPathSegLinetoHorizontalRel createSVGPathSegLinetoHorizontalRel(num x);

  /** @domName SVGPathElement.createSVGPathSegLinetoRel */
  SVGPathSegLinetoRel createSVGPathSegLinetoRel(num x, num y);

  /** @domName SVGPathElement.createSVGPathSegLinetoVerticalAbs */
  SVGPathSegLinetoVerticalAbs createSVGPathSegLinetoVerticalAbs(num y);

  /** @domName SVGPathElement.createSVGPathSegLinetoVerticalRel */
  SVGPathSegLinetoVerticalRel createSVGPathSegLinetoVerticalRel(num y);

  /** @domName SVGPathElement.createSVGPathSegMovetoAbs */
  SVGPathSegMovetoAbs createSVGPathSegMovetoAbs(num x, num y);

  /** @domName SVGPathElement.createSVGPathSegMovetoRel */
  SVGPathSegMovetoRel createSVGPathSegMovetoRel(num x, num y);

  /** @domName SVGPathElement.getPathSegAtLength */
  int getPathSegAtLength(num distance);

  /** @domName SVGPathElement.getPointAtLength */
  SVGPoint getPointAtLength(num distance);

  /** @domName SVGPathElement.getTotalLength */
  num getTotalLength();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSeg
interface SVGPathSeg {

  static final int PATHSEG_ARC_ABS = 10;

  static final int PATHSEG_ARC_REL = 11;

  static final int PATHSEG_CLOSEPATH = 1;

  static final int PATHSEG_CURVETO_CUBIC_ABS = 6;

  static final int PATHSEG_CURVETO_CUBIC_REL = 7;

  static final int PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16;

  static final int PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17;

  static final int PATHSEG_CURVETO_QUADRATIC_ABS = 8;

  static final int PATHSEG_CURVETO_QUADRATIC_REL = 9;

  static final int PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18;

  static final int PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19;

  static final int PATHSEG_LINETO_ABS = 4;

  static final int PATHSEG_LINETO_HORIZONTAL_ABS = 12;

  static final int PATHSEG_LINETO_HORIZONTAL_REL = 13;

  static final int PATHSEG_LINETO_REL = 5;

  static final int PATHSEG_LINETO_VERTICAL_ABS = 14;

  static final int PATHSEG_LINETO_VERTICAL_REL = 15;

  static final int PATHSEG_MOVETO_ABS = 2;

  static final int PATHSEG_MOVETO_REL = 3;

  static final int PATHSEG_UNKNOWN = 0;

  /** @domName SVGPathSeg.pathSegType */
  final int pathSegType;

  /** @domName SVGPathSeg.pathSegTypeAsLetter */
  final String pathSegTypeAsLetter;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegArcAbs
interface SVGPathSegArcAbs extends SVGPathSeg {

  /** @domName SVGPathSegArcAbs.angle */
  num angle;

  /** @domName SVGPathSegArcAbs.largeArcFlag */
  bool largeArcFlag;

  /** @domName SVGPathSegArcAbs.r1 */
  num r1;

  /** @domName SVGPathSegArcAbs.r2 */
  num r2;

  /** @domName SVGPathSegArcAbs.sweepFlag */
  bool sweepFlag;

  /** @domName SVGPathSegArcAbs.x */
  num x;

  /** @domName SVGPathSegArcAbs.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegArcRel
interface SVGPathSegArcRel extends SVGPathSeg {

  /** @domName SVGPathSegArcRel.angle */
  num angle;

  /** @domName SVGPathSegArcRel.largeArcFlag */
  bool largeArcFlag;

  /** @domName SVGPathSegArcRel.r1 */
  num r1;

  /** @domName SVGPathSegArcRel.r2 */
  num r2;

  /** @domName SVGPathSegArcRel.sweepFlag */
  bool sweepFlag;

  /** @domName SVGPathSegArcRel.x */
  num x;

  /** @domName SVGPathSegArcRel.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegClosePath
interface SVGPathSegClosePath extends SVGPathSeg {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegCurvetoCubicAbs
interface SVGPathSegCurvetoCubicAbs extends SVGPathSeg {

  /** @domName SVGPathSegCurvetoCubicAbs.x */
  num x;

  /** @domName SVGPathSegCurvetoCubicAbs.x1 */
  num x1;

  /** @domName SVGPathSegCurvetoCubicAbs.x2 */
  num x2;

  /** @domName SVGPathSegCurvetoCubicAbs.y */
  num y;

  /** @domName SVGPathSegCurvetoCubicAbs.y1 */
  num y1;

  /** @domName SVGPathSegCurvetoCubicAbs.y2 */
  num y2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegCurvetoCubicRel
interface SVGPathSegCurvetoCubicRel extends SVGPathSeg {

  /** @domName SVGPathSegCurvetoCubicRel.x */
  num x;

  /** @domName SVGPathSegCurvetoCubicRel.x1 */
  num x1;

  /** @domName SVGPathSegCurvetoCubicRel.x2 */
  num x2;

  /** @domName SVGPathSegCurvetoCubicRel.y */
  num y;

  /** @domName SVGPathSegCurvetoCubicRel.y1 */
  num y1;

  /** @domName SVGPathSegCurvetoCubicRel.y2 */
  num y2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegCurvetoCubicSmoothAbs
interface SVGPathSegCurvetoCubicSmoothAbs extends SVGPathSeg {

  /** @domName SVGPathSegCurvetoCubicSmoothAbs.x */
  num x;

  /** @domName SVGPathSegCurvetoCubicSmoothAbs.x2 */
  num x2;

  /** @domName SVGPathSegCurvetoCubicSmoothAbs.y */
  num y;

  /** @domName SVGPathSegCurvetoCubicSmoothAbs.y2 */
  num y2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegCurvetoCubicSmoothRel
interface SVGPathSegCurvetoCubicSmoothRel extends SVGPathSeg {

  /** @domName SVGPathSegCurvetoCubicSmoothRel.x */
  num x;

  /** @domName SVGPathSegCurvetoCubicSmoothRel.x2 */
  num x2;

  /** @domName SVGPathSegCurvetoCubicSmoothRel.y */
  num y;

  /** @domName SVGPathSegCurvetoCubicSmoothRel.y2 */
  num y2;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegCurvetoQuadraticAbs
interface SVGPathSegCurvetoQuadraticAbs extends SVGPathSeg {

  /** @domName SVGPathSegCurvetoQuadraticAbs.x */
  num x;

  /** @domName SVGPathSegCurvetoQuadraticAbs.x1 */
  num x1;

  /** @domName SVGPathSegCurvetoQuadraticAbs.y */
  num y;

  /** @domName SVGPathSegCurvetoQuadraticAbs.y1 */
  num y1;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegCurvetoQuadraticRel
interface SVGPathSegCurvetoQuadraticRel extends SVGPathSeg {

  /** @domName SVGPathSegCurvetoQuadraticRel.x */
  num x;

  /** @domName SVGPathSegCurvetoQuadraticRel.x1 */
  num x1;

  /** @domName SVGPathSegCurvetoQuadraticRel.y */
  num y;

  /** @domName SVGPathSegCurvetoQuadraticRel.y1 */
  num y1;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegCurvetoQuadraticSmoothAbs
interface SVGPathSegCurvetoQuadraticSmoothAbs extends SVGPathSeg {

  /** @domName SVGPathSegCurvetoQuadraticSmoothAbs.x */
  num x;

  /** @domName SVGPathSegCurvetoQuadraticSmoothAbs.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegCurvetoQuadraticSmoothRel
interface SVGPathSegCurvetoQuadraticSmoothRel extends SVGPathSeg {

  /** @domName SVGPathSegCurvetoQuadraticSmoothRel.x */
  num x;

  /** @domName SVGPathSegCurvetoQuadraticSmoothRel.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegLinetoAbs
interface SVGPathSegLinetoAbs extends SVGPathSeg {

  /** @domName SVGPathSegLinetoAbs.x */
  num x;

  /** @domName SVGPathSegLinetoAbs.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegLinetoHorizontalAbs
interface SVGPathSegLinetoHorizontalAbs extends SVGPathSeg {

  /** @domName SVGPathSegLinetoHorizontalAbs.x */
  num x;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegLinetoHorizontalRel
interface SVGPathSegLinetoHorizontalRel extends SVGPathSeg {

  /** @domName SVGPathSegLinetoHorizontalRel.x */
  num x;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegLinetoRel
interface SVGPathSegLinetoRel extends SVGPathSeg {

  /** @domName SVGPathSegLinetoRel.x */
  num x;

  /** @domName SVGPathSegLinetoRel.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegLinetoVerticalAbs
interface SVGPathSegLinetoVerticalAbs extends SVGPathSeg {

  /** @domName SVGPathSegLinetoVerticalAbs.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegLinetoVerticalRel
interface SVGPathSegLinetoVerticalRel extends SVGPathSeg {

  /** @domName SVGPathSegLinetoVerticalRel.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegList
interface SVGPathSegList {

  /** @domName SVGPathSegList.numberOfItems */
  final int numberOfItems;

  /** @domName SVGPathSegList.appendItem */
  SVGPathSeg appendItem(SVGPathSeg newItem);

  /** @domName SVGPathSegList.clear */
  void clear();

  /** @domName SVGPathSegList.getItem */
  SVGPathSeg getItem(int index);

  /** @domName SVGPathSegList.initialize */
  SVGPathSeg initialize(SVGPathSeg newItem);

  /** @domName SVGPathSegList.insertItemBefore */
  SVGPathSeg insertItemBefore(SVGPathSeg newItem, int index);

  /** @domName SVGPathSegList.removeItem */
  SVGPathSeg removeItem(int index);

  /** @domName SVGPathSegList.replaceItem */
  SVGPathSeg replaceItem(SVGPathSeg newItem, int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegMovetoAbs
interface SVGPathSegMovetoAbs extends SVGPathSeg {

  /** @domName SVGPathSegMovetoAbs.x */
  num x;

  /** @domName SVGPathSegMovetoAbs.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPathSegMovetoRel
interface SVGPathSegMovetoRel extends SVGPathSeg {

  /** @domName SVGPathSegMovetoRel.x */
  num x;

  /** @domName SVGPathSegMovetoRel.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPatternElement
interface SVGPatternElement extends SVGElement, SVGURIReference, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGFitToViewBox {

  /** @domName SVGPatternElement.height */
  final SVGAnimatedLength height;

  /** @domName SVGPatternElement.patternContentUnits */
  final SVGAnimatedEnumeration patternContentUnits;

  /** @domName SVGPatternElement.patternTransform */
  final SVGAnimatedTransformList patternTransform;

  /** @domName SVGPatternElement.patternUnits */
  final SVGAnimatedEnumeration patternUnits;

  /** @domName SVGPatternElement.width */
  final SVGAnimatedLength width;

  /** @domName SVGPatternElement.x */
  final SVGAnimatedLength x;

  /** @domName SVGPatternElement.y */
  final SVGAnimatedLength y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPoint
interface SVGPoint {

  /** @domName SVGPoint.x */
  num x;

  /** @domName SVGPoint.y */
  num y;

  /** @domName SVGPoint.matrixTransform */
  SVGPoint matrixTransform(SVGMatrix matrix);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPointList
interface SVGPointList {

  /** @domName SVGPointList.numberOfItems */
  final int numberOfItems;

  /** @domName SVGPointList.appendItem */
  SVGPoint appendItem(SVGPoint item);

  /** @domName SVGPointList.clear */
  void clear();

  /** @domName SVGPointList.getItem */
  SVGPoint getItem(int index);

  /** @domName SVGPointList.initialize */
  SVGPoint initialize(SVGPoint item);

  /** @domName SVGPointList.insertItemBefore */
  SVGPoint insertItemBefore(SVGPoint item, int index);

  /** @domName SVGPointList.removeItem */
  SVGPoint removeItem(int index);

  /** @domName SVGPointList.replaceItem */
  SVGPoint replaceItem(SVGPoint item, int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPolygonElement
interface SVGPolygonElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGPolygonElement.animatedPoints */
  final SVGPointList animatedPoints;

  /** @domName SVGPolygonElement.points */
  final SVGPointList points;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPolylineElement
interface SVGPolylineElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGPolylineElement.animatedPoints */
  final SVGPointList animatedPoints;

  /** @domName SVGPolylineElement.points */
  final SVGPointList points;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGPreserveAspectRatio
interface SVGPreserveAspectRatio {

  static final int SVG_MEETORSLICE_MEET = 1;

  static final int SVG_MEETORSLICE_SLICE = 2;

  static final int SVG_MEETORSLICE_UNKNOWN = 0;

  static final int SVG_PRESERVEASPECTRATIO_NONE = 1;

  static final int SVG_PRESERVEASPECTRATIO_UNKNOWN = 0;

  static final int SVG_PRESERVEASPECTRATIO_XMAXYMAX = 10;

  static final int SVG_PRESERVEASPECTRATIO_XMAXYMID = 7;

  static final int SVG_PRESERVEASPECTRATIO_XMAXYMIN = 4;

  static final int SVG_PRESERVEASPECTRATIO_XMIDYMAX = 9;

  static final int SVG_PRESERVEASPECTRATIO_XMIDYMID = 6;

  static final int SVG_PRESERVEASPECTRATIO_XMIDYMIN = 3;

  static final int SVG_PRESERVEASPECTRATIO_XMINYMAX = 8;

  static final int SVG_PRESERVEASPECTRATIO_XMINYMID = 5;

  static final int SVG_PRESERVEASPECTRATIO_XMINYMIN = 2;

  /** @domName SVGPreserveAspectRatio.align */
  int align;

  /** @domName SVGPreserveAspectRatio.meetOrSlice */
  int meetOrSlice;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGRadialGradientElement
interface SVGRadialGradientElement extends SVGGradientElement {

  /** @domName SVGRadialGradientElement.cx */
  final SVGAnimatedLength cx;

  /** @domName SVGRadialGradientElement.cy */
  final SVGAnimatedLength cy;

  /** @domName SVGRadialGradientElement.fx */
  final SVGAnimatedLength fx;

  /** @domName SVGRadialGradientElement.fy */
  final SVGAnimatedLength fy;

  /** @domName SVGRadialGradientElement.r */
  final SVGAnimatedLength r;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGRect
interface SVGRect {

  /** @domName SVGRect.height */
  num height;

  /** @domName SVGRect.width */
  num width;

  /** @domName SVGRect.x */
  num x;

  /** @domName SVGRect.y */
  num y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGRectElement
interface SVGRectElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGRectElement.height */
  final SVGAnimatedLength height;

  /** @domName SVGRectElement.rx */
  final SVGAnimatedLength rx;

  /** @domName SVGRectElement.ry */
  final SVGAnimatedLength ry;

  /** @domName SVGRectElement.width */
  final SVGAnimatedLength width;

  /** @domName SVGRectElement.x */
  final SVGAnimatedLength x;

  /** @domName SVGRectElement.y */
  final SVGAnimatedLength y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGRenderingIntent
interface SVGRenderingIntent {

  static final int RENDERING_INTENT_ABSOLUTE_COLORIMETRIC = 5;

  static final int RENDERING_INTENT_AUTO = 1;

  static final int RENDERING_INTENT_PERCEPTUAL = 2;

  static final int RENDERING_INTENT_RELATIVE_COLORIMETRIC = 3;

  static final int RENDERING_INTENT_SATURATION = 4;

  static final int RENDERING_INTENT_UNKNOWN = 0;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/// @domName SVGSVGElement
interface SVGSVGElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGLocatable, SVGFitToViewBox, SVGZoomAndPan
    default _SVGSVGElementFactoryProvider {
  SVGSVGElement();


  /** @domName SVGSVGElement.contentScriptType */
  String contentScriptType;

  /** @domName SVGSVGElement.contentStyleType */
  String contentStyleType;

  /** @domName SVGSVGElement.currentScale */
  num currentScale;

  /** @domName SVGSVGElement.currentTranslate */
  final SVGPoint currentTranslate;

  /** @domName SVGSVGElement.height */
  final SVGAnimatedLength height;

  /** @domName SVGSVGElement.pixelUnitToMillimeterX */
  final num pixelUnitToMillimeterX;

  /** @domName SVGSVGElement.pixelUnitToMillimeterY */
  final num pixelUnitToMillimeterY;

  /** @domName SVGSVGElement.screenPixelToMillimeterX */
  final num screenPixelToMillimeterX;

  /** @domName SVGSVGElement.screenPixelToMillimeterY */
  final num screenPixelToMillimeterY;

  /** @domName SVGSVGElement.useCurrentView */
  bool useCurrentView;

  /** @domName SVGSVGElement.viewport */
  final SVGRect viewport;

  /** @domName SVGSVGElement.width */
  final SVGAnimatedLength width;

  /** @domName SVGSVGElement.x */
  final SVGAnimatedLength x;

  /** @domName SVGSVGElement.y */
  final SVGAnimatedLength y;

  /** @domName SVGSVGElement.animationsPaused */
  bool animationsPaused();

  /** @domName SVGSVGElement.checkEnclosure */
  bool checkEnclosure(SVGElement element, SVGRect rect);

  /** @domName SVGSVGElement.checkIntersection */
  bool checkIntersection(SVGElement element, SVGRect rect);

  /** @domName SVGSVGElement.createSVGAngle */
  SVGAngle createSVGAngle();

  /** @domName SVGSVGElement.createSVGLength */
  SVGLength createSVGLength();

  /** @domName SVGSVGElement.createSVGMatrix */
  SVGMatrix createSVGMatrix();

  /** @domName SVGSVGElement.createSVGNumber */
  SVGNumber createSVGNumber();

  /** @domName SVGSVGElement.createSVGPoint */
  SVGPoint createSVGPoint();

  /** @domName SVGSVGElement.createSVGRect */
  SVGRect createSVGRect();

  /** @domName SVGSVGElement.createSVGTransform */
  SVGTransform createSVGTransform();

  /** @domName SVGSVGElement.createSVGTransformFromMatrix */
  SVGTransform createSVGTransformFromMatrix(SVGMatrix matrix);

  /** @domName SVGSVGElement.deselectAll */
  void deselectAll();

  /** @domName SVGSVGElement.forceRedraw */
  void forceRedraw();

  /** @domName SVGSVGElement.getCurrentTime */
  num getCurrentTime();

  /** @domName SVGSVGElement.getElementById */
  Element getElementById(String elementId);

  /** @domName SVGSVGElement.getEnclosureList */
  NodeList getEnclosureList(SVGRect rect, SVGElement referenceElement);

  /** @domName SVGSVGElement.getIntersectionList */
  NodeList getIntersectionList(SVGRect rect, SVGElement referenceElement);

  /** @domName SVGSVGElement.pauseAnimations */
  void pauseAnimations();

  /** @domName SVGSVGElement.setCurrentTime */
  void setCurrentTime(num seconds);

  /** @domName SVGSVGElement.suspendRedraw */
  int suspendRedraw(int maxWaitMilliseconds);

  /** @domName SVGSVGElement.unpauseAnimations */
  void unpauseAnimations();

  /** @domName SVGSVGElement.unsuspendRedraw */
  void unsuspendRedraw(int suspendHandleId);

  /** @domName SVGSVGElement.unsuspendRedrawAll */
  void unsuspendRedrawAll();

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGScriptElement
interface SVGScriptElement extends SVGElement, SVGURIReference, SVGExternalResourcesRequired {

  /** @domName SVGScriptElement.type */
  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGSetElement
interface SVGSetElement extends SVGAnimationElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGStopElement
interface SVGStopElement extends SVGElement, SVGStylable {

  /** @domName SVGStopElement.offset */
  final SVGAnimatedNumber offset;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGStringList
interface SVGStringList {

  /** @domName SVGStringList.numberOfItems */
  final int numberOfItems;

  /** @domName SVGStringList.appendItem */
  String appendItem(String item);

  /** @domName SVGStringList.clear */
  void clear();

  /** @domName SVGStringList.getItem */
  String getItem(int index);

  /** @domName SVGStringList.initialize */
  String initialize(String item);

  /** @domName SVGStringList.insertItemBefore */
  String insertItemBefore(String item, int index);

  /** @domName SVGStringList.removeItem */
  String removeItem(int index);

  /** @domName SVGStringList.replaceItem */
  String replaceItem(String item, int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGStylable
interface SVGStylable {

  /** @domName SVGStylable.className */
  final SVGAnimatedString $dom_svgClassName;

  /** @domName SVGStylable.style */
  final CSSStyleDeclaration style;

  /** @domName SVGStylable.getPresentationAttribute */
  CSSValue getPresentationAttribute(String name);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGStyleElement
interface SVGStyleElement extends SVGElement, SVGLangSpace {

  /** @domName SVGStyleElement.disabled */
  bool disabled;

  /** @domName SVGStyleElement.media */
  String media;

  /** @domName SVGStyleElement.title */
  String title;

  /** @domName SVGStyleElement.type */
  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGSwitchElement
interface SVGSwitchElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGSymbolElement
interface SVGSymbolElement extends SVGElement, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGFitToViewBox {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTRefElement
interface SVGTRefElement extends SVGTextPositioningElement, SVGURIReference {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTSpanElement
interface SVGTSpanElement extends SVGTextPositioningElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTests
interface SVGTests {

  /** @domName SVGTests.requiredExtensions */
  final SVGStringList requiredExtensions;

  /** @domName SVGTests.requiredFeatures */
  final SVGStringList requiredFeatures;

  /** @domName SVGTests.systemLanguage */
  final SVGStringList systemLanguage;

  /** @domName SVGTests.hasExtension */
  bool hasExtension(String extension);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTextContentElement
interface SVGTextContentElement extends SVGElement, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable {

  static final int LENGTHADJUST_SPACING = 1;

  static final int LENGTHADJUST_SPACINGANDGLYPHS = 2;

  static final int LENGTHADJUST_UNKNOWN = 0;

  /** @domName SVGTextContentElement.lengthAdjust */
  final SVGAnimatedEnumeration lengthAdjust;

  /** @domName SVGTextContentElement.textLength */
  final SVGAnimatedLength textLength;

  /** @domName SVGTextContentElement.getCharNumAtPosition */
  int getCharNumAtPosition(SVGPoint point);

  /** @domName SVGTextContentElement.getComputedTextLength */
  num getComputedTextLength();

  /** @domName SVGTextContentElement.getEndPositionOfChar */
  SVGPoint getEndPositionOfChar(int offset);

  /** @domName SVGTextContentElement.getExtentOfChar */
  SVGRect getExtentOfChar(int offset);

  /** @domName SVGTextContentElement.getNumberOfChars */
  int getNumberOfChars();

  /** @domName SVGTextContentElement.getRotationOfChar */
  num getRotationOfChar(int offset);

  /** @domName SVGTextContentElement.getStartPositionOfChar */
  SVGPoint getStartPositionOfChar(int offset);

  /** @domName SVGTextContentElement.getSubStringLength */
  num getSubStringLength(int offset, int length);

  /** @domName SVGTextContentElement.selectSubString */
  void selectSubString(int offset, int length);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTextElement
interface SVGTextElement extends SVGTextPositioningElement, SVGTransformable {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTextPathElement
interface SVGTextPathElement extends SVGTextContentElement, SVGURIReference {

  static final int TEXTPATH_METHODTYPE_ALIGN = 1;

  static final int TEXTPATH_METHODTYPE_STRETCH = 2;

  static final int TEXTPATH_METHODTYPE_UNKNOWN = 0;

  static final int TEXTPATH_SPACINGTYPE_AUTO = 1;

  static final int TEXTPATH_SPACINGTYPE_EXACT = 2;

  static final int TEXTPATH_SPACINGTYPE_UNKNOWN = 0;

  /** @domName SVGTextPathElement.method */
  final SVGAnimatedEnumeration method;

  /** @domName SVGTextPathElement.spacing */
  final SVGAnimatedEnumeration spacing;

  /** @domName SVGTextPathElement.startOffset */
  final SVGAnimatedLength startOffset;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTextPositioningElement
interface SVGTextPositioningElement extends SVGTextContentElement {

  /** @domName SVGTextPositioningElement.dx */
  final SVGAnimatedLengthList dx;

  /** @domName SVGTextPositioningElement.dy */
  final SVGAnimatedLengthList dy;

  /** @domName SVGTextPositioningElement.rotate */
  final SVGAnimatedNumberList rotate;

  /** @domName SVGTextPositioningElement.x */
  final SVGAnimatedLengthList x;

  /** @domName SVGTextPositioningElement.y */
  final SVGAnimatedLengthList y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTitleElement
interface SVGTitleElement extends SVGElement, SVGLangSpace, SVGStylable {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTransform
interface SVGTransform {

  static final int SVG_TRANSFORM_MATRIX = 1;

  static final int SVG_TRANSFORM_ROTATE = 4;

  static final int SVG_TRANSFORM_SCALE = 3;

  static final int SVG_TRANSFORM_SKEWX = 5;

  static final int SVG_TRANSFORM_SKEWY = 6;

  static final int SVG_TRANSFORM_TRANSLATE = 2;

  static final int SVG_TRANSFORM_UNKNOWN = 0;

  /** @domName SVGTransform.angle */
  final num angle;

  /** @domName SVGTransform.matrix */
  final SVGMatrix matrix;

  /** @domName SVGTransform.type */
  final int type;

  /** @domName SVGTransform.setMatrix */
  void setMatrix(SVGMatrix matrix);

  /** @domName SVGTransform.setRotate */
  void setRotate(num angle, num cx, num cy);

  /** @domName SVGTransform.setScale */
  void setScale(num sx, num sy);

  /** @domName SVGTransform.setSkewX */
  void setSkewX(num angle);

  /** @domName SVGTransform.setSkewY */
  void setSkewY(num angle);

  /** @domName SVGTransform.setTranslate */
  void setTranslate(num tx, num ty);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTransformList
interface SVGTransformList {

  /** @domName SVGTransformList.numberOfItems */
  final int numberOfItems;

  /** @domName SVGTransformList.appendItem */
  SVGTransform appendItem(SVGTransform item);

  /** @domName SVGTransformList.clear */
  void clear();

  /** @domName SVGTransformList.consolidate */
  SVGTransform consolidate();

  /** @domName SVGTransformList.createSVGTransformFromMatrix */
  SVGTransform createSVGTransformFromMatrix(SVGMatrix matrix);

  /** @domName SVGTransformList.getItem */
  SVGTransform getItem(int index);

  /** @domName SVGTransformList.initialize */
  SVGTransform initialize(SVGTransform item);

  /** @domName SVGTransformList.insertItemBefore */
  SVGTransform insertItemBefore(SVGTransform item, int index);

  /** @domName SVGTransformList.removeItem */
  SVGTransform removeItem(int index);

  /** @domName SVGTransformList.replaceItem */
  SVGTransform replaceItem(SVGTransform item, int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGTransformable
interface SVGTransformable extends SVGLocatable {

  /** @domName SVGTransformable.transform */
  final SVGAnimatedTransformList transform;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGURIReference
interface SVGURIReference {

  /** @domName SVGURIReference.href */
  final SVGAnimatedString href;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGUnitTypes
interface SVGUnitTypes {

  static final int SVG_UNIT_TYPE_OBJECTBOUNDINGBOX = 2;

  static final int SVG_UNIT_TYPE_UNKNOWN = 0;

  static final int SVG_UNIT_TYPE_USERSPACEONUSE = 1;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGUseElement
interface SVGUseElement extends SVGElement, SVGURIReference, SVGTests, SVGLangSpace, SVGExternalResourcesRequired, SVGStylable, SVGTransformable {

  /** @domName SVGUseElement.animatedInstanceRoot */
  final SVGElementInstance animatedInstanceRoot;

  /** @domName SVGUseElement.height */
  final SVGAnimatedLength height;

  /** @domName SVGUseElement.instanceRoot */
  final SVGElementInstance instanceRoot;

  /** @domName SVGUseElement.width */
  final SVGAnimatedLength width;

  /** @domName SVGUseElement.x */
  final SVGAnimatedLength x;

  /** @domName SVGUseElement.y */
  final SVGAnimatedLength y;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGVKernElement
interface SVGVKernElement extends SVGElement {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGViewElement
interface SVGViewElement extends SVGElement, SVGExternalResourcesRequired, SVGFitToViewBox, SVGZoomAndPan {

  /** @domName SVGViewElement.viewTarget */
  final SVGStringList viewTarget;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGViewSpec
interface SVGViewSpec extends SVGZoomAndPan, SVGFitToViewBox {

  /** @domName SVGViewSpec.preserveAspectRatioString */
  final String preserveAspectRatioString;

  /** @domName SVGViewSpec.transform */
  final SVGTransformList transform;

  /** @domName SVGViewSpec.transformString */
  final String transformString;

  /** @domName SVGViewSpec.viewBoxString */
  final String viewBoxString;

  /** @domName SVGViewSpec.viewTarget */
  final SVGElement viewTarget;

  /** @domName SVGViewSpec.viewTargetString */
  final String viewTargetString;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGZoomAndPan
interface SVGZoomAndPan {

  static final int SVG_ZOOMANDPAN_DISABLE = 1;

  static final int SVG_ZOOMANDPAN_MAGNIFY = 2;

  static final int SVG_ZOOMANDPAN_UNKNOWN = 0;

  /** @domName SVGZoomAndPan.zoomAndPan */
  int zoomAndPan;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SVGZoomEvent
interface SVGZoomEvent extends UIEvent {

  /** @domName SVGZoomEvent.newScale */
  final num newScale;

  /** @domName SVGZoomEvent.newTranslate */
  final SVGPoint newTranslate;

  /** @domName SVGZoomEvent.previousScale */
  final num previousScale;

  /** @domName SVGZoomEvent.previousTranslate */
  final SVGPoint previousTranslate;

  /** @domName SVGZoomEvent.zoomRectScreen */
  final SVGRect zoomRectScreen;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Screen
interface Screen {

  /** @domName Screen.availHeight */
  final int availHeight;

  /** @domName Screen.availLeft */
  final int availLeft;

  /** @domName Screen.availTop */
  final int availTop;

  /** @domName Screen.availWidth */
  final int availWidth;

  /** @domName Screen.colorDepth */
  final int colorDepth;

  /** @domName Screen.height */
  final int height;

  /** @domName Screen.pixelDepth */
  final int pixelDepth;

  /** @domName Screen.width */
  final int width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLScriptElement
interface ScriptElement extends Element {

  /** @domName HTMLScriptElement.async */
  bool async;

  /** @domName HTMLScriptElement.charset */
  String charset;

  /** @domName HTMLScriptElement.crossOrigin */
  String crossOrigin;

  /** @domName HTMLScriptElement.defer */
  bool defer;

  /** @domName HTMLScriptElement.event */
  String event;

  /** @domName HTMLScriptElement.htmlFor */
  String htmlFor;

  /** @domName HTMLScriptElement.src */
  String src;

  /** @domName HTMLScriptElement.type */
  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ScriptProfile
interface ScriptProfile {

  /** @domName ScriptProfile.head */
  final ScriptProfileNode head;

  /** @domName ScriptProfile.title */
  final String title;

  /** @domName ScriptProfile.uid */
  final int uid;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ScriptProfileNode
interface ScriptProfileNode {

  /** @domName ScriptProfileNode.callUID */
  final int callUID;

  /** @domName ScriptProfileNode.children */
  final List<ScriptProfileNode> children;

  /** @domName ScriptProfileNode.functionName */
  final String functionName;

  /** @domName ScriptProfileNode.lineNumber */
  final int lineNumber;

  /** @domName ScriptProfileNode.numberOfCalls */
  final int numberOfCalls;

  /** @domName ScriptProfileNode.selfTime */
  final num selfTime;

  /** @domName ScriptProfileNode.totalTime */
  final num totalTime;

  /** @domName ScriptProfileNode.url */
  final String url;

  /** @domName ScriptProfileNode.visible */
  final bool visible;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLSelectElement
interface SelectElement extends Element {

  /** @domName HTMLSelectElement.autofocus */
  bool autofocus;

  /** @domName HTMLSelectElement.disabled */
  bool disabled;

  /** @domName HTMLSelectElement.form */
  final FormElement form;

  /** @domName HTMLSelectElement.labels */
  final NodeList labels;

  /** @domName HTMLSelectElement.length */
  int length;

  /** @domName HTMLSelectElement.multiple */
  bool multiple;

  /** @domName HTMLSelectElement.name */
  String name;

  /** @domName HTMLSelectElement.options */
  final HTMLOptionsCollection options;

  /** @domName HTMLSelectElement.required */
  bool required;

  /** @domName HTMLSelectElement.selectedIndex */
  int selectedIndex;

  /** @domName HTMLSelectElement.selectedOptions */
  final HTMLCollection selectedOptions;

  /** @domName HTMLSelectElement.size */
  int size;

  /** @domName HTMLSelectElement.type */
  final String type;

  /** @domName HTMLSelectElement.validationMessage */
  final String validationMessage;

  /** @domName HTMLSelectElement.validity */
  final ValidityState validity;

  /** @domName HTMLSelectElement.value */
  String value;

  /** @domName HTMLSelectElement.willValidate */
  final bool willValidate;

  /** @domName HTMLSelectElement.add */
  void add(Element element, Element before);

  /** @domName HTMLSelectElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLSelectElement.item */
  Node item(int index);

  /** @domName HTMLSelectElement.namedItem */
  Node namedItem(String name);

  /** @domName HTMLSelectElement.setCustomValidity */
  void setCustomValidity(String error);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SessionDescription
interface SessionDescription default _SessionDescriptionFactoryProvider {

  SessionDescription(String sdp);

  /** @domName SessionDescription.addCandidate */
  void addCandidate(IceCandidate candidate);

  /** @domName SessionDescription.toSdp */
  String toSdp();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLShadowElement
interface ShadowElement extends Element {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ShadowRoot
interface ShadowRoot extends DocumentFragment default _ShadowRootFactoryProvider {

  ShadowRoot(Element host);

  /** @domName ShadowRoot.activeElement */
  final Element activeElement;

  /** @domName ShadowRoot.host */
  final Element host;

  /** @domName ShadowRoot.innerHTML */
  String innerHTML;

  /** @domName ShadowRoot.selection */
  final DOMSelection selection;

  /** @domName ShadowRoot.getElementById */
  Element getElementById(String elementId);

  /** @domName ShadowRoot.getElementsByClassName */
  NodeList getElementsByClassName(String className);

  /** @domName ShadowRoot.getElementsByTagName */
  NodeList getElementsByTagName(String tagName);

  /** @domName ShadowRoot.getElementsByTagNameNS */
  NodeList getElementsByTagNameNS(String namespaceURI, String localName);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SharedWorker
interface SharedWorker extends AbstractWorker default _SharedWorkerFactoryProvider {

  SharedWorker(String scriptURL, [String name]);

  /** @domName SharedWorker.port */
  final MessagePort port;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SharedWorkerContext
interface SharedWorkerContext extends WorkerContext {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  SharedWorkerContextEvents get on();

  /** @domName SharedWorkerContext.name */
  final String name;
}

interface SharedWorkerContextEvents extends WorkerContextEvents {

  EventListenerList get connect();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool SignalingCallback(String message, DeprecatedPeerConnection source);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLSourceElement
interface SourceElement extends Element {

  /** @domName HTMLSourceElement.media */
  String media;

  /** @domName HTMLSourceElement.src */
  String src;

  /** @domName HTMLSourceElement.type */
  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLSpanElement
interface SpanElement extends Element {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechGrammar
interface SpeechGrammar default _SpeechGrammarFactoryProvider {

  SpeechGrammar();

  /** @domName SpeechGrammar.src */
  String src;

  /** @domName SpeechGrammar.weight */
  num weight;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechGrammarList
interface SpeechGrammarList default _SpeechGrammarListFactoryProvider {

  SpeechGrammarList();

  /** @domName SpeechGrammarList.length */
  final int length;

  /** @domName SpeechGrammarList.addFromString */
  void addFromString(String string, [num weight]);

  /** @domName SpeechGrammarList.addFromUri */
  void addFromUri(String src, [num weight]);

  /** @domName SpeechGrammarList.item */
  SpeechGrammar item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechInputEvent
interface SpeechInputEvent extends Event {

  /** @domName SpeechInputEvent.results */
  final SpeechInputResultList results;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechInputResult
interface SpeechInputResult {

  /** @domName SpeechInputResult.confidence */
  final num confidence;

  /** @domName SpeechInputResult.utterance */
  final String utterance;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechInputResultList
interface SpeechInputResultList {

  /** @domName SpeechInputResultList.length */
  final int length;

  /** @domName SpeechInputResultList.item */
  SpeechInputResult item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechRecognition
interface SpeechRecognition extends EventTarget default _SpeechRecognitionFactoryProvider {

  SpeechRecognition();

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  SpeechRecognitionEvents get on();

  /** @domName SpeechRecognition.continuous */
  bool continuous;

  /** @domName SpeechRecognition.grammars */
  SpeechGrammarList grammars;

  /** @domName SpeechRecognition.lang */
  String lang;

  /** @domName SpeechRecognition.abort */
  void abort();

  /** @domName SpeechRecognition.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName SpeechRecognition.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName SpeechRecognition.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName SpeechRecognition.start */
  void start();

  /** @domName SpeechRecognition.stop */
  void stop();
}

interface SpeechRecognitionEvents extends Events {

  EventListenerList get audioEnd();

  EventListenerList get audioStart();

  EventListenerList get end();

  EventListenerList get error();

  EventListenerList get noMatch();

  EventListenerList get result();

  EventListenerList get resultDeleted();

  EventListenerList get soundEnd();

  EventListenerList get soundStart();

  EventListenerList get speechEnd();

  EventListenerList get speechStart();

  EventListenerList get start();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechRecognitionAlternative
interface SpeechRecognitionAlternative {

  /** @domName SpeechRecognitionAlternative.confidence */
  final num confidence;

  /** @domName SpeechRecognitionAlternative.transcript */
  final String transcript;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechRecognitionError
interface SpeechRecognitionError {

  static final int ABORTED = 2;

  static final int AUDIO_CAPTURE = 3;

  static final int BAD_GRAMMAR = 7;

  static final int LANGUAGE_NOT_SUPPORTED = 8;

  static final int NETWORK = 4;

  static final int NOT_ALLOWED = 5;

  static final int NO_SPEECH = 1;

  static final int OTHER = 0;

  static final int SERVICE_NOT_ALLOWED = 6;

  /** @domName SpeechRecognitionError.code */
  final int code;

  /** @domName SpeechRecognitionError.message */
  final String message;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechRecognitionEvent
interface SpeechRecognitionEvent extends Event {

  /** @domName SpeechRecognitionEvent.error */
  final SpeechRecognitionError error;

  /** @domName SpeechRecognitionEvent.result */
  final SpeechRecognitionResult result;

  /** @domName SpeechRecognitionEvent.resultHistory */
  final SpeechRecognitionResultList resultHistory;

  /** @domName SpeechRecognitionEvent.resultIndex */
  final int resultIndex;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechRecognitionResult
interface SpeechRecognitionResult {

  /** @domName SpeechRecognitionResult.finalValue */
  final bool finalValue;

  /** @domName SpeechRecognitionResult.length */
  final int length;

  /** @domName SpeechRecognitionResult.item */
  SpeechRecognitionAlternative item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName SpeechRecognitionResultList
interface SpeechRecognitionResultList {

  /** @domName SpeechRecognitionResultList.length */
  final int length;

  /** @domName SpeechRecognitionResultList.item */
  SpeechRecognitionResult item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/// @domName Storage
interface Storage extends Map<String, String> {

  /** @domName Storage.length */
  final int $dom_length;

  /** @domName Storage.clear */
  void $dom_clear();

  /** @domName Storage.getItem */
  String $dom_getItem(String key);

  /** @domName Storage.key */
  String $dom_key(int index);

  /** @domName Storage.removeItem */
  void $dom_removeItem(String key);

  /** @domName Storage.setItem */
  void $dom_setItem(String key, String data);

}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName StorageEvent
interface StorageEvent extends Event {

  /** @domName StorageEvent.key */
  final String key;

  /** @domName StorageEvent.newValue */
  final String newValue;

  /** @domName StorageEvent.oldValue */
  final String oldValue;

  /** @domName StorageEvent.storageArea */
  final Storage storageArea;

  /** @domName StorageEvent.url */
  final String url;

  /** @domName StorageEvent.initStorageEvent */
  void initStorageEvent(String typeArg, bool canBubbleArg, bool cancelableArg, String keyArg, String oldValueArg, String newValueArg, String urlArg, Storage storageAreaArg);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName StorageInfo
interface StorageInfo {

  static final int PERSISTENT = 1;

  static final int TEMPORARY = 0;

  /** @domName StorageInfo.queryUsageAndQuota */
  void queryUsageAndQuota(int storageType, [StorageInfoUsageCallback usageCallback, StorageInfoErrorCallback errorCallback]);

  /** @domName StorageInfo.requestQuota */
  void requestQuota(int storageType, int newQuotaInBytes, [StorageInfoQuotaCallback quotaCallback, StorageInfoErrorCallback errorCallback]);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool StorageInfoErrorCallback(DOMException error);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool StorageInfoQuotaCallback(int grantedQuotaInBytes);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool StorageInfoUsageCallback(int currentUsageInBytes, int currentQuotaInBytes);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef bool StringCallback(String data);
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLStyleElement
interface StyleElement extends Element {

  /** @domName HTMLStyleElement.disabled */
  bool disabled;

  /** @domName HTMLStyleElement.media */
  String media;

  /** @domName HTMLStyleElement.scoped */
  bool scoped;

  /** @domName HTMLStyleElement.sheet */
  final StyleSheet sheet;

  /** @domName HTMLStyleElement.type */
  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName StyleMedia
interface StyleMedia {

  /** @domName StyleMedia.type */
  final String type;

  /** @domName StyleMedia.matchMedium */
  bool matchMedium(String mediaquery);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName StyleSheet
interface StyleSheet {

  /** @domName StyleSheet.disabled */
  bool disabled;

  /** @domName StyleSheet.href */
  final String href;

  /** @domName StyleSheet.media */
  final MediaList media;

  /** @domName StyleSheet.ownerNode */
  final Node ownerNode;

  /** @domName StyleSheet.parentStyleSheet */
  final StyleSheet parentStyleSheet;

  /** @domName StyleSheet.title */
  final String title;

  /** @domName StyleSheet.type */
  final String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName StyleSheetList
interface StyleSheetList extends List<StyleSheet> {

  /** @domName StyleSheetList.length */
  final int length;

  /** @domName StyleSheetList.item */
  StyleSheet item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTableCaptionElement
interface TableCaptionElement extends Element {

  /** @domName HTMLTableCaptionElement.align */
  String align;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTableCellElement
interface TableCellElement extends Element {

  /** @domName HTMLTableCellElement.abbr */
  String abbr;

  /** @domName HTMLTableCellElement.align */
  String align;

  /** @domName HTMLTableCellElement.axis */
  String axis;

  /** @domName HTMLTableCellElement.bgColor */
  String bgColor;

  /** @domName HTMLTableCellElement.cellIndex */
  final int cellIndex;

  /** @domName HTMLTableCellElement.ch */
  String ch;

  /** @domName HTMLTableCellElement.chOff */
  String chOff;

  /** @domName HTMLTableCellElement.colSpan */
  int colSpan;

  /** @domName HTMLTableCellElement.headers */
  String headers;

  /** @domName HTMLTableCellElement.height */
  String height;

  /** @domName HTMLTableCellElement.noWrap */
  bool noWrap;

  /** @domName HTMLTableCellElement.rowSpan */
  int rowSpan;

  /** @domName HTMLTableCellElement.scope */
  String scope;

  /** @domName HTMLTableCellElement.vAlign */
  String vAlign;

  /** @domName HTMLTableCellElement.width */
  String width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTableColElement
interface TableColElement extends Element {

  /** @domName HTMLTableColElement.align */
  String align;

  /** @domName HTMLTableColElement.ch */
  String ch;

  /** @domName HTMLTableColElement.chOff */
  String chOff;

  /** @domName HTMLTableColElement.span */
  int span;

  /** @domName HTMLTableColElement.vAlign */
  String vAlign;

  /** @domName HTMLTableColElement.width */
  String width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTableElement
interface TableElement extends Element {

  /** @domName HTMLTableElement.align */
  String align;

  /** @domName HTMLTableElement.bgColor */
  String bgColor;

  /** @domName HTMLTableElement.border */
  String border;

  /** @domName HTMLTableElement.caption */
  TableCaptionElement caption;

  /** @domName HTMLTableElement.cellPadding */
  String cellPadding;

  /** @domName HTMLTableElement.cellSpacing */
  String cellSpacing;

  /** @domName HTMLTableElement.frame */
  String frame;

  /** @domName HTMLTableElement.rows */
  final HTMLCollection rows;

  /** @domName HTMLTableElement.rules */
  String rules;

  /** @domName HTMLTableElement.summary */
  String summary;

  /** @domName HTMLTableElement.tBodies */
  final HTMLCollection tBodies;

  /** @domName HTMLTableElement.tFoot */
  TableSectionElement tFoot;

  /** @domName HTMLTableElement.tHead */
  TableSectionElement tHead;

  /** @domName HTMLTableElement.width */
  String width;

  /** @domName HTMLTableElement.createCaption */
  Element createCaption();

  /** @domName HTMLTableElement.createTBody */
  Element createTBody();

  /** @domName HTMLTableElement.createTFoot */
  Element createTFoot();

  /** @domName HTMLTableElement.createTHead */
  Element createTHead();

  /** @domName HTMLTableElement.deleteCaption */
  void deleteCaption();

  /** @domName HTMLTableElement.deleteRow */
  void deleteRow(int index);

  /** @domName HTMLTableElement.deleteTFoot */
  void deleteTFoot();

  /** @domName HTMLTableElement.deleteTHead */
  void deleteTHead();

  /** @domName HTMLTableElement.insertRow */
  Element insertRow(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTableRowElement
interface TableRowElement extends Element {

  /** @domName HTMLTableRowElement.align */
  String align;

  /** @domName HTMLTableRowElement.bgColor */
  String bgColor;

  /** @domName HTMLTableRowElement.cells */
  final HTMLCollection cells;

  /** @domName HTMLTableRowElement.ch */
  String ch;

  /** @domName HTMLTableRowElement.chOff */
  String chOff;

  /** @domName HTMLTableRowElement.rowIndex */
  final int rowIndex;

  /** @domName HTMLTableRowElement.sectionRowIndex */
  final int sectionRowIndex;

  /** @domName HTMLTableRowElement.vAlign */
  String vAlign;

  /** @domName HTMLTableRowElement.deleteCell */
  void deleteCell(int index);

  /** @domName HTMLTableRowElement.insertCell */
  Element insertCell(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTableSectionElement
interface TableSectionElement extends Element {

  /** @domName HTMLTableSectionElement.align */
  String align;

  /** @domName HTMLTableSectionElement.ch */
  String ch;

  /** @domName HTMLTableSectionElement.chOff */
  String chOff;

  /** @domName HTMLTableSectionElement.rows */
  final HTMLCollection rows;

  /** @domName HTMLTableSectionElement.vAlign */
  String vAlign;

  /** @domName HTMLTableSectionElement.deleteRow */
  void deleteRow(int index);

  /** @domName HTMLTableSectionElement.insertRow */
  Element insertRow(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Text
interface Text extends CharacterData default _TextFactoryProvider {

  Text(String data);

  /** @domName Text.wholeText */
  final String wholeText;

  /** @domName Text.replaceWholeText */
  Text replaceWholeText(String content);

  /** @domName Text.splitText */
  Text splitText(int offset);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTextAreaElement
interface TextAreaElement extends Element {

  /** @domName HTMLTextAreaElement.autofocus */
  bool autofocus;

  /** @domName HTMLTextAreaElement.cols */
  int cols;

  /** @domName HTMLTextAreaElement.defaultValue */
  String defaultValue;

  /** @domName HTMLTextAreaElement.disabled */
  bool disabled;

  /** @domName HTMLTextAreaElement.form */
  final FormElement form;

  /** @domName HTMLTextAreaElement.labels */
  final NodeList labels;

  /** @domName HTMLTextAreaElement.maxLength */
  int maxLength;

  /** @domName HTMLTextAreaElement.name */
  String name;

  /** @domName HTMLTextAreaElement.placeholder */
  String placeholder;

  /** @domName HTMLTextAreaElement.readOnly */
  bool readOnly;

  /** @domName HTMLTextAreaElement.required */
  bool required;

  /** @domName HTMLTextAreaElement.rows */
  int rows;

  /** @domName HTMLTextAreaElement.selectionDirection */
  String selectionDirection;

  /** @domName HTMLTextAreaElement.selectionEnd */
  int selectionEnd;

  /** @domName HTMLTextAreaElement.selectionStart */
  int selectionStart;

  /** @domName HTMLTextAreaElement.textLength */
  final int textLength;

  /** @domName HTMLTextAreaElement.type */
  final String type;

  /** @domName HTMLTextAreaElement.validationMessage */
  final String validationMessage;

  /** @domName HTMLTextAreaElement.validity */
  final ValidityState validity;

  /** @domName HTMLTextAreaElement.value */
  String value;

  /** @domName HTMLTextAreaElement.willValidate */
  final bool willValidate;

  /** @domName HTMLTextAreaElement.wrap */
  String wrap;

  /** @domName HTMLTextAreaElement.checkValidity */
  bool checkValidity();

  /** @domName HTMLTextAreaElement.select */
  void select();

  /** @domName HTMLTextAreaElement.setCustomValidity */
  void setCustomValidity(String error);

  /** @domName HTMLTextAreaElement.setSelectionRange */
  void setSelectionRange(int start, int end, [String direction]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TextEvent
interface TextEvent extends UIEvent {

  /** @domName TextEvent.data */
  final String data;

  /** @domName TextEvent.initTextEvent */
  void initTextEvent(String typeArg, bool canBubbleArg, bool cancelableArg, Window viewArg, String dataArg);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TextMetrics
interface TextMetrics {

  /** @domName TextMetrics.width */
  final num width;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TextTrack
interface TextTrack extends EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  TextTrackEvents get on();

  static final int DISABLED = 0;

  static final int HIDDEN = 1;

  static final int SHOWING = 2;

  /** @domName TextTrack.activeCues */
  final TextTrackCueList activeCues;

  /** @domName TextTrack.cues */
  final TextTrackCueList cues;

  /** @domName TextTrack.kind */
  final String kind;

  /** @domName TextTrack.label */
  final String label;

  /** @domName TextTrack.language */
  final String language;

  /** @domName TextTrack.mode */
  int mode;

  /** @domName TextTrack.addCue */
  void addCue(TextTrackCue cue);

  /** @domName TextTrack.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName TextTrack.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName TextTrack.removeCue */
  void removeCue(TextTrackCue cue);

  /** @domName TextTrack.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

interface TextTrackEvents extends Events {

  EventListenerList get cueChange();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TextTrackCue
interface TextTrackCue extends EventTarget default _TextTrackCueFactoryProvider {

  TextTrackCue(String id, num startTime, num endTime, String text, [String settings, bool pauseOnExit]);

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  TextTrackCueEvents get on();

  /** @domName TextTrackCue.align */
  String align;

  /** @domName TextTrackCue.endTime */
  num endTime;

  /** @domName TextTrackCue.id */
  String id;

  /** @domName TextTrackCue.line */
  int line;

  /** @domName TextTrackCue.pauseOnExit */
  bool pauseOnExit;

  /** @domName TextTrackCue.position */
  int position;

  /** @domName TextTrackCue.size */
  int size;

  /** @domName TextTrackCue.snapToLines */
  bool snapToLines;

  /** @domName TextTrackCue.startTime */
  num startTime;

  /** @domName TextTrackCue.text */
  String text;

  /** @domName TextTrackCue.track */
  final TextTrack track;

  /** @domName TextTrackCue.vertical */
  String vertical;

  /** @domName TextTrackCue.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName TextTrackCue.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName TextTrackCue.getCueAsHTML */
  DocumentFragment getCueAsHTML();

  /** @domName TextTrackCue.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

interface TextTrackCueEvents extends Events {

  EventListenerList get enter();

  EventListenerList get exit();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TextTrackCueList
interface TextTrackCueList {

  /** @domName TextTrackCueList.length */
  final int length;

  /** @domName TextTrackCueList.getCueById */
  TextTrackCue getCueById(String id);

  /** @domName TextTrackCueList.item */
  TextTrackCue item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TextTrackList
interface TextTrackList extends EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  TextTrackListEvents get on();

  /** @domName TextTrackList.length */
  final int length;

  /** @domName TextTrackList.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName TextTrackList.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName TextTrackList.item */
  TextTrack item(int index);

  /** @domName TextTrackList.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

interface TextTrackListEvents extends Events {

  EventListenerList get addTrack();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TimeRanges
interface TimeRanges {

  /** @domName TimeRanges.length */
  final int length;

  /** @domName TimeRanges.end */
  num end(int index);

  /** @domName TimeRanges.start */
  num start(int index);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef void TimeoutHandler();
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTitleElement
interface TitleElement extends Element {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Touch
interface Touch {

  /** @domName Touch.clientX */
  final int clientX;

  /** @domName Touch.clientY */
  final int clientY;

  /** @domName Touch.identifier */
  final int identifier;

  /** @domName Touch.pageX */
  final int pageX;

  /** @domName Touch.pageY */
  final int pageY;

  /** @domName Touch.screenX */
  final int screenX;

  /** @domName Touch.screenY */
  final int screenY;

  /** @domName Touch.target */
  final EventTarget target;

  /** @domName Touch.webkitForce */
  final num webkitForce;

  /** @domName Touch.webkitRadiusX */
  final int webkitRadiusX;

  /** @domName Touch.webkitRadiusY */
  final int webkitRadiusY;

  /** @domName Touch.webkitRotationAngle */
  final num webkitRotationAngle;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TouchEvent
interface TouchEvent extends UIEvent {

  /** @domName TouchEvent.altKey */
  final bool altKey;

  /** @domName TouchEvent.changedTouches */
  final TouchList changedTouches;

  /** @domName TouchEvent.ctrlKey */
  final bool ctrlKey;

  /** @domName TouchEvent.metaKey */
  final bool metaKey;

  /** @domName TouchEvent.shiftKey */
  final bool shiftKey;

  /** @domName TouchEvent.targetTouches */
  final TouchList targetTouches;

  /** @domName TouchEvent.touches */
  final TouchList touches;

  /** @domName TouchEvent.initTouchEvent */
  void initTouchEvent(TouchList touches, TouchList targetTouches, TouchList changedTouches, String type, Window view, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TouchList
interface TouchList extends List<Touch> {

  /** @domName TouchList.length */
  final int length;

  /** @domName TouchList.item */
  Touch item(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLTrackElement
interface TrackElement extends Element {

  static final int ERROR = 3;

  static final int LOADED = 2;

  static final int LOADING = 1;

  static final int NONE = 0;

  /** @domName HTMLTrackElement.defaultValue */
  bool defaultValue;

  /** @domName HTMLTrackElement.kind */
  String kind;

  /** @domName HTMLTrackElement.label */
  String label;

  /** @domName HTMLTrackElement.readyState */
  final int readyState;

  /** @domName HTMLTrackElement.src */
  String src;

  /** @domName HTMLTrackElement.srclang */
  String srclang;

  /** @domName HTMLTrackElement.track */
  final TextTrack track;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TrackEvent
interface TrackEvent extends Event {

  /** @domName TrackEvent.track */
  final Object track;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitTransitionEvent
interface TransitionEvent extends Event {

  /** @domName WebKitTransitionEvent.elapsedTime */
  final num elapsedTime;

  /** @domName WebKitTransitionEvent.propertyName */
  final String propertyName;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName TreeWalker
interface TreeWalker {

  /** @domName TreeWalker.currentNode */
  Node currentNode;

  /** @domName TreeWalker.expandEntityReferences */
  final bool expandEntityReferences;

  /** @domName TreeWalker.filter */
  final NodeFilter filter;

  /** @domName TreeWalker.root */
  final Node root;

  /** @domName TreeWalker.whatToShow */
  final int whatToShow;

  /** @domName TreeWalker.firstChild */
  Node firstChild();

  /** @domName TreeWalker.lastChild */
  Node lastChild();

  /** @domName TreeWalker.nextNode */
  Node nextNode();

  /** @domName TreeWalker.nextSibling */
  Node nextSibling();

  /** @domName TreeWalker.parentNode */
  Node parentNode();

  /** @domName TreeWalker.previousNode */
  Node previousNode();

  /** @domName TreeWalker.previousSibling */
  Node previousSibling();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName UIEvent
interface UIEvent extends Event {

  /** @domName UIEvent.charCode */
  final int charCode;

  /** @domName UIEvent.detail */
  final int detail;

  /** @domName UIEvent.keyCode */
  final int keyCode;

  /** @domName UIEvent.layerX */
  final int layerX;

  /** @domName UIEvent.layerY */
  final int layerY;

  /** @domName UIEvent.pageX */
  final int pageX;

  /** @domName UIEvent.pageY */
  final int pageY;

  /** @domName UIEvent.view */
  final Window view;

  /** @domName UIEvent.which */
  final int which;

  /** @domName UIEvent.initUIEvent */
  void initUIEvent(String type, bool canBubble, bool cancelable, Window view, int detail);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLUListElement
interface UListElement extends Element {

  /** @domName HTMLUListElement.compact */
  bool compact;

  /** @domName HTMLUListElement.type */
  String type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Uint16Array
interface Uint16Array extends ArrayBufferView, List<int> default _TypedArrayFactoryProvider {

  Uint16Array(int length);

  Uint16Array.fromList(List<int> list);

  Uint16Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]);

  static final int BYTES_PER_ELEMENT = 2;

  /** @domName Uint16Array.length */
  final int length;

  /** @domName Uint16Array.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Uint16Array.subarray */
  Uint16Array subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Uint32Array
interface Uint32Array extends ArrayBufferView, List<int> default _TypedArrayFactoryProvider {

  Uint32Array(int length);

  Uint32Array.fromList(List<int> list);

  Uint32Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]);

  static final int BYTES_PER_ELEMENT = 4;

  /** @domName Uint32Array.length */
  final int length;

  /** @domName Uint32Array.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Uint32Array.subarray */
  Uint32Array subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Uint8Array
interface Uint8Array extends ArrayBufferView, List<int> default _TypedArrayFactoryProvider {

  Uint8Array(int length);

  Uint8Array.fromList(List<int> list);

  Uint8Array.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]);

  static final int BYTES_PER_ELEMENT = 1;

  /** @domName Uint8Array.length */
  final int length;

  /** @domName Uint8Array.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Uint8Array.subarray */
  Uint8Array subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Uint8ClampedArray
interface Uint8ClampedArray extends Uint8Array, List<int>, ArrayBufferView default _TypedArrayFactoryProvider {

  Uint8ClampedArray(int length);

  Uint8ClampedArray.fromList(List<int> list);

  Uint8ClampedArray.fromBuffer(ArrayBuffer buffer, [int byteOffset, int length]);

  /** @domName Uint8ClampedArray.length */
  final int length;

  /** @domName Uint8ClampedArray.setElements */
  void setElements(Object array, [int offset]);

  /** @domName Uint8ClampedArray.subarray */
  Uint8ClampedArray subarray(int start, [int end]);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLUnknownElement
interface UnknownElement extends Element {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName ValidityState
interface ValidityState {

  /** @domName ValidityState.customError */
  final bool customError;

  /** @domName ValidityState.patternMismatch */
  final bool patternMismatch;

  /** @domName ValidityState.rangeOverflow */
  final bool rangeOverflow;

  /** @domName ValidityState.rangeUnderflow */
  final bool rangeUnderflow;

  /** @domName ValidityState.stepMismatch */
  final bool stepMismatch;

  /** @domName ValidityState.tooLong */
  final bool tooLong;

  /** @domName ValidityState.typeMismatch */
  final bool typeMismatch;

  /** @domName ValidityState.valid */
  final bool valid;

  /** @domName ValidityState.valueMissing */
  final bool valueMissing;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName HTMLVideoElement
interface VideoElement extends MediaElement {

  /** @domName HTMLVideoElement.height */
  int height;

  /** @domName HTMLVideoElement.poster */
  String poster;

  /** @domName HTMLVideoElement.videoHeight */
  final int videoHeight;

  /** @domName HTMLVideoElement.videoWidth */
  final int videoWidth;

  /** @domName HTMLVideoElement.webkitDecodedFrameCount */
  final int webkitDecodedFrameCount;

  /** @domName HTMLVideoElement.webkitDisplayingFullscreen */
  final bool webkitDisplayingFullscreen;

  /** @domName HTMLVideoElement.webkitDroppedFrameCount */
  final int webkitDroppedFrameCount;

  /** @domName HTMLVideoElement.webkitSupportsFullscreen */
  final bool webkitSupportsFullscreen;

  /** @domName HTMLVideoElement.width */
  int width;

  /** @domName HTMLVideoElement.webkitEnterFullScreen */
  void webkitEnterFullScreen();

  /** @domName HTMLVideoElement.webkitEnterFullscreen */
  void webkitEnterFullscreen();

  /** @domName HTMLVideoElement.webkitExitFullScreen */
  void webkitExitFullScreen();

  /** @domName HTMLVideoElement.webkitExitFullscreen */
  void webkitExitFullscreen();
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

typedef void VoidCallback();
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WaveShaperNode
interface WaveShaperNode extends AudioNode {

  /** @domName WaveShaperNode.curve */
  Float32Array curve;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WaveTable
interface WaveTable {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLActiveInfo
interface WebGLActiveInfo {

  /** @domName WebGLActiveInfo.name */
  final String name;

  /** @domName WebGLActiveInfo.size */
  final int size;

  /** @domName WebGLActiveInfo.type */
  final int type;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLBuffer
interface WebGLBuffer {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLCompressedTextureS3TC
interface WebGLCompressedTextureS3TC {

  static final int COMPRESSED_RGBA_S3TC_DXT1_EXT = 0x83F1;

  static final int COMPRESSED_RGBA_S3TC_DXT3_EXT = 0x83F2;

  static final int COMPRESSED_RGBA_S3TC_DXT5_EXT = 0x83F3;

  static final int COMPRESSED_RGB_S3TC_DXT1_EXT = 0x83F0;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLContextAttributes
interface WebGLContextAttributes {

  /** @domName WebGLContextAttributes.alpha */
  bool alpha;

  /** @domName WebGLContextAttributes.antialias */
  bool antialias;

  /** @domName WebGLContextAttributes.depth */
  bool depth;

  /** @domName WebGLContextAttributes.premultipliedAlpha */
  bool premultipliedAlpha;

  /** @domName WebGLContextAttributes.preserveDrawingBuffer */
  bool preserveDrawingBuffer;

  /** @domName WebGLContextAttributes.stencil */
  bool stencil;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLContextEvent
interface WebGLContextEvent extends Event {

  /** @domName WebGLContextEvent.statusMessage */
  final String statusMessage;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLDebugRendererInfo
interface WebGLDebugRendererInfo {

  static final int UNMASKED_RENDERER_WEBGL = 0x9246;

  static final int UNMASKED_VENDOR_WEBGL = 0x9245;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLDebugShaders
interface WebGLDebugShaders {

  /** @domName WebGLDebugShaders.getTranslatedShaderSource */
  String getTranslatedShaderSource(WebGLShader shader);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLFramebuffer
interface WebGLFramebuffer {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLLoseContext
interface WebGLLoseContext {

  /** @domName WebGLLoseContext.loseContext */
  void loseContext();

  /** @domName WebGLLoseContext.restoreContext */
  void restoreContext();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLProgram
interface WebGLProgram {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLRenderbuffer
interface WebGLRenderbuffer {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLRenderingContext
interface WebGLRenderingContext extends CanvasRenderingContext {

  static final int ACTIVE_ATTRIBUTES = 0x8B89;

  static final int ACTIVE_TEXTURE = 0x84E0;

  static final int ACTIVE_UNIFORMS = 0x8B86;

  static final int ALIASED_LINE_WIDTH_RANGE = 0x846E;

  static final int ALIASED_POINT_SIZE_RANGE = 0x846D;

  static final int ALPHA = 0x1906;

  static final int ALPHA_BITS = 0x0D55;

  static final int ALWAYS = 0x0207;

  static final int ARRAY_BUFFER = 0x8892;

  static final int ARRAY_BUFFER_BINDING = 0x8894;

  static final int ATTACHED_SHADERS = 0x8B85;

  static final int BACK = 0x0405;

  static final int BLEND = 0x0BE2;

  static final int BLEND_COLOR = 0x8005;

  static final int BLEND_DST_ALPHA = 0x80CA;

  static final int BLEND_DST_RGB = 0x80C8;

  static final int BLEND_EQUATION = 0x8009;

  static final int BLEND_EQUATION_ALPHA = 0x883D;

  static final int BLEND_EQUATION_RGB = 0x8009;

  static final int BLEND_SRC_ALPHA = 0x80CB;

  static final int BLEND_SRC_RGB = 0x80C9;

  static final int BLUE_BITS = 0x0D54;

  static final int BOOL = 0x8B56;

  static final int BOOL_VEC2 = 0x8B57;

  static final int BOOL_VEC3 = 0x8B58;

  static final int BOOL_VEC4 = 0x8B59;

  static final int BROWSER_DEFAULT_WEBGL = 0x9244;

  static final int BUFFER_SIZE = 0x8764;

  static final int BUFFER_USAGE = 0x8765;

  static final int BYTE = 0x1400;

  static final int CCW = 0x0901;

  static final int CLAMP_TO_EDGE = 0x812F;

  static final int COLOR_ATTACHMENT0 = 0x8CE0;

  static final int COLOR_BUFFER_BIT = 0x00004000;

  static final int COLOR_CLEAR_VALUE = 0x0C22;

  static final int COLOR_WRITEMASK = 0x0C23;

  static final int COMPILE_STATUS = 0x8B81;

  static final int COMPRESSED_TEXTURE_FORMATS = 0x86A3;

  static final int CONSTANT_ALPHA = 0x8003;

  static final int CONSTANT_COLOR = 0x8001;

  static final int CONTEXT_LOST_WEBGL = 0x9242;

  static final int CULL_FACE = 0x0B44;

  static final int CULL_FACE_MODE = 0x0B45;

  static final int CURRENT_PROGRAM = 0x8B8D;

  static final int CURRENT_VERTEX_ATTRIB = 0x8626;

  static final int CW = 0x0900;

  static final int DECR = 0x1E03;

  static final int DECR_WRAP = 0x8508;

  static final int DELETE_STATUS = 0x8B80;

  static final int DEPTH_ATTACHMENT = 0x8D00;

  static final int DEPTH_BITS = 0x0D56;

  static final int DEPTH_BUFFER_BIT = 0x00000100;

  static final int DEPTH_CLEAR_VALUE = 0x0B73;

  static final int DEPTH_COMPONENT = 0x1902;

  static final int DEPTH_COMPONENT16 = 0x81A5;

  static final int DEPTH_FUNC = 0x0B74;

  static final int DEPTH_RANGE = 0x0B70;

  static final int DEPTH_STENCIL = 0x84F9;

  static final int DEPTH_STENCIL_ATTACHMENT = 0x821A;

  static final int DEPTH_TEST = 0x0B71;

  static final int DEPTH_WRITEMASK = 0x0B72;

  static final int DITHER = 0x0BD0;

  static final int DONT_CARE = 0x1100;

  static final int DST_ALPHA = 0x0304;

  static final int DST_COLOR = 0x0306;

  static final int DYNAMIC_DRAW = 0x88E8;

  static final int ELEMENT_ARRAY_BUFFER = 0x8893;

  static final int ELEMENT_ARRAY_BUFFER_BINDING = 0x8895;

  static final int EQUAL = 0x0202;

  static final int FASTEST = 0x1101;

  static final int FLOAT = 0x1406;

  static final int FLOAT_MAT2 = 0x8B5A;

  static final int FLOAT_MAT3 = 0x8B5B;

  static final int FLOAT_MAT4 = 0x8B5C;

  static final int FLOAT_VEC2 = 0x8B50;

  static final int FLOAT_VEC3 = 0x8B51;

  static final int FLOAT_VEC4 = 0x8B52;

  static final int FRAGMENT_SHADER = 0x8B30;

  static final int FRAMEBUFFER = 0x8D40;

  static final int FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1;

  static final int FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0;

  static final int FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;

  static final int FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2;

  static final int FRAMEBUFFER_BINDING = 0x8CA6;

  static final int FRAMEBUFFER_COMPLETE = 0x8CD5;

  static final int FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6;

  static final int FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9;

  static final int FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;

  static final int FRAMEBUFFER_UNSUPPORTED = 0x8CDD;

  static final int FRONT = 0x0404;

  static final int FRONT_AND_BACK = 0x0408;

  static final int FRONT_FACE = 0x0B46;

  static final int FUNC_ADD = 0x8006;

  static final int FUNC_REVERSE_SUBTRACT = 0x800B;

  static final int FUNC_SUBTRACT = 0x800A;

  static final int GENERATE_MIPMAP_HINT = 0x8192;

  static final int GEQUAL = 0x0206;

  static final int GREATER = 0x0204;

  static final int GREEN_BITS = 0x0D53;

  static final int HIGH_FLOAT = 0x8DF2;

  static final int HIGH_INT = 0x8DF5;

  static final int INCR = 0x1E02;

  static final int INCR_WRAP = 0x8507;

  static final int INT = 0x1404;

  static final int INT_VEC2 = 0x8B53;

  static final int INT_VEC3 = 0x8B54;

  static final int INT_VEC4 = 0x8B55;

  static final int INVALID_ENUM = 0x0500;

  static final int INVALID_FRAMEBUFFER_OPERATION = 0x0506;

  static final int INVALID_OPERATION = 0x0502;

  static final int INVALID_VALUE = 0x0501;

  static final int INVERT = 0x150A;

  static final int KEEP = 0x1E00;

  static final int LEQUAL = 0x0203;

  static final int LESS = 0x0201;

  static final int LINEAR = 0x2601;

  static final int LINEAR_MIPMAP_LINEAR = 0x2703;

  static final int LINEAR_MIPMAP_NEAREST = 0x2701;

  static final int LINES = 0x0001;

  static final int LINE_LOOP = 0x0002;

  static final int LINE_STRIP = 0x0003;

  static final int LINE_WIDTH = 0x0B21;

  static final int LINK_STATUS = 0x8B82;

  static final int LOW_FLOAT = 0x8DF0;

  static final int LOW_INT = 0x8DF3;

  static final int LUMINANCE = 0x1909;

  static final int LUMINANCE_ALPHA = 0x190A;

  static final int MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;

  static final int MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;

  static final int MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD;

  static final int MAX_RENDERBUFFER_SIZE = 0x84E8;

  static final int MAX_TEXTURE_IMAGE_UNITS = 0x8872;

  static final int MAX_TEXTURE_SIZE = 0x0D33;

  static final int MAX_VARYING_VECTORS = 0x8DFC;

  static final int MAX_VERTEX_ATTRIBS = 0x8869;

  static final int MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;

  static final int MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB;

  static final int MAX_VIEWPORT_DIMS = 0x0D3A;

  static final int MEDIUM_FLOAT = 0x8DF1;

  static final int MEDIUM_INT = 0x8DF4;

  static final int MIRRORED_REPEAT = 0x8370;

  static final int NEAREST = 0x2600;

  static final int NEAREST_MIPMAP_LINEAR = 0x2702;

  static final int NEAREST_MIPMAP_NEAREST = 0x2700;

  static final int NEVER = 0x0200;

  static final int NICEST = 0x1102;

  static final int NONE = 0;

  static final int NOTEQUAL = 0x0205;

  static final int NO_ERROR = 0;

  static final int ONE = 1;

  static final int ONE_MINUS_CONSTANT_ALPHA = 0x8004;

  static final int ONE_MINUS_CONSTANT_COLOR = 0x8002;

  static final int ONE_MINUS_DST_ALPHA = 0x0305;

  static final int ONE_MINUS_DST_COLOR = 0x0307;

  static final int ONE_MINUS_SRC_ALPHA = 0x0303;

  static final int ONE_MINUS_SRC_COLOR = 0x0301;

  static final int OUT_OF_MEMORY = 0x0505;

  static final int PACK_ALIGNMENT = 0x0D05;

  static final int POINTS = 0x0000;

  static final int POLYGON_OFFSET_FACTOR = 0x8038;

  static final int POLYGON_OFFSET_FILL = 0x8037;

  static final int POLYGON_OFFSET_UNITS = 0x2A00;

  static final int RED_BITS = 0x0D52;

  static final int RENDERBUFFER = 0x8D41;

  static final int RENDERBUFFER_ALPHA_SIZE = 0x8D53;

  static final int RENDERBUFFER_BINDING = 0x8CA7;

  static final int RENDERBUFFER_BLUE_SIZE = 0x8D52;

  static final int RENDERBUFFER_DEPTH_SIZE = 0x8D54;

  static final int RENDERBUFFER_GREEN_SIZE = 0x8D51;

  static final int RENDERBUFFER_HEIGHT = 0x8D43;

  static final int RENDERBUFFER_INTERNAL_FORMAT = 0x8D44;

  static final int RENDERBUFFER_RED_SIZE = 0x8D50;

  static final int RENDERBUFFER_STENCIL_SIZE = 0x8D55;

  static final int RENDERBUFFER_WIDTH = 0x8D42;

  static final int RENDERER = 0x1F01;

  static final int REPEAT = 0x2901;

  static final int REPLACE = 0x1E01;

  static final int RGB = 0x1907;

  static final int RGB565 = 0x8D62;

  static final int RGB5_A1 = 0x8057;

  static final int RGBA = 0x1908;

  static final int RGBA4 = 0x8056;

  static final int SAMPLER_2D = 0x8B5E;

  static final int SAMPLER_CUBE = 0x8B60;

  static final int SAMPLES = 0x80A9;

  static final int SAMPLE_ALPHA_TO_COVERAGE = 0x809E;

  static final int SAMPLE_BUFFERS = 0x80A8;

  static final int SAMPLE_COVERAGE = 0x80A0;

  static final int SAMPLE_COVERAGE_INVERT = 0x80AB;

  static final int SAMPLE_COVERAGE_VALUE = 0x80AA;

  static final int SCISSOR_BOX = 0x0C10;

  static final int SCISSOR_TEST = 0x0C11;

  static final int SHADER_TYPE = 0x8B4F;

  static final int SHADING_LANGUAGE_VERSION = 0x8B8C;

  static final int SHORT = 0x1402;

  static final int SRC_ALPHA = 0x0302;

  static final int SRC_ALPHA_SATURATE = 0x0308;

  static final int SRC_COLOR = 0x0300;

  static final int STATIC_DRAW = 0x88E4;

  static final int STENCIL_ATTACHMENT = 0x8D20;

  static final int STENCIL_BACK_FAIL = 0x8801;

  static final int STENCIL_BACK_FUNC = 0x8800;

  static final int STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802;

  static final int STENCIL_BACK_PASS_DEPTH_PASS = 0x8803;

  static final int STENCIL_BACK_REF = 0x8CA3;

  static final int STENCIL_BACK_VALUE_MASK = 0x8CA4;

  static final int STENCIL_BACK_WRITEMASK = 0x8CA5;

  static final int STENCIL_BITS = 0x0D57;

  static final int STENCIL_BUFFER_BIT = 0x00000400;

  static final int STENCIL_CLEAR_VALUE = 0x0B91;

  static final int STENCIL_FAIL = 0x0B94;

  static final int STENCIL_FUNC = 0x0B92;

  static final int STENCIL_INDEX = 0x1901;

  static final int STENCIL_INDEX8 = 0x8D48;

  static final int STENCIL_PASS_DEPTH_FAIL = 0x0B95;

  static final int STENCIL_PASS_DEPTH_PASS = 0x0B96;

  static final int STENCIL_REF = 0x0B97;

  static final int STENCIL_TEST = 0x0B90;

  static final int STENCIL_VALUE_MASK = 0x0B93;

  static final int STENCIL_WRITEMASK = 0x0B98;

  static final int STREAM_DRAW = 0x88E0;

  static final int SUBPIXEL_BITS = 0x0D50;

  static final int TEXTURE = 0x1702;

  static final int TEXTURE0 = 0x84C0;

  static final int TEXTURE1 = 0x84C1;

  static final int TEXTURE10 = 0x84CA;

  static final int TEXTURE11 = 0x84CB;

  static final int TEXTURE12 = 0x84CC;

  static final int TEXTURE13 = 0x84CD;

  static final int TEXTURE14 = 0x84CE;

  static final int TEXTURE15 = 0x84CF;

  static final int TEXTURE16 = 0x84D0;

  static final int TEXTURE17 = 0x84D1;

  static final int TEXTURE18 = 0x84D2;

  static final int TEXTURE19 = 0x84D3;

  static final int TEXTURE2 = 0x84C2;

  static final int TEXTURE20 = 0x84D4;

  static final int TEXTURE21 = 0x84D5;

  static final int TEXTURE22 = 0x84D6;

  static final int TEXTURE23 = 0x84D7;

  static final int TEXTURE24 = 0x84D8;

  static final int TEXTURE25 = 0x84D9;

  static final int TEXTURE26 = 0x84DA;

  static final int TEXTURE27 = 0x84DB;

  static final int TEXTURE28 = 0x84DC;

  static final int TEXTURE29 = 0x84DD;

  static final int TEXTURE3 = 0x84C3;

  static final int TEXTURE30 = 0x84DE;

  static final int TEXTURE31 = 0x84DF;

  static final int TEXTURE4 = 0x84C4;

  static final int TEXTURE5 = 0x84C5;

  static final int TEXTURE6 = 0x84C6;

  static final int TEXTURE7 = 0x84C7;

  static final int TEXTURE8 = 0x84C8;

  static final int TEXTURE9 = 0x84C9;

  static final int TEXTURE_2D = 0x0DE1;

  static final int TEXTURE_BINDING_2D = 0x8069;

  static final int TEXTURE_BINDING_CUBE_MAP = 0x8514;

  static final int TEXTURE_CUBE_MAP = 0x8513;

  static final int TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;

  static final int TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;

  static final int TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;

  static final int TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;

  static final int TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;

  static final int TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;

  static final int TEXTURE_MAG_FILTER = 0x2800;

  static final int TEXTURE_MIN_FILTER = 0x2801;

  static final int TEXTURE_WRAP_S = 0x2802;

  static final int TEXTURE_WRAP_T = 0x2803;

  static final int TRIANGLES = 0x0004;

  static final int TRIANGLE_FAN = 0x0006;

  static final int TRIANGLE_STRIP = 0x0005;

  static final int UNPACK_ALIGNMENT = 0x0CF5;

  static final int UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;

  static final int UNPACK_FLIP_Y_WEBGL = 0x9240;

  static final int UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;

  static final int UNSIGNED_BYTE = 0x1401;

  static final int UNSIGNED_INT = 0x1405;

  static final int UNSIGNED_SHORT = 0x1403;

  static final int UNSIGNED_SHORT_4_4_4_4 = 0x8033;

  static final int UNSIGNED_SHORT_5_5_5_1 = 0x8034;

  static final int UNSIGNED_SHORT_5_6_5 = 0x8363;

  static final int VALIDATE_STATUS = 0x8B83;

  static final int VENDOR = 0x1F00;

  static final int VERSION = 0x1F02;

  static final int VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;

  static final int VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622;

  static final int VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A;

  static final int VERTEX_ATTRIB_ARRAY_POINTER = 0x8645;

  static final int VERTEX_ATTRIB_ARRAY_SIZE = 0x8623;

  static final int VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624;

  static final int VERTEX_ATTRIB_ARRAY_TYPE = 0x8625;

  static final int VERTEX_SHADER = 0x8B31;

  static final int VIEWPORT = 0x0BA2;

  static final int ZERO = 0;

  /** @domName WebGLRenderingContext.drawingBufferHeight */
  final int drawingBufferHeight;

  /** @domName WebGLRenderingContext.drawingBufferWidth */
  final int drawingBufferWidth;

  /** @domName WebGLRenderingContext.activeTexture */
  void activeTexture(int texture);

  /** @domName WebGLRenderingContext.attachShader */
  void attachShader(WebGLProgram program, WebGLShader shader);

  /** @domName WebGLRenderingContext.bindAttribLocation */
  void bindAttribLocation(WebGLProgram program, int index, String name);

  /** @domName WebGLRenderingContext.bindBuffer */
  void bindBuffer(int target, WebGLBuffer buffer);

  /** @domName WebGLRenderingContext.bindFramebuffer */
  void bindFramebuffer(int target, WebGLFramebuffer framebuffer);

  /** @domName WebGLRenderingContext.bindRenderbuffer */
  void bindRenderbuffer(int target, WebGLRenderbuffer renderbuffer);

  /** @domName WebGLRenderingContext.bindTexture */
  void bindTexture(int target, WebGLTexture texture);

  /** @domName WebGLRenderingContext.blendColor */
  void blendColor(num red, num green, num blue, num alpha);

  /** @domName WebGLRenderingContext.blendEquation */
  void blendEquation(int mode);

  /** @domName WebGLRenderingContext.blendEquationSeparate */
  void blendEquationSeparate(int modeRGB, int modeAlpha);

  /** @domName WebGLRenderingContext.blendFunc */
  void blendFunc(int sfactor, int dfactor);

  /** @domName WebGLRenderingContext.blendFuncSeparate */
  void blendFuncSeparate(int srcRGB, int dstRGB, int srcAlpha, int dstAlpha);

  /** @domName WebGLRenderingContext.bufferData */
  void bufferData(int target, data_OR_size, int usage);

  /** @domName WebGLRenderingContext.bufferSubData */
  void bufferSubData(int target, int offset, data);

  /** @domName WebGLRenderingContext.checkFramebufferStatus */
  int checkFramebufferStatus(int target);

  /** @domName WebGLRenderingContext.clear */
  void clear(int mask);

  /** @domName WebGLRenderingContext.clearColor */
  void clearColor(num red, num green, num blue, num alpha);

  /** @domName WebGLRenderingContext.clearDepth */
  void clearDepth(num depth);

  /** @domName WebGLRenderingContext.clearStencil */
  void clearStencil(int s);

  /** @domName WebGLRenderingContext.colorMask */
  void colorMask(bool red, bool green, bool blue, bool alpha);

  /** @domName WebGLRenderingContext.compileShader */
  void compileShader(WebGLShader shader);

  /** @domName WebGLRenderingContext.compressedTexImage2D */
  void compressedTexImage2D(int target, int level, int internalformat, int width, int height, int border, ArrayBufferView data);

  /** @domName WebGLRenderingContext.compressedTexSubImage2D */
  void compressedTexSubImage2D(int target, int level, int xoffset, int yoffset, int width, int height, int format, ArrayBufferView data);

  /** @domName WebGLRenderingContext.copyTexImage2D */
  void copyTexImage2D(int target, int level, int internalformat, int x, int y, int width, int height, int border);

  /** @domName WebGLRenderingContext.copyTexSubImage2D */
  void copyTexSubImage2D(int target, int level, int xoffset, int yoffset, int x, int y, int width, int height);

  /** @domName WebGLRenderingContext.createBuffer */
  WebGLBuffer createBuffer();

  /** @domName WebGLRenderingContext.createFramebuffer */
  WebGLFramebuffer createFramebuffer();

  /** @domName WebGLRenderingContext.createProgram */
  WebGLProgram createProgram();

  /** @domName WebGLRenderingContext.createRenderbuffer */
  WebGLRenderbuffer createRenderbuffer();

  /** @domName WebGLRenderingContext.createShader */
  WebGLShader createShader(int type);

  /** @domName WebGLRenderingContext.createTexture */
  WebGLTexture createTexture();

  /** @domName WebGLRenderingContext.cullFace */
  void cullFace(int mode);

  /** @domName WebGLRenderingContext.deleteBuffer */
  void deleteBuffer(WebGLBuffer buffer);

  /** @domName WebGLRenderingContext.deleteFramebuffer */
  void deleteFramebuffer(WebGLFramebuffer framebuffer);

  /** @domName WebGLRenderingContext.deleteProgram */
  void deleteProgram(WebGLProgram program);

  /** @domName WebGLRenderingContext.deleteRenderbuffer */
  void deleteRenderbuffer(WebGLRenderbuffer renderbuffer);

  /** @domName WebGLRenderingContext.deleteShader */
  void deleteShader(WebGLShader shader);

  /** @domName WebGLRenderingContext.deleteTexture */
  void deleteTexture(WebGLTexture texture);

  /** @domName WebGLRenderingContext.depthFunc */
  void depthFunc(int func);

  /** @domName WebGLRenderingContext.depthMask */
  void depthMask(bool flag);

  /** @domName WebGLRenderingContext.depthRange */
  void depthRange(num zNear, num zFar);

  /** @domName WebGLRenderingContext.detachShader */
  void detachShader(WebGLProgram program, WebGLShader shader);

  /** @domName WebGLRenderingContext.disable */
  void disable(int cap);

  /** @domName WebGLRenderingContext.disableVertexAttribArray */
  void disableVertexAttribArray(int index);

  /** @domName WebGLRenderingContext.drawArrays */
  void drawArrays(int mode, int first, int count);

  /** @domName WebGLRenderingContext.drawElements */
  void drawElements(int mode, int count, int type, int offset);

  /** @domName WebGLRenderingContext.enable */
  void enable(int cap);

  /** @domName WebGLRenderingContext.enableVertexAttribArray */
  void enableVertexAttribArray(int index);

  /** @domName WebGLRenderingContext.finish */
  void finish();

  /** @domName WebGLRenderingContext.flush */
  void flush();

  /** @domName WebGLRenderingContext.framebufferRenderbuffer */
  void framebufferRenderbuffer(int target, int attachment, int renderbuffertarget, WebGLRenderbuffer renderbuffer);

  /** @domName WebGLRenderingContext.framebufferTexture2D */
  void framebufferTexture2D(int target, int attachment, int textarget, WebGLTexture texture, int level);

  /** @domName WebGLRenderingContext.frontFace */
  void frontFace(int mode);

  /** @domName WebGLRenderingContext.generateMipmap */
  void generateMipmap(int target);

  /** @domName WebGLRenderingContext.getActiveAttrib */
  WebGLActiveInfo getActiveAttrib(WebGLProgram program, int index);

  /** @domName WebGLRenderingContext.getActiveUniform */
  WebGLActiveInfo getActiveUniform(WebGLProgram program, int index);

  /** @domName WebGLRenderingContext.getAttachedShaders */
  List getAttachedShaders(WebGLProgram program);

  /** @domName WebGLRenderingContext.getAttribLocation */
  int getAttribLocation(WebGLProgram program, String name);

  /** @domName WebGLRenderingContext.getBufferParameter */
  Object getBufferParameter(int target, int pname);

  /** @domName WebGLRenderingContext.getContextAttributes */
  WebGLContextAttributes getContextAttributes();

  /** @domName WebGLRenderingContext.getError */
  int getError();

  /** @domName WebGLRenderingContext.getExtension */
  Object getExtension(String name);

  /** @domName WebGLRenderingContext.getFramebufferAttachmentParameter */
  Object getFramebufferAttachmentParameter(int target, int attachment, int pname);

  /** @domName WebGLRenderingContext.getParameter */
  Object getParameter(int pname);

  /** @domName WebGLRenderingContext.getProgramInfoLog */
  String getProgramInfoLog(WebGLProgram program);

  /** @domName WebGLRenderingContext.getProgramParameter */
  Object getProgramParameter(WebGLProgram program, int pname);

  /** @domName WebGLRenderingContext.getRenderbufferParameter */
  Object getRenderbufferParameter(int target, int pname);

  /** @domName WebGLRenderingContext.getShaderInfoLog */
  String getShaderInfoLog(WebGLShader shader);

  /** @domName WebGLRenderingContext.getShaderParameter */
  Object getShaderParameter(WebGLShader shader, int pname);

  /** @domName WebGLRenderingContext.getShaderPrecisionFormat */
  WebGLShaderPrecisionFormat getShaderPrecisionFormat(int shadertype, int precisiontype);

  /** @domName WebGLRenderingContext.getShaderSource */
  String getShaderSource(WebGLShader shader);

  /** @domName WebGLRenderingContext.getTexParameter */
  Object getTexParameter(int target, int pname);

  /** @domName WebGLRenderingContext.getUniform */
  Object getUniform(WebGLProgram program, WebGLUniformLocation location);

  /** @domName WebGLRenderingContext.getUniformLocation */
  WebGLUniformLocation getUniformLocation(WebGLProgram program, String name);

  /** @domName WebGLRenderingContext.getVertexAttrib */
  Object getVertexAttrib(int index, int pname);

  /** @domName WebGLRenderingContext.getVertexAttribOffset */
  int getVertexAttribOffset(int index, int pname);

  /** @domName WebGLRenderingContext.hint */
  void hint(int target, int mode);

  /** @domName WebGLRenderingContext.isBuffer */
  bool isBuffer(WebGLBuffer buffer);

  /** @domName WebGLRenderingContext.isContextLost */
  bool isContextLost();

  /** @domName WebGLRenderingContext.isEnabled */
  bool isEnabled(int cap);

  /** @domName WebGLRenderingContext.isFramebuffer */
  bool isFramebuffer(WebGLFramebuffer framebuffer);

  /** @domName WebGLRenderingContext.isProgram */
  bool isProgram(WebGLProgram program);

  /** @domName WebGLRenderingContext.isRenderbuffer */
  bool isRenderbuffer(WebGLRenderbuffer renderbuffer);

  /** @domName WebGLRenderingContext.isShader */
  bool isShader(WebGLShader shader);

  /** @domName WebGLRenderingContext.isTexture */
  bool isTexture(WebGLTexture texture);

  /** @domName WebGLRenderingContext.lineWidth */
  void lineWidth(num width);

  /** @domName WebGLRenderingContext.linkProgram */
  void linkProgram(WebGLProgram program);

  /** @domName WebGLRenderingContext.pixelStorei */
  void pixelStorei(int pname, int param);

  /** @domName WebGLRenderingContext.polygonOffset */
  void polygonOffset(num factor, num units);

  /** @domName WebGLRenderingContext.readPixels */
  void readPixels(int x, int y, int width, int height, int format, int type, ArrayBufferView pixels);

  /** @domName WebGLRenderingContext.releaseShaderCompiler */
  void releaseShaderCompiler();

  /** @domName WebGLRenderingContext.renderbufferStorage */
  void renderbufferStorage(int target, int internalformat, int width, int height);

  /** @domName WebGLRenderingContext.sampleCoverage */
  void sampleCoverage(num value, bool invert);

  /** @domName WebGLRenderingContext.scissor */
  void scissor(int x, int y, int width, int height);

  /** @domName WebGLRenderingContext.shaderSource */
  void shaderSource(WebGLShader shader, String string);

  /** @domName WebGLRenderingContext.stencilFunc */
  void stencilFunc(int func, int ref, int mask);

  /** @domName WebGLRenderingContext.stencilFuncSeparate */
  void stencilFuncSeparate(int face, int func, int ref, int mask);

  /** @domName WebGLRenderingContext.stencilMask */
  void stencilMask(int mask);

  /** @domName WebGLRenderingContext.stencilMaskSeparate */
  void stencilMaskSeparate(int face, int mask);

  /** @domName WebGLRenderingContext.stencilOp */
  void stencilOp(int fail, int zfail, int zpass);

  /** @domName WebGLRenderingContext.stencilOpSeparate */
  void stencilOpSeparate(int face, int fail, int zfail, int zpass);

  /** @domName WebGLRenderingContext.texImage2D */
  void texImage2D(int target, int level, int internalformat, int format_OR_width, int height_OR_type, border_OR_canvas_OR_image_OR_pixels_OR_video, [int format, int type, ArrayBufferView pixels]);

  /** @domName WebGLRenderingContext.texParameterf */
  void texParameterf(int target, int pname, num param);

  /** @domName WebGLRenderingContext.texParameteri */
  void texParameteri(int target, int pname, int param);

  /** @domName WebGLRenderingContext.texSubImage2D */
  void texSubImage2D(int target, int level, int xoffset, int yoffset, int format_OR_width, int height_OR_type, canvas_OR_format_OR_image_OR_pixels_OR_video, [int type, ArrayBufferView pixels]);

  /** @domName WebGLRenderingContext.uniform1f */
  void uniform1f(WebGLUniformLocation location, num x);

  /** @domName WebGLRenderingContext.uniform1fv */
  void uniform1fv(WebGLUniformLocation location, Float32Array v);

  /** @domName WebGLRenderingContext.uniform1i */
  void uniform1i(WebGLUniformLocation location, int x);

  /** @domName WebGLRenderingContext.uniform1iv */
  void uniform1iv(WebGLUniformLocation location, Int32Array v);

  /** @domName WebGLRenderingContext.uniform2f */
  void uniform2f(WebGLUniformLocation location, num x, num y);

  /** @domName WebGLRenderingContext.uniform2fv */
  void uniform2fv(WebGLUniformLocation location, Float32Array v);

  /** @domName WebGLRenderingContext.uniform2i */
  void uniform2i(WebGLUniformLocation location, int x, int y);

  /** @domName WebGLRenderingContext.uniform2iv */
  void uniform2iv(WebGLUniformLocation location, Int32Array v);

  /** @domName WebGLRenderingContext.uniform3f */
  void uniform3f(WebGLUniformLocation location, num x, num y, num z);

  /** @domName WebGLRenderingContext.uniform3fv */
  void uniform3fv(WebGLUniformLocation location, Float32Array v);

  /** @domName WebGLRenderingContext.uniform3i */
  void uniform3i(WebGLUniformLocation location, int x, int y, int z);

  /** @domName WebGLRenderingContext.uniform3iv */
  void uniform3iv(WebGLUniformLocation location, Int32Array v);

  /** @domName WebGLRenderingContext.uniform4f */
  void uniform4f(WebGLUniformLocation location, num x, num y, num z, num w);

  /** @domName WebGLRenderingContext.uniform4fv */
  void uniform4fv(WebGLUniformLocation location, Float32Array v);

  /** @domName WebGLRenderingContext.uniform4i */
  void uniform4i(WebGLUniformLocation location, int x, int y, int z, int w);

  /** @domName WebGLRenderingContext.uniform4iv */
  void uniform4iv(WebGLUniformLocation location, Int32Array v);

  /** @domName WebGLRenderingContext.uniformMatrix2fv */
  void uniformMatrix2fv(WebGLUniformLocation location, bool transpose, Float32Array array);

  /** @domName WebGLRenderingContext.uniformMatrix3fv */
  void uniformMatrix3fv(WebGLUniformLocation location, bool transpose, Float32Array array);

  /** @domName WebGLRenderingContext.uniformMatrix4fv */
  void uniformMatrix4fv(WebGLUniformLocation location, bool transpose, Float32Array array);

  /** @domName WebGLRenderingContext.useProgram */
  void useProgram(WebGLProgram program);

  /** @domName WebGLRenderingContext.validateProgram */
  void validateProgram(WebGLProgram program);

  /** @domName WebGLRenderingContext.vertexAttrib1f */
  void vertexAttrib1f(int indx, num x);

  /** @domName WebGLRenderingContext.vertexAttrib1fv */
  void vertexAttrib1fv(int indx, Float32Array values);

  /** @domName WebGLRenderingContext.vertexAttrib2f */
  void vertexAttrib2f(int indx, num x, num y);

  /** @domName WebGLRenderingContext.vertexAttrib2fv */
  void vertexAttrib2fv(int indx, Float32Array values);

  /** @domName WebGLRenderingContext.vertexAttrib3f */
  void vertexAttrib3f(int indx, num x, num y, num z);

  /** @domName WebGLRenderingContext.vertexAttrib3fv */
  void vertexAttrib3fv(int indx, Float32Array values);

  /** @domName WebGLRenderingContext.vertexAttrib4f */
  void vertexAttrib4f(int indx, num x, num y, num z, num w);

  /** @domName WebGLRenderingContext.vertexAttrib4fv */
  void vertexAttrib4fv(int indx, Float32Array values);

  /** @domName WebGLRenderingContext.vertexAttribPointer */
  void vertexAttribPointer(int indx, int size, int type, bool normalized, int stride, int offset);

  /** @domName WebGLRenderingContext.viewport */
  void viewport(int x, int y, int width, int height);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLShader
interface WebGLShader {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLShaderPrecisionFormat
interface WebGLShaderPrecisionFormat {

  /** @domName WebGLShaderPrecisionFormat.precision */
  final int precision;

  /** @domName WebGLShaderPrecisionFormat.rangeMax */
  final int rangeMax;

  /** @domName WebGLShaderPrecisionFormat.rangeMin */
  final int rangeMin;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLTexture
interface WebGLTexture {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLUniformLocation
interface WebGLUniformLocation {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebGLVertexArrayObjectOES
interface WebGLVertexArrayObjectOES {
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitCSSFilterValue
interface WebKitCSSFilterValue extends CSSValueList {

  static final int CSS_FILTER_BLUR = 10;

  static final int CSS_FILTER_BRIGHTNESS = 8;

  static final int CSS_FILTER_CONTRAST = 9;

  static final int CSS_FILTER_CUSTOM = 12;

  static final int CSS_FILTER_DROP_SHADOW = 11;

  static final int CSS_FILTER_GRAYSCALE = 2;

  static final int CSS_FILTER_HUE_ROTATE = 5;

  static final int CSS_FILTER_INVERT = 6;

  static final int CSS_FILTER_OPACITY = 7;

  static final int CSS_FILTER_REFERENCE = 1;

  static final int CSS_FILTER_SATURATE = 4;

  static final int CSS_FILTER_SEPIA = 3;

  /** @domName WebKitCSSFilterValue.operationType */
  final int operationType;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitCSSRegionRule
interface WebKitCSSRegionRule extends CSSRule {

  /** @domName WebKitCSSRegionRule.cssRules */
  final CSSRuleList cssRules;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitMutationObserver
interface WebKitMutationObserver {

  /** @domName WebKitMutationObserver.disconnect */
  void disconnect();

  /** @domName WebKitMutationObserver.takeRecords */
  List<MutationRecord> takeRecords();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebKitNamedFlow
interface WebKitNamedFlow {

  /** @domName WebKitNamedFlow.contentNodes */
  final NodeList contentNodes;

  /** @domName WebKitNamedFlow.overflow */
  final bool overflow;

  /** @domName WebKitNamedFlow.getRegionsByContentNode */
  NodeList getRegionsByContentNode(Node contentNode);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WebSocket
interface WebSocket extends EventTarget default _WebSocketFactoryProvider {

  WebSocket(String url);

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  WebSocketEvents get on();

  static final int CLOSED = 3;

  static final int CLOSING = 2;

  static final int CONNECTING = 0;

  static final int OPEN = 1;

  /** @domName WebSocket.URL */
  final String URL;

  /** @domName WebSocket.binaryType */
  String binaryType;

  /** @domName WebSocket.bufferedAmount */
  final int bufferedAmount;

  /** @domName WebSocket.extensions */
  final String extensions;

  /** @domName WebSocket.protocol */
  final String protocol;

  /** @domName WebSocket.readyState */
  final int readyState;

  /** @domName WebSocket.url */
  final String url;

  /** @domName WebSocket.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName WebSocket.close */
  void close([int code, String reason]);

  /** @domName WebSocket.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName WebSocket.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName WebSocket.send */
  bool send(String data);
}

interface WebSocketEvents extends Events {

  EventListenerList get close();

  EventListenerList get error();

  EventListenerList get message();

  EventListenerList get open();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WheelEvent
interface WheelEvent extends UIEvent {

  /** @domName WheelEvent.altKey */
  final bool altKey;

  /** @domName WheelEvent.clientX */
  final int clientX;

  /** @domName WheelEvent.clientY */
  final int clientY;

  /** @domName WheelEvent.ctrlKey */
  final bool ctrlKey;

  /** @domName WheelEvent.metaKey */
  final bool metaKey;

  /** @domName WheelEvent.offsetX */
  final int offsetX;

  /** @domName WheelEvent.offsetY */
  final int offsetY;

  /** @domName WheelEvent.screenX */
  final int screenX;

  /** @domName WheelEvent.screenY */
  final int screenY;

  /** @domName WheelEvent.shiftKey */
  final bool shiftKey;

  /** @domName WheelEvent.webkitDirectionInvertedFromDevice */
  final bool webkitDirectionInvertedFromDevice;

  /** @domName WheelEvent.wheelDelta */
  final int wheelDelta;

  /** @domName WheelEvent.wheelDeltaX */
  final int wheelDeltaX;

  /** @domName WheelEvent.wheelDeltaY */
  final int wheelDeltaY;

  /** @domName WheelEvent.x */
  final int x;

  /** @domName WheelEvent.y */
  final int y;

  /** @domName WheelEvent.initWebKitWheelEvent */
  void initWebKitWheelEvent(int wheelDeltaX, int wheelDeltaY, Window view, int screenX, int screenY, int clientX, int clientY, bool ctrlKey, bool altKey, bool shiftKey, bool metaKey);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName DOMWindow
interface Window extends EventTarget {

  /**
   * Executes a [callback] after the next batch of browser layout measurements
   * has completed or would have completed if any browser layout measurements
   * had been scheduled.
   */
  void requestLayoutFrame(TimeoutHandler callback);


  /** @domName DOMWindow.webkitRequestAnimationFrame */
  int requestAnimationFrame(RequestAnimationFrameCallback callback);


  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  WindowEvents get on();

  static final int PERSISTENT = 1;

  static final int TEMPORARY = 0;

  /** @domName DOMWindow.applicationCache */
  final DOMApplicationCache applicationCache;

  /** @domName DOMWindow.clientInformation */
  final Navigator clientInformation;

  /** @domName DOMWindow.closed */
  final bool closed;

  /** @domName DOMWindow.console */
  final Console console;

  /** @domName DOMWindow.crypto */
  final Crypto crypto;

  /** @domName DOMWindow.defaultStatus */
  String defaultStatus;

  /** @domName DOMWindow.defaultstatus */
  String defaultstatus;

  /** @domName DOMWindow.devicePixelRatio */
  final num devicePixelRatio;

  /** @domName DOMWindow.event */
  final Event event;

  /** @domName DOMWindow.frames */
  final Window frames;

  /** @domName DOMWindow.history */
  final History history;

  /** @domName DOMWindow.innerHeight */
  final int innerHeight;

  /** @domName DOMWindow.innerWidth */
  final int innerWidth;

  /** @domName DOMWindow.length */
  final int length;

  /** @domName DOMWindow.localStorage */
  final Storage localStorage;

  /** @domName DOMWindow.location */
  Location location;

  /** @domName DOMWindow.locationbar */
  final BarInfo locationbar;

  /** @domName DOMWindow.menubar */
  final BarInfo menubar;

  /** @domName DOMWindow.name */
  String name;

  /** @domName DOMWindow.navigator */
  final Navigator navigator;

  /** @domName DOMWindow.offscreenBuffering */
  final bool offscreenBuffering;

  /** @domName DOMWindow.opener */
  final Window opener;

  /** @domName DOMWindow.outerHeight */
  final int outerHeight;

  /** @domName DOMWindow.outerWidth */
  final int outerWidth;

  /** @domName DOMWindow.pageXOffset */
  final int pageXOffset;

  /** @domName DOMWindow.pageYOffset */
  final int pageYOffset;

  /** @domName DOMWindow.parent */
  final Window parent;

  /** @domName DOMWindow.performance */
  final Performance performance;

  /** @domName DOMWindow.personalbar */
  final BarInfo personalbar;

  /** @domName DOMWindow.screen */
  final Screen screen;

  /** @domName DOMWindow.screenLeft */
  final int screenLeft;

  /** @domName DOMWindow.screenTop */
  final int screenTop;

  /** @domName DOMWindow.screenX */
  final int screenX;

  /** @domName DOMWindow.screenY */
  final int screenY;

  /** @domName DOMWindow.scrollX */
  final int scrollX;

  /** @domName DOMWindow.scrollY */
  final int scrollY;

  /** @domName DOMWindow.scrollbars */
  final BarInfo scrollbars;

  /** @domName DOMWindow.self */
  final Window self;

  /** @domName DOMWindow.sessionStorage */
  final Storage sessionStorage;

  /** @domName DOMWindow.status */
  String status;

  /** @domName DOMWindow.statusbar */
  final BarInfo statusbar;

  /** @domName DOMWindow.styleMedia */
  final StyleMedia styleMedia;

  /** @domName DOMWindow.toolbar */
  final BarInfo toolbar;

  /** @domName DOMWindow.webkitIndexedDB */
  final IDBFactory webkitIndexedDB;

  /** @domName DOMWindow.webkitNotifications */
  final NotificationCenter webkitNotifications;

  /** @domName DOMWindow.webkitStorageInfo */
  final StorageInfo webkitStorageInfo;

  /** @domName DOMWindow.window */
  final Window window;

  /** @domName DOMWindow.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName DOMWindow.alert */
  void alert(String message);

  /** @domName DOMWindow.atob */
  String atob(String string);

  /** @domName DOMWindow.blur */
  void blur();

  /** @domName DOMWindow.btoa */
  String btoa(String string);

  /** @domName DOMWindow.captureEvents */
  void captureEvents();

  /** @domName DOMWindow.clearInterval */
  void clearInterval(int handle);

  /** @domName DOMWindow.clearTimeout */
  void clearTimeout(int handle);

  /** @domName DOMWindow.close */
  void close();

  /** @domName DOMWindow.confirm */
  bool confirm(String message);

  /** @domName DOMWindow.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName DOMWindow.find */
  bool find(String string, bool caseSensitive, bool backwards, bool wrap, bool wholeWord, bool searchInFrames, bool showDialog);

  /** @domName DOMWindow.focus */
  void focus();

  /** @domName DOMWindow.getComputedStyle */
  CSSStyleDeclaration $dom_getComputedStyle(Element element, String pseudoElement);

  /** @domName DOMWindow.getMatchedCSSRules */
  CSSRuleList getMatchedCSSRules(Element element, String pseudoElement);

  /** @domName DOMWindow.getSelection */
  DOMSelection getSelection();

  /** @domName DOMWindow.matchMedia */
  MediaQueryList matchMedia(String query);

  /** @domName DOMWindow.moveBy */
  void moveBy(num x, num y);

  /** @domName DOMWindow.moveTo */
  void moveTo(num x, num y);

  /** @domName DOMWindow.open */
  Window open(String url, String name, [String options]);

  /** @domName DOMWindow.openDatabase */
  Database openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback]);

  /** @domName DOMWindow.postMessage */
  void postMessage(/*SerializedScriptValue*/ message, String targetOrigin, [List messagePorts]);

  /** @domName DOMWindow.print */
  void print();

  /** @domName DOMWindow.prompt */
  String prompt(String message, String defaultValue);

  /** @domName DOMWindow.releaseEvents */
  void releaseEvents();

  /** @domName DOMWindow.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName DOMWindow.resizeBy */
  void resizeBy(num x, num y);

  /** @domName DOMWindow.resizeTo */
  void resizeTo(num width, num height);

  /** @domName DOMWindow.scroll */
  void scroll(int x, int y);

  /** @domName DOMWindow.scrollBy */
  void scrollBy(int x, int y);

  /** @domName DOMWindow.scrollTo */
  void scrollTo(int x, int y);

  /** @domName DOMWindow.setInterval */
  int setInterval(TimeoutHandler handler, int timeout);

  /** @domName DOMWindow.setTimeout */
  int setTimeout(TimeoutHandler handler, int timeout);

  /** @domName DOMWindow.showModalDialog */
  Object showModalDialog(String url, [Object dialogArgs, String featureArgs]);

  /** @domName DOMWindow.stop */
  void stop();

  /** @domName DOMWindow.webkitCancelAnimationFrame */
  void webkitCancelAnimationFrame(int id);

  /** @domName DOMWindow.webkitCancelRequestAnimationFrame */
  void webkitCancelRequestAnimationFrame(int id);

  /** @domName DOMWindow.webkitConvertPointFromNodeToPage */
  Point webkitConvertPointFromNodeToPage(Node node, Point p);

  /** @domName DOMWindow.webkitConvertPointFromPageToNode */
  Point webkitConvertPointFromPageToNode(Node node, Point p);

  /** @domName DOMWindow.webkitPostMessage */
  void webkitPostMessage(/*SerializedScriptValue*/ message, String targetOrigin, [List transferList]);

  /** @domName DOMWindow.webkitRequestAnimationFrame */
  int webkitRequestAnimationFrame(RequestAnimationFrameCallback callback);

  /** @domName DOMWindow.webkitRequestFileSystem */
  void webkitRequestFileSystem(int type, int size, FileSystemCallback successCallback, [ErrorCallback errorCallback]);

  /** @domName DOMWindow.webkitResolveLocalFileSystemURL */
  void webkitResolveLocalFileSystemURL(String url, [EntryCallback successCallback, ErrorCallback errorCallback]);

}

interface WindowEvents extends Events {

  EventListenerList get abort();

  EventListenerList get animationEnd();

  EventListenerList get animationIteration();

  EventListenerList get animationStart();

  EventListenerList get beforeUnload();

  EventListenerList get blur();

  EventListenerList get canPlay();

  EventListenerList get canPlayThrough();

  EventListenerList get change();

  EventListenerList get click();

  EventListenerList get contentLoaded();

  EventListenerList get contextMenu();

  EventListenerList get deviceMotion();

  EventListenerList get deviceOrientation();

  EventListenerList get doubleClick();

  EventListenerList get drag();

  EventListenerList get dragEnd();

  EventListenerList get dragEnter();

  EventListenerList get dragLeave();

  EventListenerList get dragOver();

  EventListenerList get dragStart();

  EventListenerList get drop();

  EventListenerList get durationChange();

  EventListenerList get emptied();

  EventListenerList get ended();

  EventListenerList get error();

  EventListenerList get focus();

  EventListenerList get hashChange();

  EventListenerList get input();

  EventListenerList get invalid();

  EventListenerList get keyDown();

  EventListenerList get keyPress();

  EventListenerList get keyUp();

  EventListenerList get load();

  EventListenerList get loadStart();

  EventListenerList get loadedData();

  EventListenerList get loadedMetadata();

  EventListenerList get message();

  EventListenerList get mouseDown();

  EventListenerList get mouseMove();

  EventListenerList get mouseOut();

  EventListenerList get mouseOver();

  EventListenerList get mouseUp();

  EventListenerList get mouseWheel();

  EventListenerList get offline();

  EventListenerList get online();

  EventListenerList get pageHide();

  EventListenerList get pageShow();

  EventListenerList get pause();

  EventListenerList get play();

  EventListenerList get playing();

  EventListenerList get popState();

  EventListenerList get progress();

  EventListenerList get rateChange();

  EventListenerList get reset();

  EventListenerList get resize();

  EventListenerList get scroll();

  EventListenerList get search();

  EventListenerList get seeked();

  EventListenerList get seeking();

  EventListenerList get select();

  EventListenerList get stalled();

  EventListenerList get storage();

  EventListenerList get submit();

  EventListenerList get suspend();

  EventListenerList get timeUpdate();

  EventListenerList get touchCancel();

  EventListenerList get touchEnd();

  EventListenerList get touchMove();

  EventListenerList get touchStart();

  EventListenerList get transitionEnd();

  EventListenerList get unload();

  EventListenerList get volumeChange();

  EventListenerList get waiting();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName Worker
interface Worker extends AbstractWorker default _WorkerFactoryProvider {

  Worker(String scriptUrl);

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  WorkerEvents get on();

  /** @domName Worker.postMessage */
  void postMessage(/*SerializedScriptValue*/ message, [List messagePorts]);

  /** @domName Worker.terminate */
  void terminate();

  /** @domName Worker.webkitPostMessage */
  void webkitPostMessage(/*SerializedScriptValue*/ message, [List messagePorts]);
}

interface WorkerEvents extends AbstractWorkerEvents {

  EventListenerList get message();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WorkerContext
interface WorkerContext extends EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  WorkerContextEvents get on();

  static final int PERSISTENT = 1;

  static final int TEMPORARY = 0;

  /** @domName WorkerContext.location */
  final WorkerLocation location;

  /** @domName WorkerContext.navigator */
  final WorkerNavigator navigator;

  /** @domName WorkerContext.self */
  final WorkerContext self;

  /** @domName WorkerContext.webkitIndexedDB */
  final IDBFactory webkitIndexedDB;

  /** @domName WorkerContext.webkitNotifications */
  final NotificationCenter webkitNotifications;

  /** @domName WorkerContext.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName WorkerContext.clearInterval */
  void clearInterval(int handle);

  /** @domName WorkerContext.clearTimeout */
  void clearTimeout(int handle);

  /** @domName WorkerContext.close */
  void close();

  /** @domName WorkerContext.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName WorkerContext.importScripts */
  void importScripts();

  /** @domName WorkerContext.openDatabase */
  Database openDatabase(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback]);

  /** @domName WorkerContext.openDatabaseSync */
  DatabaseSync openDatabaseSync(String name, String version, String displayName, int estimatedSize, [DatabaseCallback creationCallback]);

  /** @domName WorkerContext.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName WorkerContext.setInterval */
  int setInterval(TimeoutHandler handler, int timeout);

  /** @domName WorkerContext.setTimeout */
  int setTimeout(TimeoutHandler handler, int timeout);

  /** @domName WorkerContext.webkitRequestFileSystem */
  void webkitRequestFileSystem(int type, int size, [FileSystemCallback successCallback, ErrorCallback errorCallback]);

  /** @domName WorkerContext.webkitRequestFileSystemSync */
  DOMFileSystemSync webkitRequestFileSystemSync(int type, int size);

  /** @domName WorkerContext.webkitResolveLocalFileSystemSyncURL */
  EntrySync webkitResolveLocalFileSystemSyncURL(String url);

  /** @domName WorkerContext.webkitResolveLocalFileSystemURL */
  void webkitResolveLocalFileSystemURL(String url, [EntryCallback successCallback, ErrorCallback errorCallback]);
}

interface WorkerContextEvents extends Events {

  EventListenerList get error();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WorkerLocation
interface WorkerLocation {

  /** @domName WorkerLocation.hash */
  final String hash;

  /** @domName WorkerLocation.host */
  final String host;

  /** @domName WorkerLocation.hostname */
  final String hostname;

  /** @domName WorkerLocation.href */
  final String href;

  /** @domName WorkerLocation.pathname */
  final String pathname;

  /** @domName WorkerLocation.port */
  final String port;

  /** @domName WorkerLocation.protocol */
  final String protocol;

  /** @domName WorkerLocation.search */
  final String search;

  /** @domName WorkerLocation.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName WorkerNavigator
interface WorkerNavigator {

  /** @domName WorkerNavigator.appName */
  final String appName;

  /** @domName WorkerNavigator.appVersion */
  final String appVersion;

  /** @domName WorkerNavigator.onLine */
  final bool onLine;

  /** @domName WorkerNavigator.platform */
  final String platform;

  /** @domName WorkerNavigator.userAgent */
  final String userAgent;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XMLHttpRequest
interface XMLHttpRequest extends EventTarget default _XMLHttpRequestFactoryProvider {
  // TODO(rnystrom): This name should just be "get" which is valid in Dart, but
  // not correctly implemented yet. (b/4970173)
  XMLHttpRequest.get(String url, onSuccess(XMLHttpRequest request));

  XMLHttpRequest();

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  XMLHttpRequestEvents get on();

  static final int DONE = 4;

  static final int HEADERS_RECEIVED = 2;

  static final int LOADING = 3;

  static final int OPENED = 1;

  static final int UNSENT = 0;

  /** @domName XMLHttpRequest.asBlob */
  bool asBlob;

  /** @domName XMLHttpRequest.readyState */
  final int readyState;

  /** @domName XMLHttpRequest.response */
  final Object response;

  /** @domName XMLHttpRequest.responseBlob */
  final Blob responseBlob;

  /** @domName XMLHttpRequest.responseText */
  final String responseText;

  /** @domName XMLHttpRequest.responseType */
  String responseType;

  /** @domName XMLHttpRequest.responseXML */
  final Document responseXML;

  /** @domName XMLHttpRequest.status */
  final int status;

  /** @domName XMLHttpRequest.statusText */
  final String statusText;

  /** @domName XMLHttpRequest.upload */
  final XMLHttpRequestUpload upload;

  /** @domName XMLHttpRequest.withCredentials */
  bool withCredentials;

  /** @domName XMLHttpRequest.abort */
  void abort();

  /** @domName XMLHttpRequest.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName XMLHttpRequest.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName XMLHttpRequest.getAllResponseHeaders */
  String getAllResponseHeaders();

  /** @domName XMLHttpRequest.getResponseHeader */
  String getResponseHeader(String header);

  /** @domName XMLHttpRequest.open */
  void open(String method, String url, [bool async, String user, String password]);

  /** @domName XMLHttpRequest.overrideMimeType */
  void overrideMimeType(String override);

  /** @domName XMLHttpRequest.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName XMLHttpRequest.send */
  void send([data]);

  /** @domName XMLHttpRequest.setRequestHeader */
  void setRequestHeader(String header, String value);
}

interface XMLHttpRequestEvents extends Events {

  EventListenerList get abort();

  EventListenerList get error();

  EventListenerList get load();

  EventListenerList get loadEnd();

  EventListenerList get loadStart();

  EventListenerList get progress();

  EventListenerList get readyStateChange();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XMLHttpRequestException
interface XMLHttpRequestException {

  static final int ABORT_ERR = 102;

  static final int NETWORK_ERR = 101;

  /** @domName XMLHttpRequestException.code */
  final int code;

  /** @domName XMLHttpRequestException.message */
  final String message;

  /** @domName XMLHttpRequestException.name */
  final String name;

  /** @domName XMLHttpRequestException.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XMLHttpRequestProgressEvent
interface XMLHttpRequestProgressEvent extends ProgressEvent {

  /** @domName XMLHttpRequestProgressEvent.position */
  final int position;

  /** @domName XMLHttpRequestProgressEvent.totalSize */
  final int totalSize;
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XMLHttpRequestUpload
interface XMLHttpRequestUpload extends EventTarget {

  /**
   * @domName EventTarget.addEventListener, EventTarget.removeEventListener, EventTarget.dispatchEvent
   */
  XMLHttpRequestUploadEvents get on();

  /** @domName XMLHttpRequestUpload.addEventListener */
  void $dom_addEventListener(String type, EventListener listener, [bool useCapture]);

  /** @domName XMLHttpRequestUpload.dispatchEvent */
  bool $dom_dispatchEvent(Event evt);

  /** @domName XMLHttpRequestUpload.removeEventListener */
  void $dom_removeEventListener(String type, EventListener listener, [bool useCapture]);
}

interface XMLHttpRequestUploadEvents extends Events {

  EventListenerList get abort();

  EventListenerList get error();

  EventListenerList get load();

  EventListenerList get loadEnd();

  EventListenerList get loadStart();

  EventListenerList get progress();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XMLSerializer
interface XMLSerializer default _XMLSerializerFactoryProvider {

  XMLSerializer();

  /** @domName XMLSerializer.serializeToString */
  String serializeToString(Node node);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XPathEvaluator
interface XPathEvaluator default _XPathEvaluatorFactoryProvider {

  XPathEvaluator();

  /** @domName XPathEvaluator.createExpression */
  XPathExpression createExpression(String expression, XPathNSResolver resolver);

  /** @domName XPathEvaluator.createNSResolver */
  XPathNSResolver createNSResolver(Node nodeResolver);

  /** @domName XPathEvaluator.evaluate */
  XPathResult evaluate(String expression, Node contextNode, XPathNSResolver resolver, int type, XPathResult inResult);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XPathException
interface XPathException {

  static final int INVALID_EXPRESSION_ERR = 51;

  static final int TYPE_ERR = 52;

  /** @domName XPathException.code */
  final int code;

  /** @domName XPathException.message */
  final String message;

  /** @domName XPathException.name */
  final String name;

  /** @domName XPathException.toString */
  String toString();
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XPathExpression
interface XPathExpression {

  /** @domName XPathExpression.evaluate */
  XPathResult evaluate(Node contextNode, int type, XPathResult inResult);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XPathNSResolver
interface XPathNSResolver {

  /** @domName XPathNSResolver.lookupNamespaceURI */
  String lookupNamespaceURI(String prefix);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XPathResult
interface XPathResult {

  static final int ANY_TYPE = 0;

  static final int ANY_UNORDERED_NODE_TYPE = 8;

  static final int BOOLEAN_TYPE = 3;

  static final int FIRST_ORDERED_NODE_TYPE = 9;

  static final int NUMBER_TYPE = 1;

  static final int ORDERED_NODE_ITERATOR_TYPE = 5;

  static final int ORDERED_NODE_SNAPSHOT_TYPE = 7;

  static final int STRING_TYPE = 2;

  static final int UNORDERED_NODE_ITERATOR_TYPE = 4;

  static final int UNORDERED_NODE_SNAPSHOT_TYPE = 6;

  /** @domName XPathResult.booleanValue */
  final bool booleanValue;

  /** @domName XPathResult.invalidIteratorState */
  final bool invalidIteratorState;

  /** @domName XPathResult.numberValue */
  final num numberValue;

  /** @domName XPathResult.resultType */
  final int resultType;

  /** @domName XPathResult.singleNodeValue */
  final Node singleNodeValue;

  /** @domName XPathResult.snapshotLength */
  final int snapshotLength;

  /** @domName XPathResult.stringValue */
  final String stringValue;

  /** @domName XPathResult.iterateNext */
  Node iterateNext();

  /** @domName XPathResult.snapshotItem */
  Node snapshotItem(int index);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// WARNING: Do not edit - generated code.

/// @domName XSLTProcessor
interface XSLTProcessor default _XSLTProcessorFactoryProvider {

  XSLTProcessor();

  /** @domName XSLTProcessor.clearParameters */
  void clearParameters();

  /** @domName XSLTProcessor.getParameter */
  String getParameter(String namespaceURI, String localName);

  /** @domName XSLTProcessor.importStylesheet */
  void importStylesheet(Node stylesheet);

  /** @domName XSLTProcessor.removeParameter */
  void removeParameter(String namespaceURI, String localName);

  /** @domName XSLTProcessor.reset */
  void reset();

  /** @domName XSLTProcessor.setParameter */
  void setParameter(String namespaceURI, String localName, String value);

  /** @domName XSLTProcessor.transformToDocument */
  Document transformToDocument(Node source);

  /** @domName XSLTProcessor.transformToFragment */
  DocumentFragment transformToFragment(Node source, Document docVal);
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

typedef void EventListener(Event event);
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Defines the standard key locations returned by
 * KeyboardEvent.getKeyLocation.
 */
interface KeyLocation {

  /**
   * The event key is not distinguished as the left or right version
   * of the key, and did not originate from the numeric keypad (or did not
   * originate with a virtual key corresponding to the numeric keypad).
   */
  static final int STANDARD = 0;

  /**
   * The event key is in the left key location.
   */
  static final int LEFT = 1;

  /**
   * The event key is in the right key location.
   */
  static final int RIGHT = 2;

  /**
   * The event key originated on the numeric keypad or with a virtual key
   * corresponding to the numeric keypad.
   */
  static final int NUMPAD = 3;

  /**
   * The event key originated on a mobile device, either on a physical
   * keypad or a virtual keyboard.
   */
  static final int MOBILE = 4;

  /**
   * The event key originated on a game controller or a joystick on a mobile
   * device.
   */
  static final int JOYSTICK = 5;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Defines the standard keyboard identifier names for keys that are returned
 * by KeyEvent.getKeyboardIdentifier when the key does not have a direct
 * unicode mapping.
 */
interface KeyName {

  /** The Accept (Commit, OK) key */
  static final String ACCEPT = "Accept";

  /** The Add key */
  static final String ADD = "Add";

  /** The Again key */
  static final String AGAIN = "Again";

  /** The All Candidates key */
  static final String ALL_CANDIDATES = "AllCandidates";

  /** The Alphanumeric key */
  static final String ALPHANUMERIC = "Alphanumeric";

  /** The Alt (Menu) key */
  static final String ALT = "Alt";

  /** The Alt-Graph key */
  static final String ALT_GRAPH = "AltGraph";

  /** The Application key */
  static final String APPS = "Apps";

  /** The ATTN key */
  static final String ATTN = "Attn";

  /** The Browser Back key */
  static final String BROWSER_BACK = "BrowserBack";

  /** The Browser Favorites key */
  static final String BROWSER_FAVORTIES = "BrowserFavorites";

  /** The Browser Forward key */
  static final String BROWSER_FORWARD = "BrowserForward";

  /** The Browser Home key */
  static final String BROWSER_NAME = "BrowserHome";

  /** The Browser Refresh key */
  static final String BROWSER_REFRESH = "BrowserRefresh";

  /** The Browser Search key */
  static final String BROWSER_SEARCH = "BrowserSearch";

  /** The Browser Stop key */
  static final String BROWSER_STOP = "BrowserStop";

  /** The Camera key */
  static final String CAMERA = "Camera";

  /** The Caps Lock (Capital) key */
  static final String CAPS_LOCK = "CapsLock";

  /** The Clear key */
  static final String CLEAR = "Clear";

  /** The Code Input key */
  static final String CODE_INPUT = "CodeInput";

  /** The Compose key */
  static final String COMPOSE = "Compose";

  /** The Control (Ctrl) key */
  static final String CONTROL = "Control";

  /** The Crsel key */
  static final String CRSEL = "Crsel";

  /** The Convert key */
  static final String CONVERT = "Convert";

  /** The Copy key */
  static final String COPY = "Copy";

  /** The Cut key */
  static final String CUT = "Cut";

  /** The Decimal key */
  static final String DECIMAL = "Decimal";

  /** The Divide key */
  static final String DIVIDE = "Divide";

  /** The Down Arrow key */
  static final String DOWN = "Down";

  /** The diagonal Down-Left Arrow key */
  static final String DOWN_LEFT = "DownLeft";

  /** The diagonal Down-Right Arrow key */
  static final String DOWN_RIGHT = "DownRight";

  /** The Eject key */
  static final String EJECT = "Eject";

  /** The End key */
  static final String END = "End";

  /**
   * The Enter key. Note: This key value must also be used for the Return
   *  (Macintosh numpad) key
   */
  static final String ENTER = "Enter";

  /** The Erase EOF key */
  static final String ERASE_EOF= "EraseEof";

  /** The Execute key */
  static final String EXECUTE = "Execute";

  /** The Exsel key */
  static final String EXSEL = "Exsel";

  /** The Function switch key */
  static final String FN = "Fn";

  /** The F1 key */
  static final String F1 = "F1";

  /** The F2 key */
  static final String F2 = "F2";

  /** The F3 key */
  static final String F3 = "F3";

  /** The F4 key */
  static final String F4 = "F4";

  /** The F5 key */
  static final String F5 = "F5";

  /** The F6 key */
  static final String F6 = "F6";

  /** The F7 key */
  static final String F7 = "F7";

  /** The F8 key */
  static final String F8 = "F8";

  /** The F9 key */
  static final String F9 = "F9";

  /** The F10 key */
  static final String F10 = "F10";

  /** The F11 key */
  static final String F11 = "F11";

  /** The F12 key */
  static final String F12 = "F12";

  /** The F13 key */
  static final String F13 = "F13";

  /** The F14 key */
  static final String F14 = "F14";

  /** The F15 key */
  static final String F15 = "F15";

  /** The F16 key */
  static final String F16 = "F16";

  /** The F17 key */
  static final String F17 = "F17";

  /** The F18 key */
  static final String F18 = "F18";

  /** The F19 key */
  static final String F19 = "F19";

  /** The F20 key */
  static final String F20 = "F20";

  /** The F21 key */
  static final String F21 = "F21";

  /** The F22 key */
  static final String F22 = "F22";

  /** The F23 key */
  static final String F23 = "F23";

  /** The F24 key */
  static final String F24 = "F24";

  /** The Final Mode (Final) key used on some asian keyboards */
  static final String FINAL_MODE = "FinalMode";

  /** The Find key */
  static final String FIND = "Find";

  /** The Full-Width Characters key */
  static final String FULL_WIDTH = "FullWidth";

  /** The Half-Width Characters key */
  static final String HALF_WIDTH = "HalfWidth";

  /** The Hangul (Korean characters) Mode key */
  static final String HANGUL_MODE = "HangulMode";

  /** The Hanja (Korean characters) Mode key */
  static final String HANJA_MODE = "HanjaMode";

  /** The Help key */
  static final String HELP = "Help";

  /** The Hiragana (Japanese Kana characters) key */
  static final String HIRAGANA = "Hiragana";

  /** The Home key */
  static final String HOME = "Home";

  /** The Insert (Ins) key */
  static final String INSERT = "Insert";

  /** The Japanese-Hiragana key */
  static final String JAPANESE_HIRAGANA = "JapaneseHiragana";

  /** The Japanese-Katakana key */
  static final String JAPANESE_KATAKANA = "JapaneseKatakana";

  /** The Japanese-Romaji key */
  static final String JAPANESE_ROMAJI = "JapaneseRomaji";

  /** The Junja Mode key */
  static final String JUNJA_MODE = "JunjaMode";

  /** The Kana Mode (Kana Lock) key */
  static final String KANA_MODE = "KanaMode";

  /**
   * The Kanji (Japanese name for ideographic characters of Chinese origin)
   * Mode key
   */
  static final String KANJI_MODE = "KanjiMode";

  /** The Katakana (Japanese Kana characters) key */
  static final String KATAKANA = "Katakana";

  /** The Start Application One key */
  static final String LAUNCH_APPLICATION_1 = "LaunchApplication1";

  /** The Start Application Two key */
  static final String LAUNCH_APPLICATION_2 = "LaunchApplication2";

  /** The Start Mail key */
  static final String LAUNCH_MAIL = "LaunchMail";

  /** The Left Arrow key */
  static final String LEFT = "Left";

  /** The Menu key */
  static final String MENU = "Menu";

  /**
   * The Meta key. Note: This key value shall be also used for the Apple
   * Command key
   */
  static final String META = "Meta";

  /** The Media Next Track key */
  static final String MEDIA_NEXT_TRACK = "MediaNextTrack";

  /** The Media Play Pause key */
  static final String MEDIA_PAUSE_PLAY = "MediaPlayPause";

  /** The Media Previous Track key */
  static final String MEDIA_PREVIOUS_TRACK = "MediaPreviousTrack";

  /** The Media Stop key */
  static final String MEDIA_STOP = "MediaStop";

  /** The Mode Change key */
  static final String MODE_CHANGE = "ModeChange";

  /** The Next Candidate function key */
  static final String NEXT_CANDIDATE = "NextCandidate";

  /** The Nonconvert (Don't Convert) key */
  static final String NON_CONVERT = "Nonconvert";

  /** The Number Lock key */
  static final String NUM_LOCK = "NumLock";

  /** The Page Down (Next) key */
  static final String PAGE_DOWN = "PageDown";

  /** The Page Up key */
  static final String PAGE_UP = "PageUp";

  /** The Paste key */
  static final String PASTE = "Paste";

  /** The Pause key */
  static final String PAUSE = "Pause";

  /** The Play key */
  static final String PLAY = "Play";

  /**
   * The Power key. Note: Some devices may not expose this key to the
   * operating environment
   */
  static final String POWER = "Power";

  /** The Previous Candidate function key */
  static final String PREVIOUS_CANDIDATE = "PreviousCandidate";

  /** The Print Screen (PrintScrn, SnapShot) key */
  static final String PRINT_SCREEN = "PrintScreen";

  /** The Process key */
  static final String PROCESS = "Process";

  /** The Props key */
  static final String PROPS = "Props";

  /** The Right Arrow key */
  static final String RIGHT = "Right";

  /** The Roman Characters function key */
  static final String ROMAN_CHARACTERS = "RomanCharacters";

  /** The Scroll Lock key */
  static final String SCROLL = "Scroll";

  /** The Select key */
  static final String SELECT = "Select";

  /** The Select Media key */
  static final String SELECT_MEDIA = "SelectMedia";

  /** The Separator key */
  static final String SEPARATOR = "Separator";

  /** The Shift key */
  static final String SHIFT = "Shift";

  /** The Soft1 key */
  static final String SOFT_1 = "Soft1";

  /** The Soft2 key */
  static final String SOFT_2 = "Soft2";

  /** The Soft3 key */
  static final String SOFT_3 = "Soft3";

  /** The Soft4 key */
  static final String SOFT_4 = "Soft4";

  /** The Stop key */
  static final String STOP = "Stop";

  /** The Subtract key */
  static final String SUBTRACT = "Subtract";

  /** The Symbol Lock key */
  static final String SYMBOL_LOCK = "SymbolLock";

  /** The Up Arrow key */
  static final String UP = "Up";

  /** The diagonal Up-Left Arrow key */
  static final String UP_LEFT = "UpLeft";

  /** The diagonal Up-Right Arrow key */
  static final String UP_RIGHT = "UpRight";

  /** The Undo key */
  static final String UNDO = "Undo";

  /** The Volume Down key */
  static final String VOLUME_DOWN = "VolumeDown";

  /** The Volume Mute key */
  static final String VOLUMN_MUTE = "VolumeMute";

  /** The Volume Up key */
  static final String VOLUMN_UP = "VolumeUp";

  /** The Windows Logo key */
  static final String WIN = "Win";

  /** The Zoom key */
  static final String ZOOM = "Zoom";

  /**
   * The Backspace (Back) key. Note: This key value shall be also used for the
   * key labeled 'delete' MacOS keyboards when not modified by the 'Fn' key
   */
  static final String BACKSPACE = "Backspace";

  /** The Horizontal Tabulation (Tab) key */
  static final String TAB = "Tab";

  /** The Cancel key */
  static final String CANCEL = "Cancel";

  /** The Escape (Esc) key */
  static final String ESC = "Esc";

  /** The Space (Spacebar) key:   */
  static final String SPACEBAR = "Spacebar";

  /**
   * The Delete (Del) Key. Note: This key value shall be also used for the key
   * labeled 'delete' MacOS keyboards when modified by the 'Fn' key
   */
  static final String DEL = "Del";

  /** The Combining Grave Accent (Greek Varia, Dead Grave) key */
  static final String DEAD_GRAVE = "DeadGrave";

  /**
   * The Combining Acute Accent (Stress Mark, Greek Oxia, Tonos, Dead Eacute)
   * key
   */
  static final String DEAD_EACUTE = "DeadEacute";

  /** The Combining Circumflex Accent (Hat, Dead Circumflex) key */
  static final String DEAD_CIRCUMFLEX = "DeadCircumflex";

  /** The Combining Tilde (Dead Tilde) key */
  static final String DEAD_TILDE = "DeadTilde";

  /** The Combining Macron (Long, Dead Macron) key */
  static final String DEAD_MACRON = "DeadMacron";

  /** The Combining Breve (Short, Dead Breve) key */
  static final String DEAD_BREVE = "DeadBreve";

  /** The Combining Dot Above (Derivative, Dead Above Dot) key */
  static final String DEAD_ABOVE_DOT = "DeadAboveDot";

  /**
   * The Combining Diaeresis (Double Dot Abode, Umlaut, Greek Dialytika,
   * Double Derivative, Dead Diaeresis) key
   */
  static final String DEAD_UMLAUT = "DeadUmlaut";

  /** The Combining Ring Above (Dead Above Ring) key */
  static final String DEAD_ABOVE_RING = "DeadAboveRing";

  /** The Combining Double Acute Accent (Dead Doubleacute) key */
  static final String DEAD_DOUBLEACUTE = "DeadDoubleacute";

  /** The Combining Caron (Hacek, V Above, Dead Caron) key */
  static final String DEAD_CARON = "DeadCaron";

  /** The Combining Cedilla (Dead Cedilla) key */
  static final String DEAD_CEDILLA = "DeadCedilla";

  /** The Combining Ogonek (Nasal Hook, Dead Ogonek) key */
  static final String DEAD_OGONEK = "DeadOgonek";

  /**
   * The Combining Greek Ypogegrammeni (Greek Non-Spacing Iota Below, Iota
   * Subscript, Dead Iota) key
   */
  static final String DEAD_IOTA = "DeadIota";

  /**
   * The Combining Katakana-Hiragana Voiced Sound Mark (Dead Voiced Sound) key
   */
  static final String DEAD_VOICED_SOUND = "DeadVoicedSound";

  /**
   * The Combining Katakana-Hiragana Semi-Voiced Sound Mark (Dead Semivoiced
   * Sound) key
   */
  static final String DEC_SEMIVOICED_SOUND= "DeadSemivoicedSound";

  /**
   * Key value used when an implementation is unable to identify another key
   * value, due to either hardware, platform, or software constraints
   */
  static final String UNIDENTIFIED = "Unidentified";
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Contains the set of standard values returned by HTMLDocument.getReadyState.
 */
interface ReadyState {
  /**
   * Indicates the document is still loading and parsing.
   */
  static final String LOADING = "loading";

  /**
   * Indicates the document is finished parsing but is still loading
   * subresources.
   */
  static final String INTERACTIVE = "interactive";

  /**
   * Indicates the document and all subresources have been loaded.
   */
  static final String COMPLETE = "complete";
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * The [Collections] class implements static methods useful when
 * writing a class that implements [Collection] and the [iterator]
 * method.
 */
class _Collections {
  static void forEach(Iterable<Object> iterable, void f(Object o)) {
    for (final e in iterable) {
      f(e);
    }
  }

  static List map(Iterable<Object> source,
                  List<Object> destination,
                  f(o)) {
    for (final e in source) {
      destination.add(f(e));
    }
    return destination;
  }

  static bool some(Iterable<Object> iterable, bool f(Object o)) {
    for (final e in iterable) {
      if (f(e)) return true;
    }
    return false;
  }

  static bool every(Iterable<Object> iterable, bool f(Object o)) {
    for (final e in iterable) {
      if (!f(e)) return false;
    }
    return true;
  }

  static List filter(Iterable<Object> source,
                     List<Object> destination,
                     bool f(o)) {
    for (final e in source) {
      if (f(e)) destination.add(e);
    }
    return destination;
  }

  static bool isEmpty(Iterable<Object> iterable) {
    return !iterable.iterator().hasNext();
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _XMLHttpRequestUtils {

  // Helper for factory XMLHttpRequest.get
  static XMLHttpRequest get(String url,
                            onSuccess(XMLHttpRequest request)) {
    final request = new XMLHttpRequest();
    request.open('GET', url, true);

    // TODO(terry): Validate after client login added if necessary to forward
    //              cookies to server.
    request.withCredentials = true;

    // Status 0 is for local XHR request.
    request.on.readyStateChange.add((e) {
      if (request.readyState == XMLHttpRequest.DONE &&
          (request.status == 200 || request.status == 0)) {
        onSuccess(request);
      }
    });

    request.send();

    return request;
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _EventFactoryProvider {
  factory Event(String type, [bool canBubble = true,
      bool cancelable = true]) {
    final _EventImpl e = _document.$dom_createEvent("Event");
    e.$dom_initEvent(type, canBubble, cancelable);
    return e;
  }
}

class _MouseEventFactoryProvider {
  factory MouseEvent(String type, Window view, int detail,
      int screenX, int screenY, int clientX, int clientY, int button,
      [bool canBubble = true, bool cancelable = true, bool ctrlKey = false,
      bool altKey = false, bool shiftKey = false, bool metaKey = false,
      EventTarget relatedTarget = null]) {
    final e = _document.$dom_createEvent("MouseEvent");
    e.$dom_initMouseEvent(type, canBubble, cancelable, view, detail,
        screenX, screenY, clientX, clientY, ctrlKey, altKey, shiftKey, metaKey,
        button, relatedTarget);
    return e;
  }
}

class _CSSStyleDeclarationFactoryProvider {
  factory CSSStyleDeclaration.css(String css) {
    final style = new Element.tag('div').style;
    style.cssText = css;
    return style;
  } 

  factory CSSStyleDeclaration() {
    return new CSSStyleDeclaration.css('');
  }
}

class _DocumentFragmentFactoryProvider {
  /** @domName Document.createDocumentFragment */
  factory DocumentFragment() => document.createDocumentFragment();

  factory DocumentFragment.html(String html) {
    final fragment = new DocumentFragment();
    fragment.innerHTML = html;
    return fragment;
  }

  // TODO(nweiz): enable this when XML is ported.
  // factory DocumentFragment.xml(String xml) {
  //   final fragment = new DocumentFragment();
  //   final e = new XMLElement.tag("xml");
  //   e.innerHTML = xml;
  //
  //   // Copy list first since we don't want liveness during iteration.
  //   final List nodes = new List.from(e.nodes);
  //   fragment.nodes.addAll(nodes);
  //   return fragment;
  // }

  factory DocumentFragment.svg(String svg) {
    final fragment = new DocumentFragment();
    final e = new SVGSVGElement();
    e.innerHTML = svg;

    // Copy list first since we don't want liveness during iteration.
    final List nodes = new List.from(e.nodes);
    fragment.nodes.addAll(nodes);
    return fragment;
  }
}

class _SVGElementFactoryProvider {
  factory SVGElement.tag(String tag) {
    final Element temp =
      _document.$dom_createElementNS("http://www.w3.org/2000/svg", tag);
    return temp;
  }

  factory SVGElement.svg(String svg) {
    Element parentTag;
    final match = _START_TAG_REGEXP.firstMatch(svg);
    if (match != null && match.group(1).toLowerCase() == 'svg') {
      parentTag = new Element.tag('div');
    } else {
      parentTag = new SVGSVGElement();
    }

    parentTag.innerHTML = svg;
    if (parentTag.elements.length == 1) return parentTag.nodes.removeLast();

    throw new IllegalArgumentException('SVG had ${parentTag.elements.length} ' +
        'top-level elements but 1 expected');
  }
}

class _SVGSVGElementFactoryProvider {
  factory SVGSVGElement() {
    final el = new SVGElement.tag("svg");
    // The SVG spec requires the version attribute to match the spec version
    el.attributes['version'] = "1.1";
    return el;
  }
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _AudioContextFactoryProvider {
  factory AudioContext() => _wrap(new dom.AudioContext());
}

class _IDBKeyRangeFactoryProvider {

  factory IDBKeyRange.only(/*IDBKey*/ value) =>
      _wrap(new dom.IDBKeyRange.only(_unwrap(value)));

  factory IDBKeyRange.lowerBound(/*IDBKey*/ bound, [bool open = false]) =>
      _wrap(new dom.IDBKeyRange.lowerBound(_unwrap(bound), open));

  factory IDBKeyRange.upperBound(/*IDBKey*/ bound, [bool open = false]) =>
      _wrap(new dom.IDBKeyRange.upperBound(_unwrap(bound), open));

  factory IDBKeyRange.bound(/*IDBKey*/ lower, /*IDBKey*/ upper,
                            [bool lowerOpen = false, bool upperOpen = false]) =>
      _wrap(new dom.IDBKeyRange.bound(_unwrap(lower), _unwrap(upper),
                                      lowerOpen, upperOpen));
}

class _TypedArrayFactoryProvider {

  factory Float32Array(int length) => _F32(length);
  factory Float32Array.fromList(List<num> list) => _F32_1(ensureNative(list));
  factory Float32Array.fromBuffer(ArrayBuffer buffer,
                                  [int byteOffset = 0, int length]) {
    if (length == null) return _F32_2(buffer, byteOffset);
    return _F32_3(buffer, byteOffset, length);
  }

  factory Float64Array(int length) => _F64(length);
  factory Float64Array.fromList(List<num> list) => _F64_1(ensureNative(list));
  factory Float64Array.fromBuffer(ArrayBuffer buffer,
                                  [int byteOffset = 0, int length]) {
    if (length == null) return _F64_2(buffer, byteOffset);
    return _F64_3(buffer, byteOffset, length);
  }

  factory Int8Array(int length) => _I8(length);
  factory Int8Array.fromList(List<num> list) => _I8_1(ensureNative(list));
  factory Int8Array.fromBuffer(ArrayBuffer buffer,
                               [int byteOffset = 0, int length]) {
    if (length == null) return _I8_2(buffer, byteOffset);
    return _I8_3(buffer, byteOffset, length);
  }

  factory Int16Array(int length) => _I16(length);
  factory Int16Array.fromList(List<num> list) => _I16_1(ensureNative(list));
  factory Int16Array.fromBuffer(ArrayBuffer buffer,
                                [int byteOffset = 0, int length]) {
    if (length == null) return _I16_2(buffer, byteOffset);
    return _I16_3(buffer, byteOffset, length);
  }

  factory Int32Array(int length) => _I32(length);
  factory Int32Array.fromList(List<num> list) => _I32_1(ensureNative(list));
  factory Int32Array.fromBuffer(ArrayBuffer buffer,
                                [int byteOffset = 0, int length]) {
    if (length == null) return _I32_2(buffer, byteOffset);
    return _I32_3(buffer, byteOffset, length);
  }

  factory Uint8Array(int length) => _U8(length);
  factory Uint8Array.fromList(List<num> list) => _U8_1(ensureNative(list));
  factory Uint8Array.fromBuffer(ArrayBuffer buffer,
                                [int byteOffset = 0, int length]) {
    if (length == null) return _U8_2(buffer, byteOffset);
    return _U8_3(buffer, byteOffset, length);
  }

  factory Uint16Array(int length) => _U16(length);
  factory Uint16Array.fromList(List<num> list) => _U16_1(ensureNative(list));
  factory Uint16Array.fromBuffer(ArrayBuffer buffer,
                                 [int byteOffset = 0, int length]) {
    if (length == null) return _U16_2(buffer, byteOffset);
    return _U16_3(buffer, byteOffset, length);
  }

  factory Uint32Array(int length) => _U32(length);
  factory Uint32Array.fromList(List<num> list) => _U32_1(ensureNative(list));
  factory Uint32Array.fromBuffer(ArrayBuffer buffer,
                                 [int byteOffset = 0, int length]) {
    if (length == null) return _U32_2(buffer, byteOffset);
    return _U32_3(buffer, byteOffset, length);
  }

  factory Uint8ClampedArray(int length) => _U8C(length);
  factory Uint8ClampedArray.fromList(List<num> list) => _U8C_1(ensureNative(list));
  factory Uint8ClampedArray.fromBuffer(ArrayBuffer buffer,
                                       [int byteOffset = 0, int length]) {
    if (length == null) return _U8C_2(buffer, byteOffset);
    return _U8C_3(buffer, byteOffset, length);
  }

  static Float32Array _F32(arg) => _wrap(new dom.Float32Array(arg));
  static Float64Array _F64(arg) => _wrap(new dom.Float64Array(arg));
  static Int8Array _I8(arg) => _wrap(new dom.Int8Array(arg));
  static Int16Array _I16(arg) => _wrap(new dom.Int16Array(arg));
  static Int32Array _I32(arg) => _wrap(new dom.Int32Array(arg));
  static Uint8Array _U8(arg) => _wrap(new dom.Uint8Array(arg));
  static Uint16Array _U16(arg) => _wrap(new dom.Uint16Array(arg));
  static Uint32Array _U32(arg) => _wrap(new dom.Uint32Array(arg));
  static Uint8ClampedArray _U8C(arg) => _wrap(new dom.Uint8ClampedArray(arg));

  static Float32Array _F32_1(arg) => _wrap(new dom.Float32Array.fromList(arg));
  static Float64Array _F64_1(arg) => _wrap(new dom.Float64Array.fromList(arg));
  static Int8Array _I8_1(arg) => _wrap(new dom.Int8Array.fromList(arg));
  static Int16Array _I16_1(arg) => _wrap(new dom.Int16Array.fromList(arg));
  static Int32Array _I32_1(arg) => _wrap(new dom.Int32Array.fromList(arg));
  static Uint8Array _U8_1(arg) => _wrap(new dom.Uint8Array.fromList(arg));
  static Uint16Array _U16_1(arg) => _wrap(new dom.Uint16Array.fromList(arg));
  static Uint32Array _U32_1(arg) => _wrap(new dom.Uint32Array.fromList(arg));
  static Uint8ClampedArray _U8C_1(arg) => _wrap(new dom.Uint8ClampedArray.fromList(arg));

  static Float32Array _F32_2(buffer, byteOffset) => _wrap(new dom.Float32Array.fromBuffer(_unwrap(buffer), byteOffset));
  static Float64Array _F64_2(buffer, byteOffset) => _wrap(new dom.Float64Array.fromBuffer(_unwrap(buffer), byteOffset));
  static Int8Array _I8_2(buffer, byteOffset) => _wrap(new dom.Int8Array.fromBuffer(_unwrap(buffer), byteOffset));
  static Int16Array _I16_2(buffer, byteOffset) => _wrap(new dom.Int16Array.fromBuffer(_unwrap(buffer), byteOffset));
  static Int32Array _I32_2(buffer, byteOffset) => _wrap(new dom.Int32Array.fromBuffer(_unwrap(buffer), byteOffset));
  static Uint8Array _U8_2(buffer, byteOffset) => _wrap(new dom.Uint8Array.fromBuffer(_unwrap(buffer), byteOffset));
  static Uint16Array _U16_2(buffer, byteOffset) => _wrap(new dom.Uint16Array.fromBuffer(_unwrap(buffer), byteOffset));
  static Uint32Array _U32_2(buffer, byteOffset) => _wrap(new dom.Uint32Array.fromBuffer(_unwrap(buffer), byteOffset));
  static Uint8ClampedArray _U8C_2(buffer, byteOffset) => _wrap(new dom.Uint8ClampedArray.fromBuffer(_unwrap(buffer), byteOffset));

  static Float32Array _F32_3(buffer, byteOffset, length) => _wrap(new dom.Float32Array.fromBuffer(_unwrap(buffer), byteOffset, length));
  static Float64Array _F64_3(buffer, byteOffset, length) => _wrap(new dom.Float64Array.fromBuffer(_unwrap(buffer), byteOffset, length));
  static Int8Array _I8_3(buffer, byteOffset, length) => _wrap(new dom.Int8Array.fromBuffer(_unwrap(buffer), byteOffset, length));
  static Int16Array _I16_3(buffer, byteOffset, length) => _wrap(new dom.Int16Array.fromBuffer(_unwrap(buffer), byteOffset, length));
  static Int32Array _I32_3(buffer, byteOffset, length) => _wrap(new dom.Int32Array.fromBuffer(_unwrap(buffer), byteOffset, length));
  static Uint8Array _U8_3(buffer, byteOffset, length) => _wrap(new dom.Uint8Array.fromBuffer(_unwrap(buffer), byteOffset, length));
  static Uint16Array _U16_3(buffer, byteOffset, length) => _wrap(new dom.Uint16Array.fromBuffer(_unwrap(buffer), byteOffset, length));
  static Uint32Array _U32_3(buffer, byteOffset, length) => _wrap(new dom.Uint32Array.fromBuffer(_unwrap(buffer), byteOffset, length));
  static Uint8ClampedArray _U8C_3(buffer, byteOffset, length) => _wrap(new dom.Uint8ClampedArray.fromBuffer(_unwrap(buffer), byteOffset, length));

  static ensureNative(List list) => list;  // TODO: make sure.
}

class _PointFactoryProvider {

  factory Point(num x, num y) => _wrap(new dom.WebKitPoint(x, y));
}

class _WebSocketFactoryProvider {

  factory WebSocket(String url) => _wrap(new dom.WebSocket(url));
}

class _TextFactoryProvider {
  factory Text(String data) => _document.$dom_createTextNode(data);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

typedef Object ComputeValue();

class _MeasurementRequest<T> {
  final ComputeValue computeValue;
  final Completer<T> completer;
  Object value;
  bool exception = false;
  _MeasurementRequest(this.computeValue, this.completer);
}

final _MEASUREMENT_MESSAGE = "DART-MEASURE";
List<_MeasurementRequest> _pendingRequests;
List<TimeoutHandler> _pendingMeasurementFrameCallbacks;
bool _nextMeasurementFrameScheduled = false;
bool _firstMeasurementRequest = true;

void _maybeScheduleMeasurementFrame() {
  if (_nextMeasurementFrameScheduled) return;

  _nextMeasurementFrameScheduled = true;
  // postMessage gives us a way to receive a callback after the current
  // event listener has unwound but before the browser has repainted.
  if (_firstMeasurementRequest) {
    // Messages from other windows do not cause a security risk as
    // all we care about is that _onCompleteMeasurementRequests is called
    // after the current event loop is unwound and calling the function is
    // a noop when zero requests are pending.
    window.on.message.add((e) => _completeMeasurementFutures());
    _firstMeasurementRequest = false;
  }

  // TODO(jacobr): other mechanisms such as setImmediate and
  // requestAnimationFrame may work better of platforms that support them.
  // The key is we need a way to execute code immediately after the current
  // event listener queue unwinds.
  window.postMessage(_MEASUREMENT_MESSAGE, "*");
}

/**
 * Registers a [callback] which is called after the next batch of measurements
 * completes. Even if no measurements completed, the callback is triggered
 * when they would have completed to avoid confusing bugs if it happened that
 * no measurements were actually requested.
 */
void _addMeasurementFrameCallback(TimeoutHandler callback) {
  if (_pendingMeasurementFrameCallbacks === null) {
    _pendingMeasurementFrameCallbacks = <TimeoutHandler>[];
    _maybeScheduleMeasurementFrame();
  }
  _pendingMeasurementFrameCallbacks.add(callback);
}

/**
 * Returns a [Future] whose value will be the result of evaluating
 * [computeValue] during the next safe measurement interval.
 * The next safe measurement interval is after the current event loop has
 * unwound but before the browser has rendered the page.
 * It is important that the [computeValue] function only queries the html
 * layout and html in any way.
 */
Future _createMeasurementFuture(ComputeValue computeValue,
                                Completer completer) {
  if (_pendingRequests === null) {
    _pendingRequests = <_MeasurementRequest>[];
    _maybeScheduleMeasurementFrame();
  }
  _pendingRequests.add(new _MeasurementRequest(computeValue, completer));
  return completer.future;
}

/**
 * Complete all pending measurement futures evaluating them in a single batch
 * so that the the browser is guaranteed to avoid multiple layouts.
 */
void _completeMeasurementFutures() {
  if (_nextMeasurementFrameScheduled == false) {
    // Ignore spurious call to this function.
    return;
  }

  _nextMeasurementFrameScheduled = false;
  // We must compute all new values before fulfilling the futures as
  // the onComplete callbacks for the futures could modify the DOM making
  // subsequent measurement calculations expensive to compute.
  if (_pendingRequests !== null) {
    for (_MeasurementRequest request in _pendingRequests) {
      try {
        request.value = request.computeValue();
      } catch(var e) {
        request.value = e;
        request.exception = true;
      }
    }
  }

  final completedRequests = _pendingRequests;
  final readyMeasurementFrameCallbacks = _pendingMeasurementFrameCallbacks;
  _pendingRequests = null;
  _pendingMeasurementFrameCallbacks = null;
  if (completedRequests !== null) {
    for (_MeasurementRequest request in completedRequests) {
      if (request.exception) {
        request.completer.completeException(request.value);
      } else {
        request.completer.complete(request.value);
      }
    }
  }

  if (readyMeasurementFrameCallbacks !== null) {
    for (TimeoutHandler handler in readyMeasurementFrameCallbacks) {
      // TODO(jacobr): wrap each call to a handler in a try-catch block.
      handler();
    }
  }
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

/**
 * Utils for device detection.
 */
class _Device {
  /**
   * Gets the browser's user agent. Using this function allows tests to inject
   * the user agent.
   * Returns the user agent.
   */
  static String get userAgent() => window.navigator.userAgent;

  /**
   * Determines if the current device is running Firefox.
   */
  static bool get isFirefox() => userAgent.contains("Firefox", 0);
}
// Copyright (c) 2012, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// TODO(rnystrom): add a way to supress public classes from DartDoc output.
// TODO(jacobr): we can remove this class now that we are using the $dom_
// convention for deprecated methods rather than truly private methods.
/**
 * This class is intended for testing purposes only.
 */
class Testing {
  static void addEventListener(EventTarget target, String type, EventListener listener, bool useCapture) {
    final _EventTargetImpl targetImpl = target;
    targetImpl.$dom_addEventListener(type, listener, useCapture);
  }
  static void removeEventListener(EventTarget target, String type, EventListener listener, bool useCapture) {
    final _EventTargetImpl targetImpl = target;
    targetImpl.$dom_removeEventListener(type, listener, useCapture);
  }

}// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _DOMTypeBase {
  final _ptr;

  _DOMTypeBase._wrap(this._ptr) {
  	// We should never be creating duplicate wrappers.
  	// TODO(jacobr): this boolean value is evaluated outside of the assert
  	// to work around a mysterious and flaky bug in tip of trunk versions of
  	// chrome.
  	bool hasExistingWrapper = _ptr.dartObjectLocalStorage === null;
  	assert(hasExistingWrapper);
	  _ptr.dartObjectLocalStorage = this;
  }
}

/** This function is provided for unittest purposes only. */
unwrapDomObject(_DOMTypeBase wrapper) {
  return wrapper._ptr;
}// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Iterator for arrays with fixed size.
class _FixedSizeListIterator<T> extends _VariableSizeListIterator<T> {
  _FixedSizeListIterator(List<T> array)
      : super(array),
        _length = array.length;

  bool hasNext() => _length > _pos;

  final int _length;  // Cache array length for faster access.
}

// Iterator for arrays with variable size.
class _VariableSizeListIterator<T> implements Iterator<T> {
  _VariableSizeListIterator(List<T> array)
      : _array = array,
        _pos = 0;

  bool hasNext() => _array.length > _pos;

  T next() {
    if (!hasNext()) {
      throw const NoMoreElementsException();
    }
    return _array[_pos++];
  }

  final List<T> _array;
  int _pos;
}
// Copyright (c) 2011, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

class _Lists {

  /**
   * Returns the index in the array [a] of the given [element], starting
   * the search at index [startIndex] to [endIndex] (exclusive).
   * Returns -1 if [element] is not found.
   */
  static int indexOf(List a,
                     Object element,
                     int startIndex,
                     int endIndex) {
    if (startIndex >= a.length) {
      return -1;
    }
    if (startIndex < 0) {
      startIndex = 0;
    }
    for (int i = startIndex; i < endIndex; i++) {
      if (a[i] == element) {
        return i;
      }
    }
    return -1;
  }

  /**
   * Returns the last index in the array [a] of the given [element], starting
   * the search at index [startIndex] to 0.
   * Returns -1 if [element] is not found.
   */
  static int lastIndexOf(List a, Object element, int startIndex) {
    if (startIndex < 0) {
      return -1;
    }
    if (startIndex >= a.length) {
      startIndex = a.length - 1;
    }
    for (int i = startIndex; i >= 0; i--) {
      if (a[i] == element) {
        return i;
      }
    }
    return -1;
  }

  /**
   * Returns a sub list copy of this list, from [start] to
   * [:start + length:].
   * Returns an empty list if [length] is 0.
   * Throws an [IllegalArgumentException] if [length] is negative.
   * Throws an [IndexOutOfRangeException] if [start] or
   * [:start + length:] are out of range.
   */
  static List getRange(List a, int start, int length, List accumulator) {
    if (length < 0) throw new IllegalArgumentException('length');
    if (start < 0) throw new IndexOutOfRangeException(start);
    int end = start + length;
    if (end > a.length) throw new IndexOutOfRangeException(end);
    for (int i = start; i < end; i++) {
      accumulator.add(a[i]);
    }
    return accumulator;
  }
}
