# Copyright 2014 The Chromium Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//base/android/linker/config.gni")
import("//build/config/android/config.gni")
import("//build/config/android/internal_rules.gni")
import("//third_party/android_platform/config.gni")
import("//tools/grit/grit_rule.gni")

assert(is_android)

# Declare a jni target
#
# This target generates the native jni bindings for a set of .java files.
#
# See base/android/jni_generator/jni_generator.py for more info about the
# format of generating JNI bindings.
#
# Variables
#   sources: list of .java files to generate jni for
#   jni_package: subdirectory path for generated bindings
#
# Example
#   generate_jni("foo_jni") {
#     sources = [
#       "android/java/src/org/chromium/foo/Foo.java",
#       "android/java/src/org/chromium/foo/FooUtil.java",
#     ]
#     jni_package = "foo"
#   }
template("generate_jni") {
  set_sources_assignment_filter([])
  if (defined(invoker.testonly)) {
    testonly = invoker.testonly
  }

  assert(defined(invoker.sources))
  assert(defined(invoker.jni_package))
  jni_package = invoker.jni_package
  base_output_dir = "${target_gen_dir}/${target_name}"
  package_output_dir = "${base_output_dir}/${jni_package}"
  jni_output_dir = "${package_output_dir}/jni"

  jni_generator_include = "//base/android/jni_generator/jni_generator_helper.h"

  foreach_target_name = "${target_name}__jni_gen"
  action_foreach(foreach_target_name) {
    script = "//base/android/jni_generator/jni_generator.py"
    depfile = "$target_gen_dir/$target_name.{{source_name_part}}.d"
    sources = invoker.sources
    outputs = [
      depfile,
      "${jni_output_dir}/{{source_name_part}}_jni.h",
    ]

    args = [
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "--input_file={{source}}",
      "--optimize_generation=1",
      "--ptr_type=long",
      "--output_dir",
      rebase_path(jni_output_dir, root_build_dir),
      "--includes",
      rebase_path(jni_generator_include, jni_output_dir),
      "--native_exports_optional",
    ]
    if (defined(invoker.jni_generator_jarjar_file)) {
      args += [
        "--jarjar",
        rebase_path(jni_generator_jarjar_file, root_build_dir),
      ]
    }
  }

  config("jni_includes_${target_name}") {
    # TODO(cjhopman): #includes should probably all be relative to
    # base_output_dir. Remove that from this config once the includes are
    # updated.
    include_dirs = [
      base_output_dir,
      package_output_dir,
    ]
  }

  group(target_name) {
    deps = [
      ":$foreach_target_name",
    ]
    public_configs = [ ":jni_includes_${target_name}" ]

    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
    if (defined(invoker.public_deps)) {
      public_deps = invoker.public_deps
    }

    if (defined(invoker.visibility)) {
      visibility = invoker.visibility
    }
  }
}

# Declare a jni target for a prebuilt jar
#
# This target generates the native jni bindings for a set of classes in a .jar.
#
# See base/android/jni_generator/jni_generator.py for more info about the
# format of generating JNI bindings.
#
# Variables
#   classes: list of .class files in the jar to generate jni for. These should
#     include the full path to the .class file.
#   jni_package: subdirectory path for generated bindings
#   jar_file: the path to the .jar. If not provided, will default to the sdk's
#     android.jar
#
#   deps, public_deps: As normal
#
# Example
#   generate_jar_jni("foo_jni") {
#     classes = [
#       "android/view/Foo.class",
#     ]
#     jni_package = "foo"
#   }
template("generate_jar_jni") {
  set_sources_assignment_filter([])
  if (defined(invoker.testonly)) {
    testonly = invoker.testonly
  }

  assert(defined(invoker.classes))
  assert(defined(invoker.jni_package))

  if (defined(invoker.jar_file)) {
    jar_file = invoker.jar_file
  } else {
    jar_file = android_sdk_jar
  }

  jni_package = invoker.jni_package
  base_output_dir = "${root_gen_dir}/${target_name}/${jni_package}"
  jni_output_dir = "${base_output_dir}/jni"

  jni_generator_include = "//base/android/jni_generator/jni_generator_helper.h"

  # TODO(cjhopman): make jni_generator.py support generating jni for multiple
  # .class files from a .jar.
  jni_actions = []
  foreach(class, invoker.classes) {
    _classname_list = []
    _classname_list = process_file_template([ class ], "{{source_name_part}}")
    classname = _classname_list[0]
    jni_target_name = "${target_name}__jni_${classname}"
    jni_actions += [ ":$jni_target_name" ]
    action(jni_target_name) {
      # The sources aren't compiled so don't check their dependencies.
      check_includes = false
      depfile = "$target_gen_dir/$target_name.d"
      script = "//base/android/jni_generator/jni_generator.py"
      sources = [
        jar_file,
      ]
      outputs = [
        depfile,
        "${jni_output_dir}/${classname}_jni.h",
      ]

      args = [
        "--depfile",
        rebase_path(depfile, root_build_dir),
        "--jar_file",
        rebase_path(jar_file, root_build_dir),
        "--input_file",
        class,
        "--optimize_generation=1",
        "--ptr_type=long",
        "--output_dir",
        rebase_path(jni_output_dir, root_build_dir),
        "--includes",
        rebase_path(jni_generator_include, jni_output_dir),
        "--native_exports_optional",
      ]
    }
  }

  config("jni_includes_${target_name}") {
    include_dirs = [ base_output_dir ]
  }

  group(target_name) {
    deps = jni_actions
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
    if (defined(invoker.public_deps)) {
      public_deps = invoker.public_deps
    }
    public_configs = [ ":jni_includes_${target_name}" ]
  }
}

# Declare a target for c-preprocessor-generated java files
#
# NOTE: For generating Java conterparts to enums prefer using the java_cpp_enum
#       rule instead.
#
# This target generates java files using the host C pre-processor. Each file in
# sources will be compiled using the C pre-processor. If include_path is
# specified, it will be passed (with --I) to the pre-processor.
#
# This target will create a single .srcjar. Adding this target to an
# android_library target's srcjar_deps will make the generated java files be
# included in that library's final outputs.
#
# Variables
#   sources: list of files to be processed by the C pre-processor. For each
#     file in sources, there will be one .java file in the final .srcjar. For a
#     file named FooBar.template, a java file will be created with name
#     FooBar.java.
#   inputs: additional compile-time dependencies. Any files
#     `#include`-ed in the templates should be listed here.
#   package_name: this will be the subdirectory for each .java file in the
#     .srcjar.
#
# Example
#   java_cpp_template("foo_generated_enum") {
#     sources = [
#       "android/java/templates/Foo.template",
#     ]
#     inputs = [
#       "android/java/templates/native_foo_header.h",
#     ]
#
#     package_name = "org/chromium/base/library_loader"
#     include_path = "android/java/templates"
#   }
template("java_cpp_template") {
  set_sources_assignment_filter([])
  if (defined(invoker.testonly)) {
    testonly = invoker.testonly
  }

  assert(defined(invoker.sources))
  package_name = invoker.package_name + ""

  if (defined(invoker.include_path)) {
    include_path = invoker.include_path + ""
  } else {
    include_path = "//"
  }

  apply_gcc_target_name = "${target_name}__apply_gcc"
  zip_srcjar_target_name = "${target_name}__zip_srcjar"
  final_target_name = target_name

  action_foreach(apply_gcc_target_name) {
    visibility = [ ":$zip_srcjar_target_name" ]
    script = "//build/android/gyp/gcc_preprocess.py"
    if (defined(invoker.inputs)) {
      inputs = invoker.inputs + []
    }
    depfile = "${target_gen_dir}/${target_name}_{{source_name_part}}.d"

    sources = invoker.sources

    if (defined(invoker.deps)) {
      deps = invoker.deps
    }
    if (defined(invoker.public_deps)) {
      public_deps = invoker.public_deps
    }
    if (defined(invoker.data_deps)) {
      data_deps = invoker.data_deps
    }

    gen_dir =
        "${target_gen_dir}/${target_name}/java_cpp_template/${package_name}"
    gcc_template_output_pattern = "${gen_dir}/{{source_name_part}}.java"

    outputs = [
      depfile,
      gcc_template_output_pattern,
    ]

    args = [
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "--include-path",
      rebase_path(include_path, root_build_dir),
      "--output",
      rebase_path(gen_dir, root_build_dir) + "/{{source_name_part}}.java",
      "--template={{source}}",
    ]

    if (defined(invoker.defines)) {
      foreach(def, invoker.defines) {
        args += [
          "--defines",
          def,
        ]
      }
    }
  }

  apply_gcc_outputs = get_target_outputs(":$apply_gcc_target_name")
  base_gen_dir = get_label_info(":$apply_gcc_target_name", "target_gen_dir")

  srcjar_path = "${target_gen_dir}/${target_name}.srcjar"
  zip(zip_srcjar_target_name) {
    visibility = [ ":$final_target_name" ]
    inputs = apply_gcc_outputs
    output = srcjar_path
    base_dir = base_gen_dir
    deps = [
      ":$apply_gcc_target_name",
    ]
  }

  group(final_target_name) {
    if (defined(invoker.visibility)) {
      visibility = invoker.visibility
    }
    deps = [
      ":$zip_srcjar_target_name",
    ]
  }
}

# Declare a target for generating Java classes from C++ enums.
#
# This target generates Java files from C++ enums using a script.
#
# This target will create a single .srcjar. Adding this target to an
# android_library target's srcjar_deps will make the generated java files be
# included in that library's final outputs.
#
# Variables
#   sources: list of files to be processed by the script. For each annotated
#     enum contained in the sources files the script will generate a .java
#     file with the same name as the name of the enum.
#
#   outputs: list of outputs, relative to the output_dir. These paths are
#     verified at build time by the script. To get the list programatically run:
#       python build/android/gyp/java_cpp_enum.py \
#         --print_output_only . path/to/header/file.h
#
# Example
#   java_cpp_enum("foo_generated_enum") {
#     sources = [
#       "src/native_foo_header.h",
#     ]
#     outputs = [
#       "org/chromium/FooEnum.java",
#     ]
#   }
template("java_cpp_enum") {
  set_sources_assignment_filter([])
  if (defined(invoker.testonly)) {
    testonly = invoker.testonly
  }

  assert(defined(invoker.sources))
  assert(defined(invoker.outputs))

  generate_enum_target_name = "${target_name}__generate_enum"
  zip_srcjar_target_name = "${target_name}__zip_srcjar"
  final_target_name = target_name

  action(generate_enum_target_name) {
    visibility = [ ":$zip_srcjar_target_name" ]

    # The sources aren't compiled so don't check their dependencies.
    check_includes = false

    sources = invoker.sources
    script = "//build/android/gyp/java_cpp_enum.py"
    gen_dir = "${target_gen_dir}/${target_name}/enums"
    outputs =
        get_path_info(rebase_path(invoker.outputs, ".", gen_dir), "abspath")

    args = []
    foreach(output, rebase_path(outputs, root_build_dir)) {
      args += [
        "--assert_file",
        output,
      ]
    }
    args += [ rebase_path(gen_dir, root_build_dir) ]
    args += rebase_path(invoker.sources, root_build_dir)
  }

  generate_enum_outputs = get_target_outputs(":$generate_enum_target_name")
  base_gen_dir = get_label_info(":$generate_enum_target_name", "target_gen_dir")

  srcjar_path = "${target_gen_dir}/${target_name}.srcjar"
  zip(zip_srcjar_target_name) {
    visibility = [ ":$final_target_name" ]
    inputs = generate_enum_outputs
    output = srcjar_path
    base_dir = base_gen_dir
    deps = [
      ":$generate_enum_target_name",
    ]
  }

  group(final_target_name) {
    if (defined(invoker.visibility)) {
      visibility = invoker.visibility
    }
    deps = [
      ":$zip_srcjar_target_name",
    ]
  }
}

# Declare a target for processing Android resources as Jinja templates.
#
# This takes an Android resource directory where each resource is a Jinja
# template, processes each template, then packages the results in a zip file
# which can be consumed by an android resources, library, or apk target.
#
# If this target is included in the deps of an android resources/library/apk,
# the resources will be included with that target.
#
# Variables
#   resources: The list of resources files to process.
#   res_dir: The resource directory containing the resources.
#   variables: (Optional) A list of variables to make available to the template
#     processing environment, e.g. ["name=foo", "color=red"].
#
# Example
#   jinja_template_resources("chrome_shell_template_resources") {
#     res_dir = "shell/res_template"
#     resources = ["shell/res_template/xml/syncable.xml"]
#     variables = ["color=red"]
#   }
template("jinja_template_resources") {
  set_sources_assignment_filter([])
  if (defined(invoker.testonly)) {
    testonly = invoker.testonly
  }

  assert(defined(invoker.resources))
  assert(defined(invoker.res_dir))

  _base_path = "$target_gen_dir/$target_name"
  _resources_zip = _base_path + ".resources.zip"
  _build_config = _base_path + ".build_config"

  write_build_config("${target_name}__build_config") {
    build_config = _build_config
    resources_zip = _resources_zip
    type = "android_resources"
  }

  action("${target_name}__template") {
    sources = invoker.resources
    script = "//build/android/gyp/jinja_template.py"
    depfile = "$target_gen_dir/$target_name.d"

    outputs = [
      depfile,
      _resources_zip,
    ]

    rebased_resources = rebase_path(invoker.resources, root_build_dir)
    args = [
      "--inputs=${rebased_resources}",
      "--inputs-base-dir",
      rebase_path(invoker.res_dir, root_build_dir),
      "--outputs-zip",
      rebase_path(_resources_zip, root_build_dir),
      "--depfile",
      rebase_path(depfile, root_build_dir),
    ]
    if (defined(invoker.variables)) {
      variables = invoker.variables
      args += [ "--variables=${variables}" ]
    }
  }

  group(target_name) {
    deps = [
      ":${target_name}__build_config",
      ":${target_name}__template",
    ]
  }
}

# Creates a resources.zip with locale.pak files placed into appropriate
# resource configs (e.g. en-GB.pak -> res/raw-en/en_gb.pak). Also generates
# a locale_paks TypedArray so that resource files can be enumerated at runtime.
#
# If this target is included in the deps of an android resources/library/apk,
# the resources will be included with that target.
#
# Variables:
#   sources: List of .pak files. Names must be of the form "en.pak" or
#       "en-US.pak".
#   deps: (optional) List of dependencies that might be needed to generate
#       the .pak files.
#
# Example
#   locale_pak_resources("locale_paks") {
#     sources = [ "path/en-US.pak", "path/fr.pak", ... ]
#   }
template("locale_pak_resources") {
  set_sources_assignment_filter([])
  assert(defined(invoker.sources))

  _base_path = "$target_gen_dir/$target_name"
  _resources_zip = _base_path + ".resources.zip"
  _build_config = _base_path + ".build_config"

  write_build_config("${target_name}__build_config") {
    build_config = _build_config
    resources_zip = _resources_zip
    type = "android_resources"
  }

  action("${target_name}__create_resources_zip") {
    sources = invoker.sources
    script = "//build/android/gyp/locale_pak_resources.py"
    depfile = "$target_gen_dir/$target_name.d"

    outputs = [
      depfile,
      _resources_zip,
    ]

    _rebased_sources = rebase_path(invoker.sources, root_build_dir)
    args = [
      "--locale-paks=${_rebased_sources}",
      "--resources-zip",
      rebase_path(_resources_zip, root_build_dir),
      "--depfile",
      rebase_path(depfile, root_build_dir),
    ]

    if (defined(invoker.deps)) {
      deps = invoker.deps
    }
  }

  group(target_name) {
    deps = [
      ":${target_name}__build_config",
      ":${target_name}__create_resources_zip",
    ]
  }
}

# Declare an Android resources target
#
# This creates a resources zip file that will be used when building an Android
# library or apk and included into a final apk.
#
# To include these resources in a library/apk, this target should be listed in
# the library's deps. A library/apk will also include any resources used by its
# own dependencies.
#
# Variables
#   deps: Specifies the dependencies of this target. Any Android resources
#     listed in deps will be included by libraries/apks that depend on this
#     target.
#   resource_dirs: List of directories containing resources for this target.
#   android_manifest: AndroidManifest.xml for this target. Defaults to
#     //build/android/AndroidManifest.xml.
#   custom_package: java package for generated .java files.
#   v14_skip: If true, don't run v14 resource generator on this. Defaults to
#     false. (see build/android/gyp/generate_v14_compatible_resources.py)
#
#   shared_resources: If true make a resource package that can be loaded by a
#     different application at runtime to access the package's resources.
#

# Example
#   android_resources("foo_resources") {
#     deps = [":foo_strings_grd"]
#     resource_dirs = ["res"]
#     custom_package = "org.chromium.foo"
#   }
template("android_resources") {
  set_sources_assignment_filter([])
  if (defined(invoker.testonly)) {
    testonly = invoker.testonly
  }

  assert(defined(invoker.resource_dirs))
  assert(defined(invoker.android_manifest) || defined(invoker.custom_package))

  base_path = "$target_gen_dir/$target_name"
  zip_path = base_path + ".resources.zip"
  srcjar_path = base_path + ".srcjar"
  r_text_path = base_path + "_R.txt"
  build_config = base_path + ".build_config"

  build_config_target_name = "${target_name}__build_config"
  process_resources_target_name = "${target_name}__process_resources"
  final_target_name = target_name

  write_build_config(build_config_target_name) {
    visibility = [ ":$process_resources_target_name" ]

    type = "android_resources"
    resources_zip = zip_path
    srcjar = srcjar_path
    r_text = r_text_path
    if (defined(invoker.deps)) {
      deps = invoker.deps
    }
    if (defined(invoker.android_manifest)) {
      android_manifest = invoker.android_manifest
    }
    if (defined(invoker.custom_package)) {
      custom_package = invoker.custom_package
    }
  }

  android_manifest = "//build/android/AndroidManifest.xml"
  if (defined(invoker.android_manifest)) {
    android_manifest = invoker.android_manifest
  }

  process_resources(process_resources_target_name) {
    visibility = [ ":$final_target_name" ]

    resource_dirs = invoker.resource_dirs
    if (defined(invoker.custom_package)) {
      custom_package = invoker.custom_package
    }

    if (defined(invoker.v14_skip)) {
      v14_skip = invoker.v14_skip
    }

    if (defined(invoker.shared_resources)) {
      shared_resources = invoker.shared_resources
    }

    deps = [
      ":$build_config_target_name",
    ]
    if (defined(invoker.deps)) {
      # Invoker may have added deps that generate the input resources.
      deps += invoker.deps
    }
  }

  group(final_target_name) {
    if (defined(invoker.visibility)) {
      visibility = invoker.visibility
    }
    deps = [
      ":${target_name}__process_resources",
    ]
  }
}

# Declare a target that generates localized strings.xml from a .grd file.
#
# If this target is included in the deps of an android resources/library/apk,
# the strings.xml will be included with that target.
#
# Variables
#   deps: Specifies the dependencies of this target.
#   grd_file: Path to the .grd file to generate strings.xml from.
#   outputs: Expected grit outputs (see grit rule).
#
# Example
#  java_strings_grd("foo_strings_grd") {
#    grd_file = "foo_strings.grd"
#  }
template("java_strings_grd") {
  set_sources_assignment_filter([])
  if (defined(invoker.testonly)) {
    testonly = invoker.testonly
  }

  base_path = "$target_gen_dir/$target_name"
  resources_zip = base_path + ".resources.zip"
  build_config = base_path + ".build_config"

  write_build_config("${target_name}__build_config") {
    type = "android_resources"
    if (defined(invoker.deps)) {
      deps = invoker.deps
    }
  }

  # Put grit files into this subdirectory of target_gen_dir.
  extra_output_path = target_name + "_grit_output"

  grit_target_name = "${target_name}__grit"
  grit_output_dir = "$target_gen_dir/$extra_output_path"
  grit(grit_target_name) {
    grit_flags = [
      "-E",
      "ANDROID_JAVA_TAGGED_ONLY=false",
    ]
    output_dir = grit_output_dir
    resource_ids = ""
    source = invoker.grd_file
    outputs = invoker.outputs
  }

  # This needs to get outputs from grit's internal target, not the final
  # source_set.
  generate_strings_outputs = get_target_outputs(":${grit_target_name}_grit")

  zip("${target_name}__zip") {
    base_dir = grit_output_dir
    inputs = generate_strings_outputs
    output = resources_zip
    deps = [
      ":$grit_target_name",
    ]
  }

  group(target_name) {
    deps = [
      ":${target_name}__build_config",
      ":${target_name}__zip",
    ]
  }
}

# Declare a target that packages strings.xml generated from a grd file.
#
# If this target is included in the deps of an android resources/library/apk,
# the strings.xml will be included with that target.
#
# Variables
#  grit_output_dir: directory containing grit-generated files.
#  generated_files: list of android resource files to package.
#
# Example
#  java_strings_grd_prebuilt("foo_strings_grd") {
#    grit_output_dir = "$root_gen_dir/foo/grit"
#    generated_files = [
#      "values/strings.xml"
#    ]
#  }
template("java_strings_grd_prebuilt") {
  set_sources_assignment_filter([])
  if (defined(invoker.testonly)) {
    testonly = invoker.testonly
  }

  base_path = "$target_gen_dir/$target_name"
  resources_zip = base_path + ".resources.zip"
  build_config = base_path + ".build_config"

  build_config_target_name = "${target_name}__build_config"
  zip_target_name = "${target_name}__zip"
  final_target_name = target_name

  write_build_config(build_config_target_name) {
    visibility = [ ":$zip_target_name" ]
    type = "android_resources"
  }

  zip(zip_target_name) {
    visibility = [ ":$final_target_name" ]

    base_dir = invoker.grit_output_dir
    inputs = rebase_path(invoker.generated_files, ".", base_dir)
    output = resources_zip
    deps = [
      ":$build_config_target_name",
    ]
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
  }

  group(final_target_name) {
    if (defined(invoker.visibility)) {
      visibility = invoker.visibility
    }
    deps = [
      ":$zip_target_name",
    ]
  }
}

# Declare a Java executable target
#
# This target creates an executable from java code and libraries. The executable
# will be in the output folder's /bin/ directory.
#
# Variables
#   deps: Specifies the dependencies of this target. Java targets in this list
#     will be included in the executable (and the javac classpath).
#
#   java_files: List of .java files included in this library.
#   srcjar_deps: List of srcjar dependencies. The .java files in the srcjars
#     will be added to java_files and be included in this library.
#   srcjars: List of srcjars to be included in this library, together with the
#     ones obtained from srcjar_deps.
#
#   bypass_platform_checks: Disables checks about cross-platform (Java/Android)
#     dependencies for this target. This will allow depending on an
#     android_library target, for example.
#
#   chromium_code: If true, extra analysis warning/errors will be enabled.
#   enable_errorprone: If true, enables the errorprone compiler.
#
#   data_deps, testonly
#
# Example
#   java_binary("foo") {
#     java_files = [ "org/chromium/foo/FooMain.java" ]
#     deps = [ ":bar_java" ]
#     main_class = "org.chromium.foo.FooMain"
#   }
template("java_binary") {
  set_sources_assignment_filter([])

  # TODO(cjhopman): This should not act like a java_library for dependents (i.e.
  # dependents shouldn't get the jar in their classpath, etc.).
  java_library_impl(target_name) {
    if (defined(invoker.DEPRECATED_java_in_dir)) {
      DEPRECATED_java_in_dir = invoker.DEPRECATED_java_in_dir
    }
    if (defined(invoker.chromium_code)) {
      chromium_code = invoker.chromium_code
    }
    if (defined(invoker.data_deps)) {
      deps = invoker.data_deps
    }
    if (defined(invoker.deps)) {
      deps = invoker.deps
    }
    if (defined(invoker.enable_errorprone)) {
      enable_errorprone = invoker.enable_errorprone
    }
    if (defined(invoker.java_files)) {
      java_files = invoker.java_files
    }
    if (defined(invoker.srcjar_deps)) {
      srcjar_deps = invoker.srcjar_deps
    }
    if (defined(invoker.srcjars)) {
      srcjars = invoker.srcjars
    }
    if (defined(invoker.bypass_platform_checks)) {
      bypass_platform_checks = invoker.bypass_platform_checks
    }
    if (defined(invoker.testonly)) {
      testonly = invoker.testonly
    }

    supports_android = false
    main_class = invoker.main_class
  }
}

# Declare a Junit executable target
#
# This target creates an executable from java code for running as a junit test
# suite. The executable will be in the output folder's /bin/ directory.
#
# Variables
#   deps: Specifies the dependencies of this target. Java targets in this list
#     will be included in the executable (and the javac classpath).
#
#   java_files: List of .java files included in this library.
#   srcjar_deps: List of srcjar dependencies. The .java files in the srcjars
#     will be added to java_files and be included in this library.
#   srcjars: List of srcjars to be included in this library, together with the
#     ones obtained from srcjar_deps.
#
#   chromium_code: If true, extra analysis warning/errors will be enabled.
#
# Example
#   junit_binary("foo") {
#     java_files = [ "org/chromium/foo/FooTest.java" ]
#     deps = [ ":bar_java" ]
#   }
template("junit_binary") {
  set_sources_assignment_filter([])

  java_binary(target_name) {
    bypass_platform_checks = true
    main_class = "org.chromium.testing.local.JunitTestMain"
    testonly = true

    if (defined(invoker.DEPRECATED_java_in_dir)) {
      DEPRECATED_java_in_dir = invoker.DEPRECATED_java_in_dir
    }
    if (defined(invoker.chromium_code)) {
      chromium_code = invoker.chromium_code
    }
    deps = [
      "//testing/android/junit:junit_test_support",
      "//third_party/junit",
      "//third_party/mockito:mockito_java",
      "//third_party/robolectric:robolectric_java",
      "//third_party/robolectric:android-all-4.3_r2-robolectric-0",
    ]
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
    if (defined(invoker.java_files)) {
      java_files = invoker.java_files
    }
    if (defined(invoker.srcjar_deps)) {
      srcjar_deps = invoker.srcjar_deps
    }
    if (defined(invoker.srcjars)) {
      srcjars = invoker.srcjars
    }
  }
}

# Declare a java library target
#
# Variables
#   deps: Specifies the dependencies of this target. Java targets in this list
#     will be added to the javac classpath.
#
#   java_files: List of .java files included in this library.
#   srcjar_deps: List of srcjar dependencies. The .java files in the srcjars
#     will be added to java_files and be included in this library.
#   srcjars: List of srcjars to be included in this library, together with the
#     ones obtained from srcjar_deps.
#   DEPRECATED_java_in_dir: Directory containing java files. All .java files in
#     this directory will be included in the library. This is only supported to
#     ease the gyp->gn conversion and will be removed in the future.
#
#   chromium_code: If true, extra analysis warning/errors will be enabled.
#   enable_errorprone: If true, enables the errorprone compiler.
#
#   jar_excluded_patterns: List of patterns of .class files to exclude from the
#     final jar.
#
#   proguard_preprocess: If true, proguard preprocessing will be run. This can
#     be used to remove unwanted parts of the library.
#   proguard_config: Path to the proguard config for preprocessing.
#
#   supports_android: If true, Android targets (android_library, android_apk)
#     may depend on this target. Note: if true, this target must only use the
#     subset of Java available on Android.
#   bypass_platform_checks: Disables checks about cross-platform (Java/Android)
#     dependencies for this target. This will allow depending on an
#     android_library target, for example.
#
#   data_deps, testonly
#
# Example
#   java_library("foo_java") {
#     java_files = [
#       "org/chromium/foo/Foo.java",
#       "org/chromium/foo/FooInterface.java",
#       "org/chromium/foo/FooService.java",
#     ]
#     deps = [
#       ":bar_java"
#     ]
#     srcjar_deps = [
#       ":foo_generated_enum"
#     ]
#     jar_excluded_patterns = [
#       "*/FooService.class", "*/FooService##*.class"
#     ]
#   }
template("java_library") {
  set_sources_assignment_filter([])
  java_library_impl(target_name) {
    if (defined(invoker.DEPRECATED_java_in_dir)) {
      DEPRECATED_java_in_dir = invoker.DEPRECATED_java_in_dir
    }
    if (defined(invoker.chromium_code)) {
      chromium_code = invoker.chromium_code
    }
    if (defined(invoker.data_deps)) {
      deps = invoker.data_deps
    }
    if (defined(invoker.deps)) {
      deps = invoker.deps
    }
    if (defined(invoker.enable_errorprone)) {
      enable_errorprone = invoker.enable_errorprone
    }
    if (defined(invoker.jar_excluded_patterns)) {
      jar_excluded_patterns = invoker.jar_excluded_patterns
    }
    if (defined(invoker.java_files)) {
      java_files = invoker.java_files
    }
    if (defined(invoker.proguard_config)) {
      proguard_config = invoker.proguard_config
    }
    if (defined(invoker.proguard_preprocess)) {
      proguard_preprocess = invoker.proguard_preprocess
    }
    if (defined(invoker.srcjar_deps)) {
      srcjar_deps = invoker.srcjar_deps
    }
    if (defined(invoker.srcjars)) {
      srcjars = invoker.srcjars
    }
    if (defined(invoker.bypass_platform_checks)) {
      bypass_platform_checks = invoker.bypass_platform_checks
    }
    if (defined(invoker.testonly)) {
      testonly = invoker.testonly
    }
    if (defined(invoker.jar_path)) {
      jar_path = invoker.jar_path
    }

    if (defined(invoker.supports_android) && invoker.supports_android) {
      supports_android = true
    }
  }
}

# Declare a java library target for a prebuilt jar
#
# Variables
#   deps: Specifies the dependencies of this target. Java targets in this list
#     will be added to the javac classpath.
#   jar_path: Path to the prebuilt jar.
#   jar_dep: Target that builds jar_path (optional).
#   proguard_preprocess: If true, proguard preprocessing will be run. This can
#     be used to remove unwanted parts of the library.
#   proguard_config: Path to the proguard config for preprocessing.
#
# Example
#   java_prebuilt("foo_java") {
#     jar_path = "foo.jar"
#     deps = [
#       ":foo_resources",
#       ":bar_java"
#     ]
#   }
template("java_prebuilt") {
  set_sources_assignment_filter([])
  java_prebuilt_impl(target_name) {
    jar_path = invoker.jar_path
    if (defined(invoker.jar_dep)) {
      jar_dep = invoker.jar_dep
    }
    if (defined(invoker.testonly)) {
      testonly = invoker.testonly
    }
    if (defined(invoker.deps)) {
      deps = invoker.deps
    }
    if (defined(invoker.data_deps)) {
      data_deps = invoker.data_deps
    }
    if (defined(invoker.proguard_config)) {
      proguard_config = invoker.proguard_config
    }
    if (defined(invoker.proguard_preprocess)) {
      proguard_preprocess = invoker.proguard_preprocess
    }
  }
}

# Declare an Android library target
#
# This target creates an Android library containing java code and Android
# resources.
#
# Variables
#   deps: Specifies the dependencies of this target. Java targets in this list
#     will be added to the javac classpath. Android resources in dependencies
#     will be used when building this library.
#
#   java_files: List of .java files included in this library.
#   srcjar_deps: List of srcjar dependencies. The .java files in the srcjars
#     will be added to java_files and be included in this library.
#   srcjars: List of srcjars to be included in this library, together with the
#     ones obtained from srcjar_deps.
#   DEPRECATED_java_in_dir: Directory containing java files. All .java files in
#     this directory will be included in the library. This is only supported to
#     ease the gyp->gn conversion and will be removed in the future.
#
#   chromium_code: If true, extra analysis warning/errors will be enabled.
#   enable_errorprone: If true, enables the errorprone compiler.
#
#   jar_excluded_patterns: List of patterns of .class files to exclude from the
#     final jar.
#
#   proguard_preprocess: If true, proguard preprocessing will be run. This can
#     be used to remove unwanted parts of the library.
#   proguard_config: Path to the proguard config for preprocessing.
#
#   dex_path: If set, the resulting .dex.jar file will be placed under this
#     path.
#
#
# Example
#   android_library("foo_java") {
#     java_files = [
#       "android/org/chromium/foo/Foo.java",
#       "android/org/chromium/foo/FooInterface.java",
#       "android/org/chromium/foo/FooService.java",
#     ]
#     deps = [
#       ":bar_java"
#     ]
#     srcjar_deps = [
#       ":foo_generated_enum"
#     ]
#     jar_excluded_patterns = [
#       "*/FooService.class", "*/FooService##*.class"
#     ]
#   }
template("android_library") {
  set_sources_assignment_filter([])
  assert(!defined(invoker.jar_path),
         "android_library does not support a custom jar path")
  java_library_impl(target_name) {
    if (defined(invoker.DEPRECATED_java_in_dir)) {
      DEPRECATED_java_in_dir = invoker.DEPRECATED_java_in_dir
    }
    if (defined(invoker.chromium_code)) {
      chromium_code = invoker.chromium_code
    }
    if (defined(invoker.data_deps)) {
      deps = invoker.data_deps
    }
    if (defined(invoker.deps)) {
      deps = invoker.deps
    }
    if (defined(invoker.enable_errorprone)) {
      enable_errorprone = invoker.enable_errorprone
    }
    if (defined(invoker.jar_excluded_patterns)) {
      jar_excluded_patterns = invoker.jar_excluded_patterns
    }
    if (defined(invoker.java_files)) {
      java_files = invoker.java_files
    }
    if (defined(invoker.proguard_config)) {
      proguard_config = invoker.proguard_config
    }
    if (defined(invoker.proguard_preprocess)) {
      proguard_preprocess = invoker.proguard_preprocess
    }
    if (defined(invoker.srcjar_deps)) {
      srcjar_deps = invoker.srcjar_deps
    }
    if (defined(invoker.srcjars)) {
      srcjars = invoker.srcjars
    }
    if (defined(invoker.testonly)) {
      testonly = invoker.testonly
    }
    if (defined(invoker.visibility)) {
      visibility = invoker.visibility
    }
    if (defined(invoker.dex_path)) {
      dex_path = invoker.dex_path
    }
    if (defined(invoker.manifest_entries)) {
      manifest_entries = invoker.manifest_entries
    }

    supports_android = true
    requires_android = true

    if (!defined(jar_excluded_patterns)) {
      jar_excluded_patterns = []
    }
    jar_excluded_patterns += [
      "*/R.class",
      "*/R##*.class",
      "*/Manifest.class",
      "*/Manifest##*.class",
    ]
  }
}

# Declare a target that packages a set of Java dependencies into a standalone
# .dex.jar.
#
# Variables
#   deps: specifies the dependencies of this target. Android libraries in deps
#     will be packaged into the resulting .dex.jar file.
#   dex_path: location at which the output file will be put
template("android_standalone_library") {
  set_sources_assignment_filter([])
  deps_dex(target_name) {
    deps = invoker.deps
    dex_path = invoker.dex_path
    if (defined(invoker.excluded_jars)) {
      excluded_jars = invoker.excluded_jars
    }
  }
}

# Declare an Android library target for a prebuilt jar
#
# This target creates an Android library containing java code and Android
# resources.
#
# Variables
#   deps: Specifies the dependencies of this target. Java targets in this list
#     will be added to the javac classpath. Android resources in dependencies
#     will be used when building this library.
#   jar_path: Path to the prebuilt jar.
#   proguard_preprocess: If true, proguard preprocessing will be run. This can
#     be used to remove unwanted parts of the library.
#   proguard_config: Path to the proguard config for preprocessing.
#
# Example
#   android_java_prebuilt("foo_java") {
#     jar_path = "foo.jar"
#     deps = [
#       ":foo_resources",
#       ":bar_java"
#     ]
#   }
template("android_java_prebuilt") {
  set_sources_assignment_filter([])
  java_prebuilt_impl(target_name) {
    jar_path = invoker.jar_path
    supports_android = true
    requires_android = true
    if (defined(invoker.testonly)) {
      testonly = invoker.testonly
    }
    if (defined(invoker.deps)) {
      deps = invoker.deps
    }
    if (defined(invoker.data_deps)) {
      data_deps = invoker.data_deps
    }
    if (defined(invoker.proguard_config)) {
      proguard_config = invoker.proguard_config
    }
    if (defined(invoker.proguard_preprocess)) {
      proguard_preprocess = invoker.proguard_preprocess
    }
  }
}

# Declare an Android apk target
#
# This target creates an Android APK containing java code, resources, assets,
# and (possibly) native libraries.
#
# Variables
#   android_manifest: Path to AndroidManifest.xml.
#   android_manifest_dep: Target that generates AndroidManifest (if applicable)
#   data_deps: List of dependencies needed at runtime. These will be built but
#     won't change the generated .apk in any way (in fact they may be built
#     after the .apk is).
#   deps: List of dependencies. All Android java resources and libraries in the
#     "transitive closure" of these dependencies will be included in the apk.
#     Note: this "transitive closure" actually only includes such targets if
#     they are depended on through android_library or android_resources targets
#     (and so not through builtin targets like 'action', 'group', etc).
#   java_files: List of .java files to include in the apk.
#   srcjar_deps: List of srcjar dependencies. The .java files in the srcjars
#      will be added to java_files and be included in this apk.
#   apk_name: Name for final apk.
#   final_apk_path: Path to final built apk. Default is
#     $root_out_dir/apks/$apk_name.apk. Setting this will override apk_name.
#   native_libs: List paths of native libraries to include in this apk. If these
#     libraries depend on other shared_library targets, those dependencies will
#     also be included in the apk.
#   apk_under_test: For an instrumentation test apk, this is the target of the
#     tested apk.
#   include_all_resources - If true include all resource IDs in all generated
#     R.java files.
#   testonly: Marks this target as "test-only".
#
#   DEPRECATED_java_in_dir: Directory containing java files. All .java files in
#     this directory will be included in the library. This is only supported to
#     ease the gyp->gn conversion and will be removed in the future.
#
# Example
#   android_apk("foo_apk") {
#     android_manifest = "AndroidManifest.xml"
#     java_files = [
#       "android/org/chromium/foo/FooApplication.java",
#       "android/org/chromium/foo/FooActivity.java",
#     ]
#     deps = [
#       ":foo_support_java"
#       ":foo_resources"
#     ]
#     srcjar_deps = [
#       ":foo_generated_enum"
#     ]
#     native_libs = [
#       native_lib_path
#     ]
#   }
template("android_apk") {
  set_sources_assignment_filter([])
  if (defined(invoker.testonly)) {
    testonly = invoker.testonly
  }

  assert(defined(invoker.final_apk_path) || defined(invoker.apk_name))
  assert(defined(invoker.android_manifest))
  gen_dir = "$target_gen_dir/$target_name"
  base_path = "$gen_dir/$target_name"
  _build_config = "$target_gen_dir/$target_name.build_config"
  resources_zip_path = "$base_path.resources.zip"
  _all_resources_zip_path = "$base_path.resources.all.zip"
  jar_path = "$base_path.jar"
  _template_name = target_name

  final_dex_path = "$gen_dir/classes.dex"
  final_dex_target_name = "${_template_name}__final_dex"

  _final_apk_path = ""
  if (defined(invoker.final_apk_path)) {
    _final_apk_path = invoker.final_apk_path
  } else if (defined(invoker.apk_name)) {
    _final_apk_path = "$root_build_dir/apks/" + invoker.apk_name + ".apk"
  }
  _dist_jar_path_list =
      process_file_template(
          [ _final_apk_path ],
          "$root_build_dir/test.lib.java/{{source_name_part}}.jar")
  _dist_jar_path = _dist_jar_path_list[0]

  _native_libs = []

  _version_code = "1"
  if (defined(invoker.version_code)) {
    _version_code = invoker.version_code
  }

  _version_name = "Developer Build"
  if (defined(invoker.version_name)) {
    _version_name = invoker.version_name
  }
  _keystore_path = android_default_keystore_path
  _keystore_name = android_default_keystore_name
  _keystore_password = android_default_keystore_password

  if (defined(invoker.keystore_path)) {
    _keystore_path = invoker.keystore_path
    _keystore_name = invoker.keystore_name
    _keystore_password = invoker.keystore_password
  }

  _srcjar_deps = []
  if (defined(invoker.srcjar_deps)) {
    _srcjar_deps += invoker.srcjar_deps
  }

  _load_library_from_apk = false

  # The dependency that makes the chromium linker, if any is needed.
  _chromium_linker_dep = []

  if (defined(invoker.native_libs)) {
    _use_chromium_linker = false
    if (defined(invoker.use_chromium_linker)) {
      _use_chromium_linker =
          invoker.use_chromium_linker && chromium_linker_supported
      _chromium_linker_dep = [ "//base/android/linker:chromium_android_linker" ]
    }

    if (defined(invoker.load_library_from_apk) &&
        invoker.load_library_from_apk) {
      _load_library_from_apk = true
      assert(_use_chromium_linker,
             "Loading library from the apk requires use" +
                 " of the Chromium linker.")
    }

    _enable_relocation_packing = false
    if (defined(invoker.enable_relocation_packing) &&
        invoker.enable_relocation_packing) {
      _enable_relocation_packing = relocation_packing_supported
      assert(_use_chromium_linker,
             "Relocation packing requires use of the" + " Chromium linker.")
    }

    if (is_component_build) {
      _native_libs += [ "$root_out_dir/lib.stripped/libc++_shared.so" ]
      _chromium_linker_dep += [ "//build/android:cpplib_stripped" ]
    }

    # Allow native_libs to be in the form "foo.so" or "foo.cr.so"
    _first_ext_removed =
        process_file_template(invoker.native_libs, "{{source_name_part}}")
    _native_libs += process_file_template(
            _first_ext_removed,
            "$root_build_dir/lib.stripped/{{source_name_part}}$android_product_extension")

    _native_libs_dir = base_path + "/libs"

    if (_use_chromium_linker) {
      _native_libs += [ "$root_build_dir/lib.stripped/libchromium_android_linker$android_product_extension" ]
    }

    _enable_relocation_packing = false
    if (_use_chromium_linker && defined(invoker.enable_relocation_packing) &&
        invoker.enable_relocation_packing) {
      _enable_relocation_packing = true
    }

    _native_lib_version_rule = ""
    if (defined(invoker.native_lib_version_rule)) {
      _native_lib_version_rule = invoker.native_lib_version_rule
    }
    _native_lib_version_arg = "\"\""
    if (defined(invoker.native_lib_version_arg)) {
      _native_lib_version_arg = invoker.native_lib_version_arg
    }
  }

  _android_manifest_deps = []
  if (defined(invoker.android_manifest_dep)) {
    _android_manifest_deps = [ invoker.android_manifest_dep ]
  }
  _android_manifest = invoker.android_manifest

  _rebased_build_config = rebase_path(_build_config, root_build_dir)
  _create_abi_split =
      defined(invoker.create_abi_split) && invoker.create_abi_split
  _create_density_splits =
      defined(invoker.create_density_splits) && invoker.create_density_splits

  # Help GN understand that _create_abi_split is not unused (bug in GN).
  assert(_create_abi_split || true)

  build_config_target = "${_template_name}__build_config"
  write_build_config(build_config_target) {
    type = "android_apk"
    dex_path = final_dex_path
    resources_zip = resources_zip_path
    build_config = _build_config
    android_manifest = _android_manifest

    deps = _chromium_linker_dep + _android_manifest_deps
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }

    if (defined(invoker.apk_under_test)) {
      apk_under_test = invoker.apk_under_test
    }

    native_libs = _native_libs
  }

  final_deps = []

  process_resources_target = "${_template_name}__process_resources"
  final_deps += [ ":$process_resources_target" ]
  process_resources(process_resources_target) {
    srcjar_path = "${target_gen_dir}/${target_name}.srcjar"
    r_text_path = "${target_gen_dir}/${target_name}_R.txt"
    android_manifest = _android_manifest
    resource_dirs = [ "//build/android/ant/empty/res" ]
    zip_path = resources_zip_path
    all_resources_zip_path = _all_resources_zip_path
    generate_constant_ids = true

    if (defined(invoker.include_all_resources)) {
      include_all_resources = invoker.include_all_resources
    }

    build_config = _build_config
    deps = _android_manifest_deps + [ ":$build_config_target" ]
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
  }
  _srcjar_deps += [ ":$process_resources_target" ]

  if (_native_libs != []) {
    _enable_chromium_linker_tests = false
    if (defined(invoker.enable_chromium_linker_tests)) {
      _enable_chromium_linker_tests = invoker.enable_chromium_linker_tests
    }

    java_cpp_template("${_template_name}__native_libraries_java") {
      package_name = "org/chromium/base/library_loader"
      sources = [
        "//base/android/java/templates/NativeLibraries.template",
      ]
      inputs = [
        _build_config,
      ]
      deps = [
        ":$build_config_target",
      ]
      if (_native_lib_version_rule != "") {
        deps += [ _native_lib_version_rule ]
      }

      defines = [
        "NATIVE_LIBRARIES_LIST=" +
            "@FileArg($_rebased_build_config:native:java_libraries_list)",
        "NATIVE_LIBRARIES_VERSION_NUMBER=$_native_lib_version_arg",
      ]
      if (_use_chromium_linker) {
        defines += [ "ENABLE_CHROMIUM_LINKER" ]
      }
      if (_load_library_from_apk) {
        defines += [ "ENABLE_CHROMIUM_LINKER_LIBRARY_IN_ZIP_FILE" ]
      }
      if (_enable_chromium_linker_tests) {
        defines += [ "ENABLE_CHROMIUM_LINKER_TESTS" ]
      }
    }
    _srcjar_deps += [ ":${_template_name}__native_libraries_java" ]
  }

  java_target = "${_template_name}__java"
  final_deps += [ ":$java_target" ]
  java_library_impl(java_target) {
    supports_android = true
    requires_android = true
    override_build_config = _build_config
    deps = _android_manifest_deps + [ ":$build_config_target" ]

    android_manifest = _android_manifest
    chromium_code = true
    if (defined(invoker.java_files)) {
      java_files = invoker.java_files
    } else if (defined(invoker.DEPRECATED_java_in_dir)) {
      DEPRECATED_java_in_dir = invoker.DEPRECATED_java_in_dir
    } else {
      java_files = []
    }
    srcjar_deps = _srcjar_deps
    dex_path = base_path + ".dex.jar"

    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
  }

  if (_dist_jar_path != "") {
    create_dist_target = "${_template_name}__create_dist_jar"
    final_deps += [ ":$create_dist_target" ]

    # TODO(cjhopman): This is only ever needed to calculate the list of tests to
    # run. See build/android/pylib/instrumentation/test_jar.py. We should be
    # able to just do that calculation at build time instead.
    action(create_dist_target) {
      script = "//build/android/gyp/create_dist_jar.py"
      depfile = "$target_gen_dir/$target_name.d"
      inputs = [
        _build_config,
      ]
      outputs = [
        depfile,
        _dist_jar_path,
      ]
      args = [
        "--depfile",
        rebase_path(depfile, root_build_dir),
        "--output",
        rebase_path(_dist_jar_path, root_build_dir),
        "--inputs=@FileArg($_rebased_build_config:dist_jar:dependency_jars)",
      ]
      inputs += [ jar_path ]
      _rebased_jar_path = rebase_path([ jar_path ], root_build_dir)
      args += [ "--inputs=$_rebased_jar_path" ]
      deps = [
        ":$build_config_target",  # Generates the build config file.
        ":$java_target",  # Generates the jar file.
      ]
    }
  }

  final_deps += [ ":$final_dex_target_name" ]
  dex("${final_dex_target_name}_jar") {
    deps = [
      ":$build_config_target",
      ":$java_target",
    ]
    sources = [
      jar_path,
    ]
    inputs = [
      _build_config,
    ]
    output = "${final_dex_path}.jar"
    dex_arg_key = "${_rebased_build_config}:final_dex:dependency_dex_files"
    args = [ "--inputs=@FileArg($dex_arg_key)" ]
  }

  dex("$final_dex_target_name") {
    deps = [
      ":${final_dex_target_name}_jar",
    ]
    sources = [
      "${final_dex_path}.jar",
    ]
    output = final_dex_path
  }

  if (_native_libs != []) {
    action("${_template_name}__prepare_native") {
      script = "//build/android/gyp/pack_relocations.py"
      packed_libraries_dir = "$_native_libs_dir/$android_app_abi"
      depfile = "$target_gen_dir/$target_name.d"
      outputs = [
        depfile,
      ]

      inputs = _native_libs
      deps = _chromium_linker_dep

      inputs += [ _build_config ]
      deps += [ ":$build_config_target" ]

      skip_packing_list = [
        "gdbserver",
        "libchromium_android_linker$android_product_extension",
      ]

      enable_packing_arg = 0
      if (_enable_relocation_packing) {
        enable_packing_arg = 1
        deps += [ relocation_packer_target ]
      }

      args = [
        "--depfile",
        rebase_path(depfile, root_build_dir),
        "--enable-packing=$enable_packing_arg",
        "--exclude-packing-list=$skip_packing_list",
        "--android-pack-relocations",
        rebase_path(relocation_packer_exe, root_build_dir),
        "--stripped-libraries-dir",
        rebase_path(root_build_dir, root_build_dir),
        "--packed-libraries-dir",
        rebase_path(packed_libraries_dir, root_build_dir),
        "--libraries=@FileArg(${_rebased_build_config}:native:libraries)",
        "--clear-dir",
      ]

      if (defined(invoker.deps)) {
        deps += invoker.deps
      }
      if (defined(invoker.public_deps)) {
        public_deps = invoker.public_deps
      }
      if (defined(invoker.data_deps)) {
        data_deps = invoker.data_deps
      }

      if (is_debug) {
        rebased_gdbserver = rebase_path([ android_gdbserver ], root_build_dir)
        inputs += [ android_gdbserver ]
        args += [ "--libraries=$rebased_gdbserver" ]
      }
    }
  }

  final_deps += [ ":${_template_name}__create" ]
  create_apk("${_template_name}__create") {
    apk_path = _final_apk_path
    android_manifest = _android_manifest
    resources_zip = _all_resources_zip_path
    dex_path = final_dex_path
    load_library_from_apk = _load_library_from_apk
    create_density_splits = _create_density_splits
    if (defined(invoker.language_splits)) {
      language_splits = invoker.language_splits
    }
    if (defined(invoker.extensions_to_not_compress)) {
      extensions_to_not_compress = invoker.extensions_to_not_compress
    } else {
      # Allow icu data, v8 snapshots, and pak files to be loaded directly from
      # the .apk.
      # Note: These are actually suffix matches, not necessarily extensions.
      extensions_to_not_compress = ".dat,.bin,.pak"
    }

    version_code = _version_code
    version_name = _version_name

    keystore_name = _keystore_name
    keystore_path = _keystore_path
    keystore_password = _keystore_password

    # This target generates the input file _all_resources_zip_path.
    deps = _android_manifest_deps + [
             ":$process_resources_target",
             ":$final_dex_target_name",
           ]
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }

    if (defined(invoker.asset_location)) {
      asset_location = invoker.asset_location

      # We don't know the exact dependencies that create the assets in
      # |asset_location|; we depend on all caller deps until a better solution
      # is figured out (http://crbug.com/433330).
      if (defined(invoker.deps)) {
        deps += invoker.deps
      }
    }

    if (_native_libs != [] && !_create_abi_split) {
      native_libs_dir = _native_libs_dir
      deps += [ ":${_template_name}__prepare_native" ]
    }
  }

  if (_native_libs != [] && _create_abi_split) {
    _manifest_rule = "${_template_name}__split_manifest_abi_${android_app_abi}"
    generate_split_manifest(_manifest_rule) {
      main_manifest = _android_manifest
      out_manifest =
          "$gen_dir/split-manifests/${android_app_abi}/AndroidManifest.xml"
      split_name = "abi_${android_app_abi}"
      deps = _android_manifest_deps
    }

    _apk_rule = "${_template_name}__split_apk_abi_${android_app_abi}"
    final_deps += [ ":$_apk_rule" ]
    create_apk(_apk_rule) {
      _split_paths = process_file_template(
              [ _final_apk_path ],
              "{{source_dir}}/{{source_name_part}}-abi-${android_app_abi}.apk")
      apk_path = _split_paths[0]
      base_path = "$gen_dir/$_apk_rule"

      manifest_outputs = get_target_outputs(":${_manifest_rule}")
      android_manifest = manifest_outputs[1]
      load_library_from_apk = _load_library_from_apk

      version_code = _version_code
      version_name = _version_name

      keystore_name = _keystore_name
      keystore_path = _keystore_path
      keystore_password = _keystore_password

      native_libs_dir = _native_libs_dir
      deps = [
        ":${_template_name}__prepare_native",
        ":${_manifest_rule}",
      ]
    }
  }

  if (defined(invoker.flutter_dist_jar)) {
    flutter_jar_target = "${_template_name}__create_flutter_jar"
    final_deps += [ ":$flutter_jar_target" ]

    action(flutter_jar_target) {
      script = "//build/android/gyp/create_flutter_jar.py"
      depfile = "$target_gen_dir/$target_name.d"
      inputs = [
        _dist_jar_path,
      ]
      outputs = [
        invoker.flutter_dist_jar,
      ]
      args = [
        "--depfile",
        rebase_path(depfile, root_build_dir),
        "--output",
        rebase_path(invoker.flutter_dist_jar, root_build_dir),
        "--dist_jar",
        rebase_path(_dist_jar_path, root_build_dir),
        "--android_abi",
        "$android_app_abi",
        "--asset_dir",
        rebase_path(invoker.asset_location, root_build_dir),
      ]
      foreach(native_lib, rebase_path(_native_libs, root_build_dir)) {
        args += [
          "--native_lib",
          native_lib,
        ]
      }
      deps = [
        ":$create_dist_target",
        ":${_template_name}__prepare_native"
      ]
      if (defined(invoker.deps)) {
        deps += invoker.deps
      }
    }
  }

  group(target_name) {
    deps = final_deps
    if (defined(invoker.data_deps)) {
      data_deps = invoker.data_deps
    }
  }
}

# Declare an Android instrumentation test apk
#
# This target creates an Android instrumentation test apk.
#
# Variables
#   android_manifest: Path to AndroidManifest.xml.
#   data_deps: List of dependencies needed at runtime. These will be built but
#     won't change the generated .apk in any way (in fact they may be built
#     after the .apk is).
#   deps: List of dependencies. All Android java resources and libraries in the
#     "transitive closure" of these dependencies will be included in the apk.
#     Note: this "transitive closure" actually only includes such targets if
#     they are depended on through android_library or android_resources targets
#     (and so not through builtin targets like 'action', 'group', etc).
#   java_files: List of .java files to include in the apk.
#   srcjar_deps: List of srcjar dependencies. The .java files in the srcjars
#      will be added to java_files and be included in this apk.
#   apk_name: Name for final apk.
#   support_apk_path: Path to a support apk. If present, the test runner script
#      will install it on the device before running the instrumentation tests.
#      Should be a path relative to the src root.
#   final_apk_path: Path to final built apk. Default is
#     $root_out_dir/apks/$apk_name.apk. Setting this will override apk_name.
#   native_libs: List paths of native libraries to include in this apk. If these
#     libraries depend on other shared_library targets, those dependencies will
#     also be included in the apk.
#   apk_under_test: The apk being tested.
#   isolate_file: Isolate file containing the list of test data dependencies.
#
#   DEPRECATED_java_in_dir: Directory containing java files. All .java files in
#     this directory will be included in the library. This is only supported to
#     ease the gyp->gn conversion and will be removed in the future.
#
# Example
#   instrumentation_test_apk("foo_test_apk") {
#     android_manifest = "AndroidManifest.xml"
#     apk_name = "FooTest"
#     apk_under_test = "Foo"
#     java_files = [
#       "android/org/chromium/foo/FooTestCase.java",
#       "android/org/chromium/foo/FooExampleTest.java",
#     ]
#     deps = [
#       ":foo_test_support_java"
#     ]
#   }
template("instrumentation_test_apk") {
  set_sources_assignment_filter([])
  testonly = true
  _template_name = target_name

  if (defined(invoker.apk_name)) {
    test_runner_data_dep = [ ":${_template_name}__test_runner_script" ]
    test_runner_script("${_template_name}__test_runner_script") {
      test_name = invoker.target_name
      test_type = "instrumentation"
      test_apk = invoker.apk_name
      if (defined(invoker.isolate_file)) {
        isolate_file = invoker.isolate_file
      }
      if (defined(invoker.support_apk_path)) {
        support_apk_path = invoker.support_apk_path
      }
    }
  }

  android_apk(target_name) {
    if (defined(invoker.android_manifest)) {
      android_manifest = invoker.android_manifest
    }
    data_deps = [
      "//testing/android/driver:driver_apk",
      "//tools/android/forwarder2",
      "//tools/android/md5sum",
    ]
    if (defined(test_runner_data_dep)) {
      data_deps += test_runner_data_dep
    }
    if (defined(invoker.data_deps)) {
      data_deps += invoker.data_deps
    }
    deps = [
      "//testing/android/broker:broker_java",
    ]
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
    if (defined(invoker.java_files)) {
      java_files = invoker.java_files
    }
    if (defined(invoker.srcjar_deps)) {
      srcjar_deps = invoker.srcjar_deps
    }
    if (defined(invoker.apk_name)) {
      apk_name = invoker.apk_name
    }
    if (defined(invoker.final_apk_path)) {
      final_apk_path = invoker.final_apk_path
    }
    if (defined(invoker.native_libs)) {
      native_libs = invoker.native_libs
    }
    if (defined(invoker.apk_under_test)) {
      apk_under_test = invoker.apk_under_test
    }
    if (defined(invoker.DEPRECATED_java_in_dir)) {
      DEPRECATED_java_in_dir = invoker.DEPRECATED_java_in_dir
    }
  }
}

# Declare an Android gtest apk
#
# This target creates an Android apk for running gtest-based unittests.
#
# Variables
#   deps: Specifies the dependencies of this target. These will be passed to
#     the underlying android_apk invocation and should include the java and
#     resource dependencies of the apk.
#   unittests_dep: This should be the label of the gtest native target. This
#     target must be defined previously in the same file.
#   unittests_binary: The basename of the library produced by the unittests_dep
#     target. If unspecified, it assumes the name of the unittests_dep target
#     (which will be correct unless that target specifies an "output_name".
#     TODO(brettw) make this automatic by allowing get_target_outputs to
#     support executables.
#   apk_name: The name of the produced apk. If unspecified, it uses the name
#             of the unittests_dep target postfixed with "_apk"
#
# Example
#   unittest_apk("foo_unittests_apk") {
#     deps = [ ":foo_java", ":foo_resources" ]
#     unittests_dep = ":foo_unittests"
#   }
template("unittest_apk") {
  set_sources_assignment_filter([])
  testonly = true

  assert(defined(invoker.unittests_dep), "Need unittests_dep for $target_name")

  test_suite_name = get_label_info(invoker.unittests_dep, "name")

  # This trivial assert is needed in case both unittests_binary and apk_name
  # are defined, as otherwise test_suite_name would not be used.
  assert(test_suite_name != "")

  if (defined(invoker.unittests_binary)) {
    unittests_binary = invoker.unittests_binary
  } else {
    unittests_binary = "lib${test_suite_name}${android_product_extension}"
  }

  if (defined(invoker.apk_name)) {
    apk_name = invoker.apk_name
  } else {
    apk_name = test_suite_name
  }

  android_apk(target_name) {
    final_apk_path = "$root_build_dir/${apk_name}_apk/${apk_name}-debug.apk"
    java_files = [
      "//testing/android/native_test/java/src/org/chromium/native_test/NativeBrowserTestActivity.java",
      "//testing/android/native_test/java/src/org/chromium/native_test/NativeTestActivity.java",
      "//testing/android/native_test/java/src/org/chromium/native_test/NativeUnitTestActivity.java",
      "//testing/android/native_test/java/src/org/chromium/native_test/NativeTestInstrumentationTestRunner.java",
    ]
    android_manifest = "//testing/android/native_test/java/AndroidManifest.xml"
    native_libs = [ unittests_binary ]
    if (defined(invoker.asset_location)) {
      asset_location = invoker.asset_location
    }
    deps = [
      "//base:base_java",
      "//build/android/pylib/remote/device/dummy:remote_device_dummy_apk",
      "//testing/android/appurify_support:appurify_support_java",
      "//testing/android/reporter:reporter_java",
    ]
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
    data_deps = [ "//tools/android/md5sum" ]
    if (host_os == "linux") {
      data_deps += [ "//tools/android/forwarder2" ]
    }
    if (defined(invoker.data_deps)) {
      data_deps += invoker.data_deps
    }
  }
}

# Generate .java files from .aidl files.
#
# This target will store the .java files in a srcjar and should be included in
# an android_library or android_apk's srcjar_deps.
#
# Variables
#   sources: Paths to .aidl files to compile.
#   import_include: Path to directory containing .java files imported by the
#     .aidl files.
#   interface_file: Preprocessed aidl file to import.
#
# Example
#   android_aidl("foo_aidl") {
#     import_include = "java/src"
#     sources = [
#       "java/src/com/foo/bar/FooBarService.aidl",
#       "java/src/com/foo/bar/FooBarServiceCallback.aidl",
#     ]
#   }
template("android_aidl") {
  set_sources_assignment_filter([])
  if (defined(invoker.testonly)) {
    testonly = invoker.testonly
  }

  srcjar_path = "${target_gen_dir}/${target_name}.srcjar"
  aidl_path = "${android_sdk_build_tools}/aidl"
  framework_aidl = "$android_sdk/framework.aidl"

  action(target_name) {
    script = "//build/android/gyp/aidl.py"
    sources = invoker.sources

    imports = [ framework_aidl ]
    if (defined(invoker.interface_file)) {
      assert(invoker.interface_file != "")
      imports += [ invoker.interface_file ]
    }

    inputs = [ aidl_path ] + imports

    depfile = "${target_gen_dir}/${target_name}.d"
    outputs = [
      depfile,
      srcjar_path,
    ]
    rebased_imports = rebase_path(imports, root_build_dir)
    args = [
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "--aidl-path",
      rebase_path(aidl_path, root_build_dir),
      "--imports=$rebased_imports",
      "--srcjar",
      rebase_path(srcjar_path, root_build_dir),
    ]
    if (defined(invoker.import_include) && invoker.import_include != "") {
      # TODO(cjhopman): aidl supports creating a depfile. We should be able to
      # switch to constructing a depfile for the overall action from that
      # instead of having all the .java files in the include paths as inputs.
      rebased_import_includes =
          rebase_path([ invoker.import_include ], root_build_dir)
      args += [ "--includes=$rebased_import_includes" ]

      _java_files_build_rel =
          exec_script("//build/android/gyp/find.py",
                      rebase_path([ invoker.import_include ], root_build_dir),
                      "list lines")
      _java_files = rebase_path(_java_files_build_rel, ".", root_build_dir)
      inputs += _java_files
    }
    args += rebase_path(sources, root_build_dir)
  }
}

# Creates a dist directory for a native executable.
#
# Running a native executable on a device requires all the shared library
# dependencies of that executable. To make it easier to install and run such an
# executable, this will create a directory containing the native exe and all
# it's library dependencies.
#
# Note: It's usually better to package things as an APK than as a native
# executable.
#
# Variables
#   dist_dir: Directory for the exe and libraries. Everything in this directory
#     will be deleted before copying in the exe and libraries.
#   binary: Path to (stripped) executable.
#
# Example
#   create_native_executable_dist("foo_dist") {
#     dist_dir = "$root_build_dir/foo_dist"
#     binary = "$root_build_dir/exe.stripped/foo"
#     deps = [ ":the_thing_that_makes_foo" ]
#   }
template("create_native_executable_dist") {
  set_sources_assignment_filter([])
  if (defined(invoker.testonly)) {
    testonly = invoker.testonly
  }

  dist_dir = invoker.dist_dir
  binary = invoker.binary
  template_name = target_name

  libraries_list =
      "${target_gen_dir}/${template_name}_library_dependencies.list"

  find_deps_target_name = "${template_name}__find_library_dependencies"
  copy_target_name = "${template_name}__copy_libraries_and_exe"

  stripped_libraries_dir = "$root_build_dir/lib.stripped"
  action(find_deps_target_name) {
    visibility = [ ":$copy_target_name" ]

    script = "//build/android/gyp/write_ordered_libraries.py"
    depfile = "$target_gen_dir/$target_name.d"
    inputs = [
      binary,
      android_readelf,
    ]
    outputs = [
      depfile,
      libraries_list,
    ]
    rebased_binaries = rebase_path([ binary ], root_build_dir)
    args = [
      "--depfile",
      rebase_path(depfile, root_build_dir),
      "--input-libraries=$rebased_binaries",
      "--libraries-dir",
      rebase_path(stripped_libraries_dir, root_build_dir),
      "--output",
      rebase_path(libraries_list, root_build_dir),
      "--readelf",
      rebase_path(android_readelf, root_build_dir),
    ]
    if (defined(invoker.deps)) {
      deps = invoker.deps
    }
  }

  copy_ex(copy_target_name) {
    visibility = [ ":$template_name" ]

    clear_dir = true
    inputs = [
      binary,
      libraries_list,
    ]
    dest = dist_dir
    rebased_binaries_list = rebase_path([ binary ], root_build_dir)
    rebased_libraries_list = rebase_path(libraries_list, root_build_dir)
    args = [
      "--files=$rebased_binaries_list",
      "--files=@FileArg($rebased_libraries_list:lib_paths)",
    ]

    deps = [
      ":$find_deps_target_name",
    ]
    if (defined(invoker.deps)) {
      deps += invoker.deps
    }
  }

  group(template_name) {
    if (defined(invoker.visibility)) {
      visibility = invoker.visibility
    }
    deps = [
      ":$copy_target_name",
    ]
  }
}

# Compile a protocol buffer to java.
#
# This generates java files from protocol buffers and creates an Android library
# containing the classes.
#
# Variables
#   sources: Paths to .proto files to compile.
#   proto_path: Root directory of .proto files.
#
# Example:
#  proto_java_library("foo_proto_java") {
#    proto_path = [ "src/foo" ]
#    sources = [ "$proto_path/foo.proto" ]
#  }
template("proto_java_library") {
  set_sources_assignment_filter([])
  _protoc_dep = "//third_party/android_protobuf:android_protoc($host_toolchain)"
  _protoc_out_dir = get_label_info(_protoc_dep, "root_out_dir")
  _protoc_bin = "$_protoc_out_dir/android_protoc"
  _proto_path = invoker.proto_path

  _template_name = target_name

  action("${_template_name}__protoc_java") {
    srcjar_path = "$target_gen_dir/$target_name.srcjar"
    script = "//build/protoc_java.py"
    deps = [
      _protoc_dep,
    ]
    sources = invoker.sources
    depfile = "$target_gen_dir/$target_name.d"
    outputs = [
      depfile,
      srcjar_path,
    ]
    args = [
             "--depfile",
             rebase_path(depfile, root_build_dir),
             "--protoc",
             rebase_path(_protoc_bin, root_build_dir),
             "--proto-path",
             rebase_path(_proto_path, root_build_dir),
             "--srcjar",
             rebase_path(srcjar_path, root_build_dir),
           ] + rebase_path(sources, root_build_dir)
  }

  android_library(target_name) {
    java_files = []
    srcjar_deps = [ ":${_template_name}__protoc_java" ]
    deps = [
      "//third_party/android_protobuf:protobuf_nano_javalib",
    ]
  }
}

# TODO(GYP): implement this.
template("uiautomator_test") {
  set_sources_assignment_filter([])
  if (defined(invoker.testonly)) {
    testonly = invoker.testonly
  }
  assert(target_name != "")
  assert(invoker.deps != [] || true)
  group(target_name) {
  }
}
